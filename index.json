[{"content":"Hier vind je de lesplanner, geplande toetsen en inlevermomenten voor 4 havo.\nLesplanner 2025/2026 Het is vandaag .\nData Theorieles (Woensdag) Praktijkles (Maandag + Vrijdag) 1 sep - 7 sep Introductie + Opstarten T1 Web Design Oefening: Khan 1 Intro to HTML 8 sep - 14 sep T1 Web Design Uitleg: HTML tags T1 Web Design Oefening: Khan 2 Intro to CSS + Khan 3 More HTML tags 15 sep - 21 sep T1 Web Design Uitleg: CSS selectors en properties T1 Web Design Oefening: Khan 4 CSS text properties + Oefening: Khan 6 CSS layout 22 sep - 28 sep T1 Web Design Uitleg: boxmodel 29 sep - 5 okt T1 Web Design Uitleg: floats T1 Web Design Oefening: Khan 7 More CSS selectors 6 okt - 12 okt T1 Web Design Uitleg: eye catchers T1 Web Design Oefentoets in Woots maken + bespreken 13 okt - 19 okt T2 Informatie Uitleg: bits O1 Website stap 1 eerste wijziging gemaakt 20 okt - 26 okt Herfstvakantie 27 okt - 2 nov T2 Informatie Uitleg: BIN O1 Website stap 2 menu + lege pagina’s 3 nov - 9 nov TW1: Toets 4V-IN-S01 over T1 Web Design 10 nov - 16 nov T2 Informatie Uitleg: HEX O1 Website stap 3 layout hoofdpagina 17 nov - 23 nov T2 Informatie Oefening: IA gestart O1 Website stap 4 inhoud en plaatjes hoofdpagina 24 nov - 30 nov T2 Informatie Oefening: IA t/m 3 O1 Website stap 5 layout subpagina’s 1 dec - 7 dec T2 Informatie Oefening: IA t/m 6 O1 Website stap 6 inhoud en plaatjes subpagina’s 8 dec - 14 dec T2 Informatie kleuren + plaatjes O1 Website stap 7 kleuren 15 dec - 21 dec T2 Informatie tekst + geluid + video + compressie O1 Website stap 8 perfectioneren 22 dec - 28 dec Kerstvakantie 29 dec - 4 jan Kerstvakantie 5 jan - 11 jan T2 Informatie Oefening: Beeldbewerking O1 Website stap 9 eyecathers 12 jan - 18 jan T2 Informatie Oefening: Beeldbewerking PO 4V-IN-S04 website inleveren 19 jan - 25 jan T3 Programmeren Uitleg: programmeertalen + P5JS T3 Oefening Khan t/m 5 Animation basics 26 jan - 1 feb T3 Programmeren Uitleg: variabelen T3 Oefening Khan t/m 10 Functions 2 feb - 8 feb T3 Programmeren Uitleg: functies T3 Oefening Khan t/m 11 Logic and if statements 9 feb - 15 feb T3 Programmeren Uitleg: logica en if T3 Oefening Khan t/m 13 Loopings 16 feb - 22 feb Voorjaarsvakantie 23 feb - 1 mrt T3 Programmeren Uitleg: loops (les) arrays (thuis kijken) T3 Oefening Khan t/m 15 Arrays 2 mrt - 8 mrt TW2: Toets 4V-IN-S02 over T2 Informatie 9 mrt - 15 mrt TW2 16 mrt - 22 mrt uitloop / herhaling / oefentoets uitloop / herhaling / oefentoets 23 mrt - 29 mrt T4 Algoritmen Uitleg: stroomdiagrammen O2 Game eerste wijziging gemaakt 30 mrt - 5 apr T4 Algoritmen Uitleg: lijsten O2 Game speler beweegt 6 apr - 12 apr T4 Algoritmen Uitleg: nesten O2 Game vijand 13 apr - 19 apr T4 Algoritmen Oefenen: eenvoudige algoritmen t/m 2 O2 Game botsingdetectie + afgaan 20 apr - 26 apr meivakantie 27 apr - 3 mei meivakantie 4 mei - 10 mei T4 Algoritmen Oefenen: eenvoudige algoritmen t/m 4 O2 Game punten + gameoverscherm 11 mei - 17 mei T4 Algoritmen Oefenen: eenvoudige algoritmen t/m 6 O2 Game uitlegscherm (je hebt nu een speelbaar spel) 18 mei - 24 mei T4 Algoritmen Oefenen: eenvoudige algoritmen t/m 8 O2 Game werk aan uitbreiding 25 mei - 31 mei T4 Algoritmen Oefenen: eenvoudige algoritmen t/m 10 O2 Game werk aan uitbreiding 1 jun - 7 jun T4 Algoritmen Oefenen: oefentoets algoritmen O2 Game werk aan uitbreiding 8 jun - 14 jun T4 Algoritmen Nabespreken: oefentoets algoritmen O2 Game uitbreiding afmaken PO 4V-IN-S05 game inleveren 15 jun - 21 jun uitloop / herhaling / oefentoets uitloop / herhaling / oefentoets 22 jun - 28 jun TW3: Toets 4V-IN-S03 over T3 Programmeren + T4 Algoritmen 29 jun - 5 jul TW3 6 jul - 12 jul Lesvrije week 13 jul - 19 jul Lesvrije week 20 jul - 26 jul Zomervakantie Toetsen en inlevermomenten Datum Code Toetsvorm Stof Toetsweek 1 4H-IN-S01 Digitale toets T1 Web Design Zaterdag 17 19 jan 2025 23:59 4H-IN-S04 Praktische Opdracht O1 Website Toetsweek 2 4H-IN-S02 Digitale toets T2 Digitale Informatie Zaterdag 13 juni 2025 23:59 4H-IN-S05 Praktische Opdracht O2 Game Toetsweek 3 4H-IN-S03 Digitale Toets T3 Programmeren + T4 Algoritmen ","description":"","tags":null,"title":"4 havo","uri":"/planning/4h/"},{"content":"Khan Academy is internationale online lesmethode met cursussen voor diverse onderwerpen. Wij gebruiken enkele cursussen uit de sectie Computer Programming.\nDe eerste keer inloggen op Khan Academy Start je browser (Chrome werkt het best) en ga naar https://www.khanacademy.org/ Als je inlogt op khanacademy, dan onthoudt de website wat je al bekeken en gemaakt hebt. Inloggen kan als volgt:\nKlik op “login” kies de knop “continue with google” type je school-email van google en bijbehorende wachtwoord in De eerste keer dat je inlogt krijg je een aantal vragen\n“What grade are you in?” -\u003e kies “Grade 12 / Year 12” “What courses can we help you learn?” -\u003e scroll omlaag en kies “Computer Programming” Je kunt nu naar je cursus gaan:\nKlik linksboven op courses. Kies computer programming. Kies de juiste cursus. Bekijk de video’s en maak de opdrachten. De volgende keer inloggen op Khan Academy Start je browser (Chrome werkt het best) en ga naar https://www.khanacademy.org/ Klik op “login” kies de knop “continue with google” type je school-email van google en bijbehorende wachtwoord in Klik linksboven op courses. Kies computer programming. Kies de juiste cursus. Bekijk de video’s en maak de opdrachten. Je kunt ook de links gebruiken op diverse plaatsen op de informatica-website. Die brengen je gelijk naar de goede plek.\nVeelgestelde vragen Ik kan de cursus niet vinden Kijk of je op de Engelstalige site zit. Als je zoekt via google, dan kom je vaak op de Nederlandstalige site, daar staat niet de cursus die wij gebruiken. De Engelstalige site vind je op https://khanacademy.org/ De juiste cursus vind je door linksboven op de knop “courses” te klikken. Vervolgen kies je “Computer Programming”. Nu kom je op een pagina waar alle cursussen staan die we gebruiken.\nIk krijg steeds de Nederlandse in plaats van de Engelse site De Engelstalige site vind je op https://khanacademy.org/ . Als je daar steeds teruggezet wordt op de Nederlandse site, dan moet je in je profiel aangeven dat je voorkeur hebt voor de Engelse taal. Dit doe je als volgt: klik rechtsboven op je inlognaam, klik in het menu dat verschijnt op setting, verander Primary Language in “English”\n","description":"","tags":null,"title":"Khan Academy","uri":"/tools/khan/"},{"content":"Je gaat je eigen website maken!\nHulpmiddelen We gebruiken in deze opdracht de volgende tools:\nGitHub om je code op te slaan. Gitpod om je code te bewerken en een voorbeeld van je website te bekijken. Opdrachtbeschrijving De opdracht in het kort is: Maak je eigen informatieve website over een zelfgekozen onderwerp. Je gebruikt de startcode met HTML en CSS.\nInschrijven Je schrijft je in via Github Classroom (login met je github account).\nOnderwerp kiezen Je bent vrij om zelf een onderwerp voor je website te bedenken. Je docent moet het onderwerp goedkeuren. Je kunt denken aan een hobby, sport, jouw favoriete lifestyle enzovoort. Misschien is het wel mogelijk om de website te gebruiken voor een schrijfopdracht voor een ander vak.\nWerkwijze Je maakt deze opdracht in je eentje. Je krijgt van de docent startcode voor deze opdracht. Deze staat klaar in een repo op GitHub. Je maakt code in GitHub Codespaces. Elke week (liefst vaker) sla je je tussentijdse werk op in de repo op GitHub. Zo zorg je ervoor dat de laatste werkende versie van je opdracht steeds op GitHub staat. Deze opdracht maak je alsof het een echt project is. De stappen uit README.md in de starterscode zijn de basis van je planning. De voortgang hou je wekelijks bij in README.md. Als het niet volgens je plan gaat, dan stuur je bij. In de les kun je hulp vragen, maar uiteindelijk moet jij zorgen dat je op tijd klaar bent en een goed project oplevert. Beoordeling Het cijfer dat je voor je PO krijgt wordt vanuit verschillende invalshoeken bepaald:\nminimale eisen uiterlijk techniek inzet en planning Minimale eisen\nVoordat je een cijfer krijgt voor je PO, wordt gekeken of je werk voldoet aan de minimale eisen. Werk dat niet voldoet aan de minimale eisen krijgt het cijfer 1,0. De minimale eisen zijn:\nDe inhoud van je webshop is moreel verantwoord: het is niet beledigend, visueel gewelddadig of op andere manieren onfatsoenlijk. Natuurlijk mag je overleggen met klasgenoten en mag je op internet kijken hoe je bepaalde dingen kunt maken. Let wel op dat je geen plagiaat pleegt. Je mag maximaal 5 regels code overnemen van andere leerlingen of internet en je schrijft in het commentaar erbij waar je het voorbeeld vandaan hebt. Dat geldt ook voor code die je zelf vertaalt naar het Nederlands. Overtypen van code uit een Youtube-video of een tutorial van internet volgen en dat resultaat inleveren is niet toegestaan. Je gebruikt de startcode die je krijgt. Je gebruikt het stappenplan dat bij deze opdracht gegeven is. Een download in zip-formaat van je opdracht mag maximaal 50 MB groot zijn. Vormgeving en inhoud Enkele punten waarop gelet kan worden bij de beoordeling van vormgeving en inhoud zijn\nDe website bestaat uit minimaal 4 pagina’s. Uit de home-page (index.html) blijkt duidelijk wat er op je website te vinden is. De vormgeving ziet er aantrekkelijk uit en nodigt uit om verder te kijken op je website. De inhoud is compleet en informatief, de teksten heb je niet klakkeloos gekopieerd van een andere website. De website is goed te bekijken op gangbare browsers en computers met verschillende schermresoluties. Het is een pre als je website er op een telefoon ook goed uitziet. De uitlijning van de verschillende onderdelen op je website is netjes. Je respecteert auteursrecht, daar waar je voorbeelden of plaatjes van anderen gebruikt geef je tenminste in commentaar de bron aan. … Techniek Enkele punten waarop gelet kan worden bij de beoordeling van techniek zijn\nJe laat zien dat je de in de les aangereikte technieken begrijpt en op een nette manier kan toepassen, hierbij hoort zeker het gebruik van floats om een nette layout te maken. Je laat zien dat je in staat bent om zelf nieuwe dingen kunt toevoegen die voortbouwen op wat je al geleerd hebt. Alle code (HTML / CSS / JavaScript / …) is goed leesbaar en overzichtelijk. Je springt netjes in waar dat verwacht wordt. Je gebruikt duidelijk commentaar in HTML en CSS. CSS-klassen en ID’s hebben duidelijke en begrijpelijke namen. Er is geen ongebruikte code aanwezig. Je maakt gebruik van een nette mappen structuur, met logische bestandsnamen. Ongebruikte of oude bestanden zijn verwijderd. CSS bevindt zich niet in de HTML-pagina, maar in een los CSS-bestand. Je gebruikt één CSS-bestand voor je hele website. Met commentaar geef je aan welke delen eventueel paginaspecifiek zijn. Je linkt niet naar afbeeldingen op andere websites, alle afbeeldingen die je gebruikt heb je lokaal opgeslagen. Je afbeeldingen hebben een passende resolutie, zodat ze niet blokkerig zijn (te lage resolutie) of langzaam laden (te hoge resolutie). … Inzet en planning\nJe toont inzet tijdens de lessen De planning is vooraf gemaakt, gevolgd en als nodig bijgesteld. Het werk is verdeeld over de weken waarin aan de opdracht kon worden gewerkt, dit blijkt onder andere uit de commits in Github. Inleveren De deadline voor inleveren vind je in de lesplanner. Je kunt vragen stellen tot de laatste les voor de deadline. Je zorgt dat alle bestanden in die nodig zijn om je website correct te laten werken in GitHub staan, dit zijn ten minste: index.html, 3 html-bestanden voor de subpagina’s en style.css. Als je plaatjes gebruikt, dan staan die er ook bij. Uit de versiegeschiedenis in GitHub blijkt wanneer je wat gedaan hebt. De laatste versie van je PO die op het moment van de deadline in GitHub staat, wordt gebruikt voor de beoordeling. Startcode Als je van je docent je een kopie van de startcode hebt ontvangen, dan kun je aan de slag met de stappen uit het README.md bestand.\nStappenplan Werk de planning af van boven naar beneden.\nStap 1: Start Je hebt het onderwerp van je website gekozen en door je docent laten goedkeuren. Je hebt een account aangemaakt op www.github.com . Je hebt de voorbeeldwebsite van de docent gekopieerd naar je eigen github account. Je hebt het onderwerp in de kop op van je homepage gezet. Aan het einde van stap 1 heb je de voorbeeldwebsite van je docent waarin je zelf de kop hebt aangepast.\nStap 2: Menu en bestandsstructuur Je hebt bepaald wat je op de hoofdpagina en de subpagina’s (minimaal 3) wilt laten zien. Je past het menu in index.html aan, zodat het de keuzes biedt voor jouw subpagina’s Je maakt een html-bestand voor alle pagina’s. De titel en het menu staan erop, maar de inhoud nog niet. Je hebt een werkend menu waarmee je naar de verschillende pagina’s kunt gaan, de layout kun je later nog aanpassen en mooi maken. Aan het einde van stap 2 heb je een werkend menu met minimaal drie lege subpagina’s.\nStap 3: Indeling en opmaak hoofdpagina Let op: In deze stap ga je nog geen plaatjes zoeken en teksten maken, dat komt in de volgende stap.\nJe hebt de layout van je hoofdpagina bepaald. Leg de layout vast in een wireframe. Een wireframe is een tekening waarin elke box op je pagina als een rechthoek getekend is. Je hebt in html voor alle onderdelen uit de layout een tag opgenomen en aan de tags heb je classes toegevoegd. Je hebt met css ervoor gezorgd dat alle onderdelen op de juiste plaats op de pagina worden weergegeven. Je hebt opmaak zoals kleuren, lettertypen en kaders in css toegevoegd aan de onderdelen in je layout. Je kunt een wireframe bijvoorbeeld als volgt maken\nop https://draw.io in Powerpoint op papier en dan fotograferen (het is dan wel lastig om het netjes te doen) Aan het einde van stap 3 heb je een hoofdpagina met een goede indeling en opmaak. De tekst en de plaatjes zijn nog niet ingevuld, daarvoor gebruik je tijdelijk een willekeurige tekst of plaatjes zoals in de voorbeeldsite.\nStap 4: Plaatjes en tekst hoofdpagina Je hebt in html de tekst op je hoofdpagina gezet. Je hebt plaatjes bij je teksten gezocht, omgezet naar de juiste resolutie en op je website gezet. Alle plaatjes moet je opslaan, je linkt niet naar plaatjes op andere websites, die kunnen immers verwijderd worden. Aan het einde van stap 4 heb je een hoofdpagina met teksten en plaatjes.\nStap 5: Indeling en opmaak subpagina's Je hebt een layout en opmaak voor al je subpagina’s gemaakt. Het is handig om voor al je sub-pagina’s dezelfde lay-out en opmaak te gebruiken. Aan het einde van stap 5 heb je minimaal drie subpagina’s met een goede indeling en opmaak. De tekst en de plaatjes zijn nog niet ingevuld, daarvoor gebruik je tijdelijk een willekeurige tekst of plaatjes zoals in de voorbeeldsite.\nStap 6: Plaatjes en tekst subpagina's Je hebt de tekst en plaatjes voor al je subpagina’s gemaakt. Aan het einde van stap 6 heb je minimaal drie subpagina’s met teksten en plaatjes.\nStap 7: Kleuren Je hebt alle elementen op je site kleuren gegeven die je mooi vindt en die duidelijk leesbaar zijn. Je hebt fonts gekozen die je mooi vindt en die duidelijk leesbaar zijn. Aan het einde van stap 8 zijn alle kleine kleuren en fonts op je website goed ingesteld.\nStap 8: Perfectioneren Je hebt slordigheden in de lay-out, kleuren en inhoud gerepareerd. Je hebt gezorgd dat je HTML en CSS goed leesbaar zijn (geen herhaling, namen van classes die aangeven wat erin zit in plaats van hoe het eruit ziet, uit logische onderdelen opgebouwd, inclusief commentaar, …) Je hebt gecontroleerd of de lay-out werkt op een groter venster, een kleiner venster, een ander apparaat en andere browser. Aan het einde van stap 8 zijn alle kleine foutjes uit je website verdwenen.\nStap 9: Eye catchers Je hebt een aantal extra dingen toegevoegd die je website nog mooier maken. Denk bijvoorbeeld aan animaties met CSS, een responsive design (=website heeft een andere indeling op apparaten met een kleiner scherm), een fotogalerij, visuele effecten als je met je muis ergens overheen beweegt, vernieuwingen in het ontwerp van een gebruikte voorbeeldwebsite etc. Aan het einde van stap 9 heb je een perfecte website met één of enkele opvallende functies die je zelf hebt toegevoegd.\nStap 10: Uitbreidingen (niet verplicht) Kies de uitbreidingen die je leuk vindt en maak je website nog mooier\n… Uitlegvideo’s ","description":"","tags":null,"title":"O1. Website","uri":"/opdrachten/website/"},{"content":"Hier vind je de lesplanners (met geplande toetsen en inlevermomenten), het vakoverzicht en de PTA’s.\nLesplanner, toetsen en inlevermomenten 4 havo Hier vind je de lesplanner, geplande toetsen en inlevermomenten voor 4 havo.\n5 havo Hier vind je de lesplanner, geplande toetsen en inlevermomenten voor 5 havo.\n4 vwo Hier vind je de lesplanner, geplande toetsen en inlevermomenten voor 4 vwo.\n5 vwo Hier vind je de lesplanner, geplande toetsen en inlevermomenten voor 5 vwo.\n6 vwo Hier vind je de lesplanner, geplande toetsen en inlevermomenten voor 6 vwo.\n4hv inhaalprogramma Hier vind je een planning voor leerlingen die tijdens het vierde jaar willen overstappen naar informatica.\nVakoverzicht PTA De leerlingen raden we aan om vooral te kijken naar het vakoverzicht en de toets- en inlevermomenten hierboven op deze web-pagina. Voor wie het echt wil weten, is hier een linkje naar ons PTA in Excel , zoals we dat jaarlijks aanleveren aan de school.\n","description":"","tags":null,"title":"Planning","uri":"/planning/"},{"content":"Je leert hoe je informatie op een website zet met de programmeertalen HTML en CSS.\nHulpmiddelen We gebruiken in deze module de volgende tools:\nKhan Academy Oefeningen Khanacademy, module Intro to HTML/CSS\nIntro to html Intro to css More html tags Css text properties Web development tools (geen toetsstof) CSS layout More css selectors Other ways to embed css (geen toetsstof) Further learning (geen toetsstof) Presentaties Introductie + Opstarten Uitleg: HTML tags Uitleg: CSS selectors en propteries De overige presentaties volgen later. De slides zijn steeds voorafgaand aan de les online beschikbaar.\nLeerdoelen voor de toets HTML\nJe kunt uitleggen wat een URL is en waarvoor een webbrowser deze gebruikt en je kent de volgende vier onderdelen van een URL: protocol, server, map, bestand Je kent het principe van tags zoals die in HTML gebruikt worden. Je kent de basisstructuur van een HTML-pagina. Je weet wat de begrippen parent, child en sibling betekenen en kunt de betekenis van deze begrippen toelichten. Je kunt deze begrippen toepassen op HTML. Je kent de volgende tags: \u003chtml\u003e, \u003chead\u003e, \u003cbody\u003e, \u003cp\u003e, \u003col\u003e, \u003cul\u003e, \u003cli\u003e, \u003ch1\u003e t/m \u003ch6\u003e, \u003cbr/\u003e, \u003cimg\u003e met src en alt, \u003ca\u003e met href, \u003cdiv\u003e, \u003ctable\u003e, \u003ctr\u003e, \u003cth\u003e, \u003ctd\u003e. Je kunt uitleggen wat deze tags doen en hoe je kunt ze gebruiken. Je kunt eenvoudige stukken HTML interpreteren, dat wil zeggen dat je kunt uitleggen hoe een webbrowser omgaat met een eenvoudig stuk HTML. Je kunt wijzigingen aanbrengen in een eenvoudig stuk HTML, de syntax van de HTML tags die daarvoor nodig zijn wordt daarbij gegeven in de vraag. CSS\nJe kunt uitleggen wat er binnen de informatica met Separation of Concern wordt bedoeld en hoe dat op HTML en CSS van toepassing is. Je kunt uitleggen wat selectors, properties en values in CSS zijn en je kunt ermee werken. Dat wil zeggen dat je eenvoudige stukken CSS met selectors, properties en values kunt maken en de werking ervan kunt uitleggen. Je kunt CSS selectors maken die bestaan uit een tag, class of id of een combinatie daarvan. Je kunt de voorrangsregels tussen tags, classes en id’s toepassen en je kunt daarbij aangeven welke selectors meer of minder specifiek zijn. Je kent van de volgende properties de betekenis en kunt deze toepassen in CSS: font-size, width, height, color, background-color. Je kunt werken met kleuren en doorzichtigheid in CSS, door gebruik te maken van kleurnamen en rgba(). Je kunt de werking van boxen in CSS toelichten. Je kunt daarbij uitleggen wat de content, padding, border en margin van een box zijn. Je kunt eenvoudige stukken CSS interpreteren, dat wil zeggen dat je kunt uitleggen hoe een webbrowser omgaat met een eenvoudig stuk CSS en hoe het eruit ziet in een webbrowser. Je kunt wijzigingen aanbrengen in een eenvoudig stuk CSS, de properties die daarvoor nodig zijn worden beschreven in de vraag. Oefentoets Een oefentoets voor deze module staat in Woots .\nVerdieping CSS Battle ( https://cssbattle.dev/) . Oud materiaal Hieronder vind je materiaal van voorgaande jaren. De inhoud komt grotendeels overeen, maar er kunnen kleine verschillen zijn. Raadpleeg daarom altijd de slides van dit jaar om zeker te zijn. Het materiaal is bedoeld als aanvulling, zodat je de stof vanuit een ander perspectief kunt bekijken.\nLespresentatie havo Lespresentatie vwo Uitleg video 1: Uitleg video 2: ","description":"","tags":null,"title":"T1. Web Design met HTML en CSS","uri":"/theorie/webdesign/"},{"content":"Inleiding Tijdens het maken van je website zul je ongetwijfeld gemerkt hebben hoe gemakkelijk het is om informatie van andere webpagina’s over te nemen in die van jezelf. Het was vooraf bekend dat je voor de opdracht geen tekst mocht kopiëren zonder te citeren, maar wellicht heb je wel gebruik gemaakt van afbeeldingen, muziek, of HTML / javascript code.\nMaar mag dit eigenlijk wel? Dat hangt er vanaf. Hieronder zullen we een aantal aspecten van intellectueel eigendom behandelen die je zullen helpen met het beantwoorden van de vraag of je de informatie op je website rechtmatig hebt gebruikt. Daarnaast krijg je ook informatie over het gebruiken van afbeeldingen van mensen en (software)licenties.\nWat is intellectueel eigendom Intellectueel eigendom is eigenlijk iets vreemds. In de Nederlandse wet is eigendom beschermd. De spullen die jij in bezit hebt, mag een ander niet zomaar afnemen. Het is niet de bedoeling dat een medeleerling zomaar je mobiele telefoon uit je tas haalt omdat hij die wel kan gebruiken. Dan spreken we van diefstal. Maar hoe zit dit bij creatieve uitingen, of “voortbrengselen van de geest”? Mag iemand een leuk muzikaal thema uit een recent hiphop nummer gebruiken voor een eigen nummer? Mag iemand anders een werkstuk dat identiek is aan het jouwe uploaden op scholieren.com? De wetten voor de bescherming van intellectueel eigendom proberen ook dit te beschermen. Er zijn hiervoor talrijke nationale en internationale wetten.\nGeen auteursrecht voor dieren na uitspraak rechter VS in zaak selfie-aap “Dieren kunnen onder de Amerikaanse wet definitief geen aanspraak maken op het auteursrecht. Dat heeft een federale rechtbank van de Verenigde Staten bepaald in een uitspraak rond de ‘selfie-aap’.\nDe wilde kuifmakaak Naruto maakte in 2011 meerdere foto’s van zichzelf met een camera die was achtergelaten door fotograaf David Slater. Die beelden werden drie jaar later gepubliceerd in een boek, waarbij Slater zich het auteursrecht toe-eigende.\nDat leidde in 2015 tot een rechtszaak, die namens Naruto werd aangespannen door dierenrechtenorganisatie People for the Ethical Treatment of Animals (PETA). De organisatie beweerde dat de aap het auteursrecht op de selfies had. Een rechter ging daar echter niet in mee en stelde dat dieren geen auteursrecht kunnen bezitten. PETA ging vervolgens in beroep.”\nLees verder op nu.nl Auteursrecht In 1883 kwamen België, Duitsland, Frankrijk, Italië, Spanje, Tunesië, het Verenigd Koninkrijk en Zwitserland in Bern bij elkaar (Berner Conventie) om tot een eenduidig verdrag te komen om ook over grenzen heen het auteursrecht te beschermen. Tot dan toe waren er talloze verdragen tussen verschillende landen gesloten, maar dit werd onwerkbaar. Na verschillende conferenties kwam men in 1886 tot een verdrag dat op 5 december 1887 voor alle acht staten in werking zou treden. Deze landen vormden de Berner Unie. Een auteur uit de Berner Unie heeft in al deze landen automatisch het auteursrecht. Daar hoeven geen extra handelingen of claims voor worden gedaan. De verschillende landen zijn gebonden aan een minimum bescherming, maar mogen zelf hun wetgeving anders formuleren. Zo is in het verdrag opgenomen dat het auteursrecht pas na minimaal 50 jaare na de dood van de auteur (voor filmwerken na de publicatie) vervalt. In veel landen is dit echter langer. In Nederland wordt een periode van 70 jaar gehanteerd.\nOuders Nederlandse top-dj's willen dj-talenten beschermen “Managers die veel aan je verdienen en promotors die vooral zélf beter worden van succes van een ander: de dancewereld is een miljoenenbusiness en daar willen veel mensen een graantje van meepikken. Daar gaat het vaak mis, merken ouders van dj’s die op jonge leeftijd doorbraken.\nZij komen nu met de Dutch DJ Foundation (DDJF). Zo willen ze de belangen behartigen van Nederlandse dj’s en producers.”\nLees verder op nos.nl Steeds meer landen werden lid van deze Unie, waaronder Nederland in 1912. Opvallend is dat bijvoorbeeld de Verenigde Staten pas in 1989 lid werden. Dat verklaart ook (deels) waarom in de V.S. vaak zulke uitvoerige copyright claims in publicaties staan.\nHet auteursrecht is in Nederland zo geformuleerd:\n“Het auteursrecht is het uitsluitend recht van den maker van een werk van letterkunde, wetenschap of kunst, of van diens rechtverkrijgenden, om dit openbaar te maken en te verveelvoudigen, behoudens de beperkingen, bij de wet gesteld.”\nEr zijn echter situaties waarin anderen wel of gedeeltelijk zo’n werk mogen verveelvoudigen of publiceren. Zo mag berichtgeving van nieuws en actualiteiten door andere nieuwsmedia vrij worden gebruikt, mits men de bron vermeldt. Een ander geval is het citeren. Voor een citaat geldt dat het een ondergeschikte rol vervult in het werk waarin het geciteerd wordt en dat de bron vermeld moet worden. Interessant is de zogenaamde thuiskopie. Een kopie maken voor jezelf van een werk om te kunnen oefenen, studeren of gebruiken is in Nederland toegestaan. Nederlandse auteurs krijgen hiervoor een kleine compensatie via de zogenoemde thuiskopieheffing: een klein bedrag dat geheven wordt op gegevensdragers, zoals harddisks, lege DVD’s, USB sticks, etc. Zo’n kopie is uitsluitend voor eigen gebruik. Je mag deze niet aan anderen geven. Tot voor kort viel het illegaal downloaden van software, muziek, films, etc. onder dit artikel. Het uploaden (=verspreiden onder derden) was wel strafbaar, het downloaden (=maken van een kopie) echter niet. Sinds een uitspraak van het Europees Hof op 10 april 2014 is dit illegaal downloaden ook in Nederland strafbaar geworden. Het hof vond de thuiskopieheffing niet toereikend voor compensatie.\nHet is mogelijk om de auteursrechten over de dragen. Dit wordt vaak gedaan in de muziek- en boekenbranche. De auteurs verleent bijvoorbeeld aan de producer of uitgever de exclusieve rechten om het boek te verspreiden. De auteurs krijgen hiervoor een vergoeding. Ook dan mag een producer of uitgever niet met het werk doen wat men maar wil. Er blijft sprake van ‘persoonlijkheidsrechten’. Een auteur mag dan bijvoorbeeld bezwaar maken tegen een publicatie omdat zijn / haar naam niet wordt vermeld, het gebruikt wordt in een context waarvoor de auteur het niet heeft bedoeld of omdat er door de betreffende publicatie niet het nodige respect wordt getoond voor het werk.\nPortretrecht Naast auteursrecht kennen we ook het portretrecht. Dit portretrecht houdt in dat men niet zomaar beeldmateriaal mag verspreiden indien hierop anderen op te herkennen zijn. In bepaalde gevallen is hiervoor toestemming nodig van de geportretteerde(n).\nIn het portretrecht is een ‘portret’ breder dan wat men er in bijvoorbeeld de schilderkunst of fotografie mee bedoelt. Van een portret is sprake wanneer men iemand kan herkennen. Dit kan zijn door middel van het gezicht, maar ook gelaatstrekken, een specifieke lichaamshouding, attributen of de omgeving spelen hierbij mee. Als je de identiteit van iemand uit het afgebeelde kunt achterhalen, is er in de wetgeving sprake van een portret.\nHet maakt uit of een portret wel of niet in opdracht is gemaakt. Een fotograaf kan een reportage van iemand maken. Dan is er sprake van een opdracht. Een journalist kan een foto maken van een winkelstraat. Daarop staan mogelijk ook mensen afgebeeld die op dat moment in die straat liepen. In het portretrecht wordt verschil gemaakt voor deze twee verschillende redenen.\nEen portret in opdracht Als een portret in opdracht is gemaakt, geldt het volgende. De maker van het portret bezit het auteursrecht van zijn / haar creatie. Publicatie mag echter alleen indien de maker hiervoor toestemming van de geportretteerde heeft. Degene die afgebeeld is, mag voor zichzelf en vrienden / familie een aantal kopieën maken. Ook mag hij / zij het portret beperkt in publicaties opnemen (zoals een portfolio van een model), zolang er maar bij vermeld wordt wie de maker ervan is. Commerciële publicatie mag alleen als ook de auteur hiervoor toestemming geeft.\nSamengevat: de geportretteerde mag heel beperkt en onder voorwaarden kopieën maken of publiceren. Voor breder gebruik door de auteur, de geportretteerde of anderen is altijd toestemming van zowel de auteur als de geportretteerde nodig.\nEen portret niet in opdracht Een portret dat niet in opdracht is gemaakt, mag in principe vrij worden gepubliceerd. Het kan echter zo zijn dat een afgebeeld persoon een ‘redelijk belang’ heeft om dit niet gepubliceerd te willen hebben. Dit kan bijvoorbeeld gaan om schending van privacy of omdat het beeldmateriaal iets suggereert wat niet het geval is. Ook kan het gaan om een financieel belang. Een popster verdient vaak aan producten waar zijn of haar portret op staat. Je kunt je voorstellen dat het niet is toestaan om zelf tijdens een concert een mooie foto te maken en zelf bijvoorbeeld t-shirts mee laat bedrukken.\nHet wordt anders wanneer het niet om een incidentele foto of video in de openbare ruimte gaat, maar om een foto of video gemaakt met een ‘aangebrachte’ camera. Je mag dus niet zomaar videocamera’s in de openbare ruimte ophangen. In dat geval moet je dit duidelijk vooraf aankondigen. Evenzo is iedere vorm van filmen of fotograferen in huizen of andere niet-publieke ruimtes verboden, tenzij dit vooraf duidelijk is aangekondigd.\nSoftware licenties De rechten voor software vallen voor een deel samen met het auteursrecht. Je mag dit niet zomaar vermenigvuldigen, verspreiden of openbaar maken. Je moet hiervoor een vergunning hebben, een licentie. Je kunt software niet gebruiken zonder (stilzwijgend) akkoord te zijn met de licentie. Er zijn verschillende soorten licenties om software te mogen gebruiken. Hieronder worden de meest gebruikte kort behandeld:\nCommercieel Voor commerciële software moet vooraf worden betaald. Met deze betaling krijg je het recht om de software op een vooraf bepaald aantal apparaten te installeren. Soms geldt deze licentie voor een bepaalde tijd en zul je na het verstrijken van deze periode opnieuw een licentie moeten kopen. Voorbeelden van software met deze licenties zijn Microsoft Office en Adobe Creative Cloud. Ook de meeste betaalde apps uit de app stores van Apple en Google maken gebruik van deze licentie.\nShareware Shareware mag je kopiëren en verspreiden zonder dat je er zelf iets aan verdient. Je mag het programma proberen, vaak voor een vaststaande tijd. Gebruik je deze software echter vaker, dan dien je hiervoor te betalen. Vaak zie je dat bepaalde functies niet werken totdat er een licentie is aangeschaft. Vóór de jaren ’90 was shareware software een aparte categorie. Langzaamaan zijn de verschillen met commerciële software steeds verder vervaagd. Veel apps die je nu in de app stores tegenkomt, zouden vroeger waarschijnlijk shareware zijn geweest.\nFreeware Software waarvoor de auteur een licentie verleent voor gebruik en verspreiding, heet freeware. Het is wel belangrijk om te beseffen dat de software alleen ongewijzigd mag worden verspreid. Anderen mogen er dus geen aanpassingen aan doen en vervolgens verspreiden. Een voorbeeld van freeware is Skype.\nOpen Source Open Source software heeft een licentie die ook de mogelijkheid geeft om de software aan te passen. De broncode van open source software is vrij beschikbaar en voor iedereen aan te passen. Men mag bijvoorbeeld een eigen ‘versie’ of smaak maken (dit heet een fork) en publiek maken. Er zijn heel veel open source licenties. De grootste verschillen zijn: Sommige licenties vereisen dat de aangepaste software ook de broncode openbaar moet maken Sommige licenties vereisen dat aangepaste software exact dezelfde licentie moet hanteren als de broncode waar vanaf de fork gemaakt is. Sommige licenties staan toe dat er verdient mag worden met aangepast software, andere niet. Sommige licenties staan toe dat er een tweede andere licentie aan de fork wordt verbonden, andere niet.\nTegenbewegingen Open source software is in sommige gevallen ontstaan vanuit onvrede met de beperkingen uit het auteursrecht. In bepaalde gevallen kunnen deze vooruitgang hinderen, wat sommige mensen erg vervelend vinden.\nVoor andere werken, zoals tekst, muziek en afbeeldingen is er vanuit een Amerikaans project een aantal licenties geformuleerd om meer meer duidelijkheid te geven over waarvoor materiaal gebruikt mag worden. Dit project heet Creative Commons. Bij een foto die je publiceert kun je aangeven welke CC licentie hierop van toepassing is. Ook is het gemakkelijk om zo te weten te komen of je een foto met een bepaalde CC licentie kunt gebruiken voor je website.\nEen CC-licentie wordt opgebouwd uit vier bouwstenen. Dit zijn de voorwaarden waaronder anderen gebruik mogen maken van jouw werk. De bouwstenen zijn:\nNaamsvermelding - Je staat anderen toe om het werk waar jij auteursrecht op hebt te kopiëren, distribueren, vertonen, en op te voeren, en om afgeleid materiaal te maken dat op jouw werk gebaseerd is – maar uitsluitend als jij vermeld wordt als maker.\nNiet-commercieel - Anderen mogen je werk kopiëren, vertonen, distribueren en opvoeren, alsmede materiaal wat op jouw werk gebaseerd is, mits niet voor commerciële doeleinden.\nGeenAfgeleideWerken - Anderen mogen je werk kopiëren, distribueren, vertonen en opvoeren mits het werk in de originele staat blijft. Het is niet toegestaan dat anderen jouw werk gebruiken als basis voor nieuw materiaal.\nGelijkDelen - Je staat anderen toe om van jouw werk afgeleid materiaal te maken onder de voorwaarde dat zij het onder dezelfde licentie vrijgeven als het originele werk.\nMet deze vier bouwstenen heeft men zes verschillende licenties gemaakt, waarbij het uitgangspunt is dat je altijd de naam van de originele auteur vermeldt:\nNaamsvermelding Naamsvermelding-GelijkDelen Naamsvermelding-NietCommercieel Naamsvermelding-NietCommercieel-GelijkDelen Naamsvermelding-GeenAfgeleideWerken Naamsvermelding-NietCommercieel-GeenAfgeleideWerken En mijn website? Of je materiaal legaal hebt gebruikt op je website hangt dus van heel veel factoren af. Wil je andermans materiaal gebruiken, dan zul je moeten achterhalen op welke manier de auteur het beschikbaar stelt. Soms is dat via een voor iedereen te gebruiken licentie. Het kan ook zijn dat je een auteur expliciet om toestemming zult moeten vragen of een licentie moeten kopen. In een aantal gevallen is de wetgeving zo geregeld dat je materiaal mag publiceren, zoals bij een zelf genomen foto van een winkelstraat of shots van een fotoshoot waar jij op staat. Er zijn hiervoor ook meteen beperkingen geformuleerd, waardoor je goed moet beseffen of je binnen de regels handelt.\n","description":"","tags":null,"title":"T1a. Intellectueel eigendom","uri":"/theorie/webdesign_auteursrecht/"},{"content":"Hier vind je de lesplanner, geplande toetsen en inlevermomenten voor 5 havo.\nLesplanner 25/26 Het is vandaag .\nWeek Theorie+Praktijk (les 1) Praktijk (les 2) 36 T6 Robotica](/theorie/robotica) Intro en Arduinobakjes uitdelen 37 T6 Arduinolessen gestart T6 Arduinolessen 1. Knipperende led + 2. Knipperende led op breadboard 38 T6 Uitleg breadboard, led, gedimd led T6 Arduinolessen 3. Fadende led op breadboard met PWM 39 T6 Uitleg microcontrollers potmeter, knop, samenvatting T6 Uitleg toestandsdiagrammen deel 1 40 T6 Arduinolessen 4. Knippersnelheid regelen met potmeter T6 Uitleg toestandsdiagrammen deel 2 41 T6 Arduinolessen 5. LED schakelen met drukknop T6 Toestandsdiagrammen Oefening 42 O4-Robot Stap 1 starten O4-Robot Stap 1 starten 43 Herfstvakantie 44 O4-Robot Stap 2 toestandsdiagram O4-Robot Stap 2 toestandsdiagram 45 Oefentoets, toetsvoorbereiding TW1: Toets 5H-IN-S06 over T6 Robotica 46 TW1 O4-Robot Stap 3 code 47 O4-Robot Stap 3 code O4-Robot Stap 3 code 48 O4-Robot Stap 4 uitbreidingen O4-Robot Stap 4 uitbreidingen 49 O4-Robot Stap 4 uitbreidingen PO 5H-IN-S08 robot inleveren Stap 5 video en inleveren 50 T5 Databases Uitleg: SELECT WHERE T5 Databases Oefening: Khan 1 SQL Basics 51 T5 Databases Uitleg: GROUP BY T5 Databases Oefening: Khan 2 More advanced SQL-queries 52 Kerstvakantie 1 Kerstvakantie 2 T5 Databases Uitleg: JOIN 1:N T5 Databases Oefening: Khan 1e helft van 3 Relational Queries 3 T5 Databases Uitleg: JOIN N:M T5 Databases Oefening: Khan 2e helft van 3 Relational Queries 4 O3 Webshop Intekenen + uitleg hoofdlijnen O3 Webshop Repo ontvangen + Stap 1 5 O3 Webshop Stap 2 DB O3 Webshop Stap 2 DB 6 O3 Webshop Stap 3 API O3 Webshop Stap 3 API 7 O3 Webshop Stap 4 Web PO 5H-IN-S08 webshop inleveren 8 Voorjaarsvakantie 9 T5 Oefentoets 1e helft T5 Oefentoets 2e helft 10 TW2: Toets 5H-IN-S07 over T5 Databases 11 TW2 12 invulling volgt bespreking toets 5H-IN-S07 13 invulling volgt invulling volgt 14 invulling volgt invulling volgt 15 invulling volgt invulling volgt 16 invulling volgt invulling volgt 17 meivakantie 18 meivakantie examencijfer informatica bekend 19 CE geen CE voor informatica 20 CE geen CE voor informatica 21 CE geen CE voor informatica Toetsen en inlevermomenten Datum Code Toetsvorm Stof Toetsweek 1 5H-IN-S06 Digitale toets T6 Robotica Zondag 8 dec 2024 23:59 5H-IN-S08 Praktische Opdracht O4 Robot Zondag 23 feb 2025 23:59 5H-IN-S09 Praktische Opdracht O3 Webshop Toetsweek 2 5H-IN-S07 Digitale toets T5 Databases ","description":"","tags":null,"title":"5 havo","uri":"/planning/5h/"},{"content":"Informatica Actief is de lesmethode voor informatica die wij gebruiken. Wij gebruiken enkele modules uit de methode.\nDe eerste keer inloggen op Informatica Actief Start je browser (Chrome werkt het best) en ga naar https://www.informatica-actief.nl/ De volgende stappen zijn een grove beschrijving, die we later nog uitwerken:\nKlik op “login”. Klik op aanmelden via Entree. Je kunt je magister inloggegevens gebruiken om in te loggen. Als er gevraagd wordt om een mailadres, gebruik dan je schoolmail. Je krijgt een bevestingsmail met een link waar je op moet klikken. Log opnieuw in op de pagina waar de link je naartoe brengt. Klik linksboven op het IA icoontje, je komt dan terug op de home page van de site. Schuif een popup uit door rechts op het pijltje te klikken en voer de voucher code in, inclusief de streepjes. Deze code krijg je van je docent. Je moet die voucher code elk jaar vernieuwen, anders wordt de site afgesloten. Kies de module die we gebruiken. Letop: we doen niet alle onderdelen van een module, kijk in de lesstof welke onderdelen bij de stof horen. De volgende keer inloggen op Informatica Actief Start je browser (Chrome werkt het best) en ga naar https://www.informatica-actief.nl/ Klik op “login”. Klik op aanmelden via Entree. Je kunt je magister inloggegevens gebruiken om in te loggen. Kies de module die we gebruiken. Je kunt ook de links gebruiken op diverse plaatsen op de informatica-website. Die brengen je gelijk naar de goede plek.\nQ\u0026A Mijn voucher code werkt niet Let op het verschil tussen 0 (cijfer nul) en O (hoofdletter oo) en let op het verschil tussen l (kleine letter l) en 1 (cijfer één).\n","description":"","tags":null,"title":"Informatica Actief","uri":"/tools/ia/"},{"content":"Je gaat je eigen game programmeren!\nHulpmiddelen We gebruiken in deze opdracht de volgende tools:\nGitHub met Codespaces en VS Code Opdrachtbeschrijving De opdracht in het kort is: Maak in groepjes van twee je eigen spel in JavaScript. Je gebruikt de startcode en maakt gebruik van de p5js-library.\nInschrijven Je schrijft je in via GitHub Classroom via de onderstaande link (login met je github account).\nLetop 1: Zorg dat je gebruikersnaam in GitHub begint met je voornaam, gevolgd door je leerlingnummer om hem uniek te maken. Je kunt je gebruikersnaam aanpassen in GitHub -\u003e klik op je foto rechtsboven -\u003e Settings -\u003e Account .\nLetop 2: De teamnaam die je kiest bevat de gebruikersnamen van alle leerlingen in je team, bijvoorbeeld jolanda123111-klaas123987\n4H.in1 HAR 24/25 Codespaces 4H.in2 GEE 24/25 Codespaces 4V.in1 HAR 24/25 Codespaces 4V.in2 HAR 24/25 Codespaces 4H.in1 HAR 24/25 GitPod (oude link) 4V.in1 HAR 24/25 GitPod (oude link) Nadat je jezelf helemaal ingeschreven hebt, krijg je automatisch toegang tot een repository met startcode. Er is één repository per team. Elk teamlid heeft lees- en schrijfrechten in de repository.\nGame kiezen Je bent vrij om zelf te kiezen welke game je gaat maken. Je docent moet de game die je kiest goedkeuren. Enkele voorbeelden van een game die je kunt maken zijn: Tennis, Flappy Bird, Snake (voorganger van Slither.io), een Break Out Game (zoals Arkanoid), een race spelletje, een eenvoudige platform game (zoals pacman), een puzzelspel enzovoort.\nBeantwoord de volgende vragen voor de game die je wilt maken:\nWat is het doel van het spel? Wanneer ben je af? Hoe kun je punten halen? Hoe wordt het spel steeds moeilijker? Hoe werkt de bediening van je spel? Werkwijze Je maakt deze opdracht in een team van twee personen. De docent geeft aan hoe de teams gemaakt worden. Je bepaalt zelf hoe je het werk binnen je team verdeelt, zolang iedereen een gelijkwaardige bijdrage levert. Je krijgt van de docent startcode voor deze opdracht. Deze staat klaar in een repo op GitHub. Er is één repo per team. Je maakt code in Gitpod. Elk teamlid heeft zijn eigen Gitpod omgeving. Elke week (liefst vaker) slaan alle teamleden hun tussentijdse werk op in de repo op GitHub. Zo zorgen jullie ervoor dat de laatste werkende versie van jullie opdracht steeds op GitHub staat. Deze opdracht maak je alsof het een echt project is. Je maakt eerst een planning. Daarna kijk je wekelijks of je nog volgens plan loopt. Als je niet volgens plan loopt, dan stuur je bij. In de les word je hiermee geholpen, maar uiteindelijk moet jij zorgen dat je op tijd klaar bent en een goed resultaat oplevert. Beoordeling Het cijfer dat je voor je PO krijgt wordt vanuit verschillende invalshoeken bepaald:\nMinimale eisen\nVoordat je een cijfer krijgt voor je PO, wordt gekeken of je werk voldoet aan de minimale eisen. Werk dat niet voldoet aan de minimale eisen krijgt het cijfer 1,0. De minimale eisen zijn:\nDe inhoud is moreel verantwoord: het is niet beledigend, visueel gewelddadig of op andere manieren onfatsoenlijk. Natuurlijk mag je overleggen met klasgenoten en mag je op internet kijken hoe je bepaalde dingen kunt maken. Let wel op dat je geen plagiaat pleegt. Je mag maximaal 5 regels code overnemen van andere leerlingen of internet en je schrijft in het commentaar erbij waar je het voorbeeld vandaan hebt. Dat geldt ook voor code die je zelf vertaalt naar het Nederlands. Overtypen van code uit een Youtube-video of een tutorial van internet volgen en dat resultaat inleveren is niet toegestaan. Je gebruikt de startcode die je krijgt. Je gebruikt het stappenplan dat bij deze opdracht gegeven is. Een download in zip-formaat van je opdracht mag maximaal 50 MB groot zijn. Werking en aantrekkelijkheid\nSpel start op Het spel werkt (hoe klein ook) Behaalde punten zijn zichtbaar bij game-over Het doel en de bediening van het spel is duidelijk Aantrekkelijk uiterlijk Prettige bediening Eenvoudig om mee te beginnen en moeilijker als je verder komt Afwisselend Techniek\nDe code volgt de lijn van het template De code is netjes en duidelijk leesbaar De code bevat geen dubbele stukken code Je hebt de technieken gebruikt die in de programmeerlessen zijn aangeboden. Je hebt dingen toegevoegd waarvan je zelf hebt uitgezocht hoe ze werken Proces\nJe toont inzet tijdens de lessen De planning is vooraf gemaakt, gevolgd en als nodig bijgesteld. De taakverdeling is duidelijk en alle teamleden dragen in gelijke mate bij. Het werk is verdeeld over de weken waarin aan de opdracht kon worden gewerkt, dit blijkt onder andere uit de commits in Github. Extra bepalingen voor je cijfer\nJe krijgt één cijfer per team, maar de docent kan daarvan afwijken. Als de teamleden geen gelijkwaardige bijdrage hebben geleverd, dan kun je een individueel cijfer krijgen. Tip: Zorg dat je een gelijkwaardige bijdrage levert binnen het team. Als het ingeleverde werk van een hoger niveau is dan wat je begrijpt, dan kan de docent extra vragen stellen over je opdracht en op basis daarvan je cijfer bijstellen. Tip: Zorg dat jij en je teamleden je eigen en elkaars werk begrijpen. Fraude wordt gemeld aan de examencommissie, daarna bepaalt de examencommissie wat er met je cijfer gebeurt. Tip: Vermeld altijd de bronnen die je gebruikt hebt en zorg dat duidelijk is welk stuk van je werk op welke bron is gebaseerd. Van Youtube video’s of AI-chats kun je de linken bijvoegen. Inleveren De deadline voor inleveren vind je in de lesplanner. Je kunt vragen stellen tot de laatste les voor de deadline. Je zorgt dat alle bestanden in die nodig zijn om je spel te spelen in GitHub staan, dit zijn ten minste: index.html, style.css en script.js. Als je plaatjes gebruikt, dan staan die er ook bij. Uit de versie historie in GitHub blijkt wanneer je wat gedaan hebt. De laatste versie van je PO die op het moment van de deadline in GitHub staat, wordt gebruikt voor de beoordeling. Startcode Je krijgt van de docent een kopie van onderstaande startcode. Stappenplan Werk de planning af van boven naar beneden. Vul de planning aan en stel bij terwijl je aan de opdracht werkt.\nStap 1: uitleg, spelen, afgaan en punten maak index.html, style.css en script.js met canvas teken speler Zet je code in de functie tekenAlles() beweeg speler Zet je code in de functie beweegAlles() Kies de afmeting van speler Gebruik variabalen spelerX en spelerY als middelpunt van de speler teken je tegenspeler (vijanden of dingen die je moet pakken of doelen of …) beweeg je tegenspeler detecteer botsing zorg dat je af kunt gaan zorg dat je punten kunt halen een simpele manier om punten te geven is de tijd meten hoe lang je het volhoudt zet punten op het scherm maak uitlegscherm en game-overscherm Stap 2: bijvoorbeeld schieten of springen zelf uitwerken… zelf uitwerken… zelf uitwerken… Stap 3: bijvoorbeeld meer tegenstanders zelf uitwerken… zelf uitwerken… zelf uitwerken… Stap x: meer voorbeelden voor uitbreidingen Gebruik plaatjes voor de vijanden Animeer speler Laat badges vallen die extra’s aan speler geven Maak spel steeds moeilijker door toenemend aantal vijanden met tekenVijand Maak andere vijanden bij toenemen tekenVijand Laat vijanden bewegen in patronen Maak bediening met touch of bewegen van telefoon mogelijk (zorg dat toetsenbordbediening ook blijft werken) of bedenk zelf iets… Uitlegvideo’s ","description":"","tags":null,"title":"O2. Game","uri":"/opdrachten/game/"},{"content":"Je leert hoe een computer allerlei soorten informatie opslaat.\nHulpmiddelen We gebruiken in deze module de volgende tools:\nInformatica Actief Oefeningen Informatica Actief, module informatie digitaal\nDigitale afbeeldingen, pixels met kleur (alleen theorie 1 t/m 7) Bits en Bytes (alleen theorie 1 t/m 5) Talstelsels: decimale en binaire getallen (alleen theorie 1 t/m 9) Rekenen met binaire getallen (overslaan) Digitale tekst (alleen theorie 1 t/m 9) Verschillende soorten afbeeldingen (alleen theorie 1 t/m 12) Bewegend beeld en geluid (alleen theorie 1 t/m 7) Digitale informatie in bestanden (alleen theorie 1 t/m 5) Diagnostische toets (overslaan) Beeldbewerking\nBeeldbewerking oefeningen (powerpoint presentatie) met photopea.com Uitleg (havo) Uitleg (vwo) Naslagmateriaal Lespresentatie informatie (havo) Collegesheets informatie (vwo) (heel dik) Lesmateriaal informatie (havo \u0026 vwo) Leerdoelen voor de toets Informatie digitaal\nJe kunt binaire getallen omzetten naar decimale getallen en andersom. Je kunt binaire getallen omzetten naar hexadecimale getallen en andersom. Je kunt decimale getallen omzetten naar hexadecimale getallen en andersom. Je kunt uitrekenen uit hoeveel bits of bytes een kilobyte, megabyte, gigabyte of terabyte bestaat. Je kunt uitleggen waarin de klassieke maten van kilo-, mega-, gigabyte etc. afwijken van de SI-maten. Je weet wat het verschil is tussen ASCII en Unicode en kunt uitleggen hoe ze tekst digitaliseren. Je kunt uitleggen hoe het RGB-kleurenmodel en het CMYK-kleurmodel werken, je kunt de verschillen tussen beide kleurmodellen benoemen en je kunt de modellen gebruiken om kleuren te maken en kleuren te veranderen. Je kent de betekenis van het begrip resolutie Je kunt uitleggen hoe plaatjes worden opgeslagen door een computer Je kent verschillende bestandsformaten voor plaatjes, zoals bmp, gif, jpg en png en de eigenschappen waarin ze van elkaar verschillen Je kunt aangeven welk bestandsformaat voor plaatjes het best geschikt is voor een beschreven situatie Je kunt uitleggen hoe muziek wordt opgeslagen door een computer Je kunt uitleggen hoe video wordt opgeslagen door een computer Je kunt uitleggen wat een extensie is en waar deze voor dient Je kunt uitleggen wat compressie is aan de hand van voorbeelden (tekst, geluid, plaatjes en video) en je kent het verschil tussen lossless en niet-lossless compressie. Alleen vwo: Je kunt op basis van een beschrijving van een compressie algoritme een klein voorbeeld comprimeren en decomprimeren. Beeldbewerking (deze leerdoelen gelden NIET voor schooljaar 23/24)\nJe kunt het aantal pixels van een plaatje aanpassen Je kunt een plaatje bijsnijden (Engels: crop) Je kunt een plaatje in diverse bestand-formaten omzetten (bijvoorbeeld .jpg, .png, .gif) Je kunt basisinstellingen van de kleuren in een plaatje aanpassen (bijvoorbeeld contrast) Je kunt de achtergrond van een plaatje transparant maken, een vast kleur maken, vervangen door een ander plaatje. Je begrijpt wat je kunt doen met lagen en je kunt dat uitleggen aan de hand van een gegeven situatie. Oefentoets Een oefentoets voor deze module staat in Woots .\n","description":"","tags":null,"title":"T2. Digitale informatie","uri":"/theorie/informatie/"},{"content":"Hier vind je alle theorie per module.\nTheorie modules T1. Web Design met HTML en CSS Je leert hoe je informatie op een website zet met de programmeertalen HTML en CSS.\nT2. Digitale informatie Je leert hoe een computer allerlei soorten informatie opslaat.\nT3. Programmeren met Javascript Je leert hoe je eenvoudige programma’s kunt maken met de programmeertaal Javascript en de p5js library.\nT4. Algoritmen in Javascript Je leert hoe je problemen kunt oplossen met algoritmen, je gebruikt daarbij stroomdiagrammen en de programmeertaal Javascript.\nT5. Databases met SQL Je leert hoe je heel veel informatie kunt bekijken en bewaren in databases met de programmeertaal SQL.\nT6. Robotica met Arduino Je leert hoe je met behulp van toestandsgrammen kunt programmeren. Je gebruikt daarbij het Arduino platform.\nT7. Netwerken met IP Je leert hoe het internet van binnen werkt.\nT8. Objectgeoriënteerd Programmeren Je leert objectgeoriënteerd programmeren. Dat is een manier van programmeren waarbij data en logica gebundeld zijn in objecten.\nT9. Security Over de beveiliging van computers en data.\n","description":"","tags":null,"title":"Theorie","uri":"/theorie/"},{"content":"Hier vind je de lesplanner, geplande toetsen en inlevermomenten voor 4 vwo.\nLesplanner 25/26 Het is vandaag .\nData Theorieles (Vrijdag) Praktijkles (Maandag) 1 sep - 7 sep Introductie + Opstarten 8 sep - 14 sep T1 Web Design Uitleg: HTML tags + CSS selectors en properties T1 Web Design Oefening: Khan 1 Intro to HTML + 2 Intro to CSS + 3 More HTML tags 15 sep - 21 sep T1 Web Design Uitleg: boxmodel T1 Web Design Oefening: Khan 4 CSS text properties + 6 CSS layout 22 sep - 28 sep 29 sep - 5 okt T1 Web Design Oefening: Khan 7 More CSS selectors + T1 Web Design Uitleg: floats 6 okt - 12 okt T1 Web Design Uitleg: eye catchers + T1 Web Design Oefentoets in Woots maken T1 Web Design Oefentoets nabespreken 13 okt - 19 okt T2 Informatie Uitleg: bits O1 Website stap 1 eerste wijziging gemaakt 20 okt - 26 okt Herfstvakantie 27 okt - 2 nov T2 Informatie Uitleg: BIN O1 Website stap 2 menu + lege pagina’s 3 nov - 9 nov TW1: Toets 4V-IN-S01 over T1 Web Design 10 nov - 16 nov T2 Informatie Uitleg: HEX O1 Website stap 3 layout hoofdpagina 17 nov - 23 nov T2 Informatie Oefening: IA gestart O1 Website stap 4 inhoud en plaatjes hoofdpagina 24 nov - 30 nov T2 Informatie Oefening: IA t/m 3 O1 Website stap 5 layout subpagina’s 1 dec - 7 dec T2 Informatie Oefening: IA t/m 6 O1 Website stap 6 inhoud en plaatjes subpagina’s 8 dec - 14 dec T2 Informatie kleuren + plaatjes O1 Website stap 7 kleuren 15 dec - 21 dec T2 Informatie tekst + geluid + video + compressie O1 Website stap 8 perfectioneren 22 dec - 28 dec Kerstvakantie 29 dec - 4 jan Kerstvakantie 5 jan - 11 jan T2 Informatie Oefening: Beeldbewerking O1 Website stap 9 eyecathers 12 jan - 18 jan T2 Informatie Oefening: Beeldbewerking PO 4V-IN-S04 website inleveren 19 jan - 25 jan T3 Programmeren Uitleg: programmeertalen + P5JS T3 Oefening Khan t/m 5 Animation basics 26 jan - 1 feb T3 Programmeren Uitleg: variabelen T3 Oefening Khan t/m 10 Functions 2 feb - 8 feb T3 Programmeren Uitleg: functies T3 Oefening Khan t/m 11 Logic and if statements 9 feb - 15 feb T3 Programmeren Uitleg: logica en if T3 Oefening Khan t/m 13 Loopings 16 feb - 22 feb Voorjaarsvakantie 23 feb - 1 mrt T3 Programmeren Uitleg: loops (les) arrays (thuis kijken) T3 Oefening Khan t/m 15 Arrays 2 mrt - 8 mrt TW2: Toets 4V-IN-S02 over T2 Informatie 9 mrt - 15 mrt TW2 16 mrt - 22 mrt uitloop / herhaling / oefentoets uitloop / herhaling / oefentoets 23 mrt - 29 mrt T4 Algoritmen Uitleg: stroomdiagrammen O2 Game eerste wijziging gemaakt 30 mrt - 5 apr T4 Algoritmen Uitleg: lijsten O2 Game speler beweegt 6 apr - 12 apr T4 Algoritmen Uitleg: nesten O2 Game vijand 13 apr - 19 apr T4 Algoritmen Oefenen: eenvoudige algoritmen t/m 2 O2 Game botsingdetectie + afgaan 20 apr - 26 apr meivakantie 27 apr - 3 mei meivakantie 4 mei - 10 mei T4 Algoritmen Oefenen: eenvoudige algoritmen t/m 4 O2 Game punten + gameoverscherm 11 mei - 17 mei T4 Algoritmen Oefenen: eenvoudige algoritmen t/m 6 O2 Game uitlegscherm (je hebt nu een speelbaar spel) 18 mei - 24 mei T4 Algoritmen Oefenen: eenvoudige algoritmen t/m 8 O2 Game werk aan uitbreiding 25 mei - 31 mei T4 Algoritmen Oefenen: eenvoudige algoritmen t/m 10 O2 Game werk aan uitbreiding 1 jun - 7 jun T4 Algoritmen Oefenen: oefentoets algoritmen O2 Game werk aan uitbreiding 8 jun - 14 jun T4 Algoritmen Nabespreken: oefentoets algoritmen O2 Game uitbreiding afmaken PO 4V-IN-S05 game inleveren 15 jun - 21 jun uitloop / herhaling / oefentoets uitloop / herhaling / oefentoets 22 jun - 28 jun TW3: Toets 4V-IN-S03 over T3 Programmeren + T4 Algoritmen 29 jun - 5 jul TW3 6 jul - 12 jul Lesvrije week 13 jul - 19 jul Lesvrije week 20 jul - 26 jul Zomervakantie Toetsen en inlevermomenten Datum Code Toetsvorm Stof Toetsweek 1 4V-IN-S01 Digitale toets T1 Web Design Zaterdag 17 19 jan 2025 23:59 4V-IN-S04 Praktische Opdracht O1 Website Toetsweek 2 4V-IN-S02 Digitale toets T2 Digitale Informatie Zaterdag 13 juni 2025 23:59 4V-IN-S05 Praktische Opdracht O2 Game Toetsweek 3 4V-IN-S03 Digitale Toets T3 Programmeren + T4 Algoritmen ","description":"","tags":null,"title":"4 vwo","uri":"/planning/4v/"},{"content":"Je gaat je eigen webshop maken!\nOpdrachtbeschrijving De opdracht in het kort is: Maak in groepjes van twee je eigen webshop. Je gebruikt de startcode en breidt de database uit met jouw producten. De api en het website deel pas je aan waar dat nodig is.\nInschrijven Je schrijft je in via Github Classroom (login met je github account).\n5Hin2 GEE 24/25 5Vin1 HAR 24/25 5Vin2 GEE 24/25 5Vin3 GEE 24/25 De teamnaam die je invult is de voornamen van de leerlingen in je team, gescheiden door een streepje.\nBijvoorbeeld piet-truus.\nKies wat je gaat verkopen Je bent vrij om zelf te kiezen wat je in je webshop gaat verkopen. Je docent moet goedkeuren wat je verkoopt. Je kunt denken aan kleding, producten die te maken hebben met je idool, zelfgemaakte sieraden, tweedehandsspullen enzovoort. Het hoeven niet persé bestaande producten te zijn.\nWerkwijze Je maakt deze opdracht in een team van twee personen. De docent geeft aan hoe de teams gemaakt worden. Je bepaalt zelf hoe je het werk binnen je team verdeelt, zolang iedereen een gelijkwaardige bijdrage levert. Je krijgt één cijfer per team, maar de docent kan hiervan afwijken als teamleden geen gelijkwaardige bijdrage hebben geleverd. Je krijgt van de docent startcode voor deze opdracht. Deze staat klaar in een repo op GitHub. Er is één repo per team. Je maakt code in Gitpod. Elk teamlid heeft zijn eigen Gitpod omgeving. Elke week (liefst vaker) slaan alle teamleden hun tussentijdse werk op in de repo op GitHub. Zo zorgen jullie ervoor dat de laatste werkende versie van jullie opdracht steeds op GitHub staat. Deze opdracht maak je alsof het een echt project is. Je maakt eerst een planning. Daarna kijk je wekelijks of je nog volgens plan loopt. Als je niet volgens plan loopt, dan stuur je bij. In de les word je hiermee geholpen, maar uiteindelijk moet jij zorgen dat je op tijd klaar bent en een goed resultaat oplevert. Beoordeling Het cijfer dat je voor je PO krijgt wordt vanuit verschillende invalshoeken bepaald:\nDe technische kwaliteit van de database (vwo 40%, havo 60%) De technische kwaliteit van de aanpassingen in de api en het website-deel (vwo 20%, havo 10%) Uitbreidingen die je hebt toegevoegd (vwo 20%, havo 10%) Inzet, planning en samenwerking (20%) Minimale eisen\nVoordat je een cijfer krijgt voor je PO, wordt gekeken of je werk voldoet aan de minimale eisen. Werk dat niet voldoet aan de minimale eisen krijgt het cijfer 1,0. De minimale eisen zijn:\nDe inhoud van je webshop is moreel verantwoord: het is niet beledigend, visueel gewelddadig of op andere manieren onfatsoenlijk. Natuurlijk mag je overleggen met klasgenoten en mag je op internet kijken hoe je bepaalde dingen kunt maken. Let wel op dat je geen plagiaat pleegt. Je mag maximaal 5 regels code overnemen van andere leerlingen of internet en je schrijft in het commentaar erbij waar je het voorbeeld vandaan hebt. Dat geldt ook voor code die je zelf vertaalt naar het Nederlands. Overtypen van code uit een Youtube-video of een tutorial van internet volgen en dat resultaat inleveren is niet toegestaan. Je gebruikt de startcode die je krijgt. Je gebruikt het stappenplan dat bij deze opdracht gegeven is. Een download in zip-formaat van je opdracht mag maximaal 50 MB groot zijn. Database Enkele punten waarop gelet kan worden bij de beoordeling zijn\nJe database is genormaliseerd, dat betekent dat je redundante gegevens hebt voorkomen door het gebruik van meerdere tabellen. Je database bevat minimaal tien producten Je neemt ten minste vijf eigenschappen van producten op. Je database bevat minimaal vijf tabellen. Je database bevat minimaal één relatie van de vorm 1:n en minimaal één relatie van de vorm n:m. Je SQL-code is toegankelijk, dat wil zeggen niet complexer dan nodig, logisch georganiseerd en waar nodig voorzien van commentaar. API en web Enkele punten waarop gelet kan worden bij de beoordeling zijn.\nDe API is aangepast, zodat hij alle informatie uit de database kan doorgeven aan je website. De html en scripts in je website zijn aangepast, zodat ze alle data die de api levert netjes laten zien. Uitbreidingen Enkele punten waarop gelet kan worden bij de beoordeling zijn.\nJe hebt functies toegevoegd waaruit blijkt dat je heel goed begrijpt hoe de database, api en website samenwerken. Je kunt bijvoorbeeld denken aan het aanbrengen van filters waarmee je snel producten kunt zoeken, of een zoekfunctie. Je hebt substantiële (grote) toevoegingen gedaan aan de html/css van het web-site gedeelte, zowel wat betreft de layout als de functionaliteit. Je kunt bijvoorbeeld denken aan een uitbreiding van meerdere pagina’s met nuttige informatie voor kopers. … Inzet, planning en samenwerking\nJe toont inzet tijdens de lessen De planning is vooraf gemaakt, gevolgd en als nodig bijgesteld. De taakverdeling is duidelijk en alle teamleden dragen in gelijke mate bij. Het werk is verdeeld over de weken waarin aan de opdracht kon worden gewerkt, dit blijkt onder andere uit de commits in Github. Inleveren De deadline voor inleveren vind je in de lesplanner. Je kunt vragen stellen tot de laatste les voor de deadline. Je zorgt dat alle bestanden in die nodig zijn om je spel te spelen in GitHub staan, dit zijn ten minste: index.html, style.css en script.js. Als je plaatjes gebruikt, dan staan die er ook bij. Uit de versie historie in GitHub blijkt wanneer je wat gedaan hebt. De laatste versie van je PO die op het moment van de deadline in GitHub staat, wordt gebruikt voor de beoordeling. Hulpmiddelen We gebruiken in deze opdracht de volgende tools:\nGitHub Gitpod Startcode Stappenplan Werk de planning af van boven naar beneden. Vul de planning aan en stel bij terwijl je aan de opdracht werkt.\nStap 1: Start Pas de achtergrondkleur van de shop aan (zie mapje web) Pas de titel van het eerste product in de shop aan (zie mapje db) Pas de query aan zodat getoonde producten gesorteerd worden op naam (zie mapje api) Stap 2: Database opzetten Maak tabellen en velden (CREATE TABLE commando) in je database waarin alle informatie kan worden opgeslagen die je over je producten wilt tonen.\nTip: je kunt een multipliciteitendiagram gebruiken als tussenstap voor je database-ontwerp Vul de tabellen met informatie (INSERT commando) Voeg eventueel plaatjes toe (web/images map) Stap 3: API aanpassen Pas de API aan, zodat je alle informatie uit je database kunt opvragen via de API Stap 4: Website aanpassen Pas de website aan, zodat alle informatie getoond wordt. Stap 5: Webshop verder verbeteren Herhaal stap 2 t/m 4 om je webshop verder te verbeteren. Voor en goed cijfer is het belangrijk dat je laat zien dat je uitstekend begrepen hebt hoe je een webshop moet opzetten. Uitlegvideo’s (have en vwo) ","description":"","tags":null,"title":"O3. Webshop","uri":"/opdrachten/webshop/"},{"content":"Hier vind je de praktische opdrachten. Praktische opdrachten zijn meestal tussen de vier en acht weken werk. Je hebt veel vrijheid en kunt er echt iets moois van maken.\nVoorbeelden Voorbeelden van werkstukken die andere leerlingen hebben gemaakt.\nO1. Website Je gaat je eigen website maken!\nO2. Game Je gaat je eigen game programmeren!\nO3. Webshop Je gaat je eigen webshop maken!\nO4. Robot Je gaat je robot programmeren!\nO5. Marble Mania Knikkerbaan Je maakt een interactieve module voor een grotere knikkerbaan.\n","description":"","tags":null,"title":"Opdrachten","uri":"/opdrachten/"},{"content":"Je leert hoe je eenvoudige programma’s kunt maken met de programmeertaal Javascript en de p5js library.\nHulpmiddelen We gebruiken in deze module de volgende tools:\nKhan Academy Oefeningen Khanacademy, module Intro to JS Intro to programming Drawing basics Coloring Variables Animation basics Interactive programs Becoming a community coder (overslaan) Bonus: Resizing with variables Text and strings Functions (lang) Logic and if Statements (lang) Debugging programs (kort) Looping (lang) Writing clean code (kort) Arrays (lang) Objects (overslaan) Object-Oriented Design (overslaan) Becoming a better programmer (overslaan) Verdiepingsopdrachten\nMy Pong Game voor als je oefeningen 1 t/m 11 af hebt My Galaxy voor als je oefeningen 1 t/m 15 af hebt Uitleg Naslagmateriaal Lespresentatie programmeren (havo) Collegesheets programmeren (vwo) (heel dik) Leerdoelen voor de toets Programmeertalen\nJe kunt uitleggen wat machinetaal is. Je kunt uitleggen wat een compiler is. Je kunt uitleggen wat een library is. Je kunt drie hogere programmeertalen opnoemen. Je kunt uitleggen wat er binnen de informatica bedoeld wordt met het begrip grammatica. Je kunt uitleggen wat een variabele is. Je kunt uitleggen wat declareren en definiëren van een variabele is. Je kunt uitleggen wat een datatype is Je kent de datatypen boolean, number en string en begrijpt welke waarden erin opgeslagen worden Je kunt uitleggen wat controlestructuren zijn en je kent de volgende voorbeelden: if-statement, for-loop, while-loop. Je kunt uitleggen waar abstractie voor dient. Je kunt uitleggen wat een functie is. Je kunt uitleggen wat declareren, definiëren en aanroepen van een functie is. Je kunt uitleggen wat een parameter van een functie is. Je kunt uitleggen wat het resultaat van een functie is. Je kunt uitleggen wat het verschil is tussen globale en lokale variabelen. Je kunt de leesbaarheid van code verbeteren door gebruik te maken van commentaar, lay-out en structuur. Javascript\nje kunt commentaarregels gebruiken. je kunt aangeven welke waarden bepaalde variabelen hebben aan het einde van een stukje computercode. je kunt op basis van een stukje code zelf de bijbehorende schermuitvoer tekenen. je kunt met behulp van naslagmateriaal zelf computercode schrijven om een vraag te beantwoorden. je weet hoe je in een tekening animatie aanbrengt. je begrijpt wat variabelen zijn en hoe je deze kunt gebruiken. je begrijpt wat een logische expressie is en hoe je deze kunt gebruiken. je begrijpt hoe de logische operatoren “en”, “of” en “niet” werken en je kunt deze gebruiken. je begrijpt hoe de vergelijkingsoperatoren “groter dan”, “kleiner dan”, “groter-gelijk dan”, “kleiner-gelijk dan”, “gelijk aan” en “ongelijk aan” werken en je kunt deze gebruiken. je weet wat de datatypen boolean, number en string zijn en kunt deze gebruiken. je begrijpt hoe een if-statement werkt en hoe je deze kunt gebruiken. je begrijpt hoe een while-loop en een for-loop werken en hoe je deze kunt gebruiken. je kunt een while-loop omzetten naar een for-loop en andersom. je begrijpt hoe een for-loop in een for-loop werkt en hoe je dit kunt gebruiken. je begrijpt wat arrays zijn en hoe je deze kunt gebruiken. je kunt een array doorlopen met een for-loop. Alleen vwo: je kunt een twee-dimensionale array doorlopen met een for-loop in een for-loop je begrijpt hoe een functie werkt en hoe je deze kunt gebruiken. je begrijpt wat parameters van een functie zijn en hoe je deze gebruikt. je begrijpt wat het resultaat van een functie is en hoe je dit gebruikt. je begrijpt wat er op het syntaxblad Javascript staat en dit kunt toelichten en gebruiken. Oefentoets Een oefentoets voor deze module staat in Woots .\n","description":"","tags":null,"title":"T3. Programmeren met Javascript","uri":"/theorie/programmeren/"},{"content":"Hier vind je de lesplanner, geplande toetsen en inlevermomenten voor 5 vwo.\nLesplanner 25/26 Het is vandaag .\nWeek Theorie+Praktijk (les 1) Praktijk (les 2) 35 intro 36 T7 Netwerken Uitleg: lagen deel 1 T7 Netwerken Oefenen: 1. IA (met Filius) 37 T7 Netwerken Uitleg: lagen deel 2 T7 netwerken Oefenen: 2. IA (met Filius) 38 T7 Netwerken Uitleg: ethernet T7 netwerken Oefenen: 3. IA (met Filius) 39 T7 Netwerken Uitleg: IP T7 netwerken Oefenen: 4 + 5 IA (met Filius) 40 T7 Netwerken Uitleg: RFC’s T7 netwerken Oefentoets in Woots 41 T5 Databases Uitleg: SELECT WHERE T5 Databases Oefening: Khan 1 SQL Basics 42 T5 Databases Uitleg: GROUP BY T5 Databases Oefening: Khan 2 More advanced SQL-queries 43 Herfstvakantie 44 T5 Databases Uitleg: JOIN T5 Databases Oefening: Khan 1e helft van Khan 3 Relational Queries 45 Voorbereiding voor toets of verder met databases TW1: Toets 5V-IN-S06 over T7 Netwerken 46 TW1 47 T5 Databases Uitleg: multipliciteiten- en strokendiagram T5 Databases Oefening: Khan 2e helft van 3 Relational Queries 48 T5 Databases Uitleg: Ruimtedatabase voorbeeldopgave\nMaak vooraf: Ruimtedatabase vragen met meerdere tabellen in Woots T5 Databases Oefening: Khan 4 Modifying Databases 49 O3 Webshop Intekenen O3 Webshop Voorbeeldcode ontvangen 50 O3 Webshop Uitleg stap 1 (hoofdlijnen) O3 Webshop Stap 1 51 O3 Webshop Stap 2 DB O3 Webshop Stap 2 DB 52 Kerstvakantie 1 Kerstvakantie 2 O3 Webshop Stap 3 API O3 Webshop Stap 3 API 3 O3 Webshop Stap 4 Web O3 Webshop Stap 4 Web 4 O3 Webshop Stap 5 verbeteren DB O3 Webshop Stap 5 verbeteren API 5 O3 Webshop Stap 5 verbeteren Web O3 Webshop Stap 5 opschonen code 6 O3 Webshop 5V-IN-S09 webshop inleveren 8 Voorjaarsvakantie 9 voorbereiding TW2 voorbereiding TW2 10 TW2: Toets 5V-IN-S07 over T5 Databases 11 TW2 T6 Robotica Intro en Arduino uitdelen 12 T6 Robotica Uitleg: microcontrollers deel 1 T6 Arduinolessen 3 + 4 13 T6 Robotica Uitleg: microcontrollers deel 2 T6 Arduinolessen 5 14 T6 Robotica Uitleg: toestandsdiagrammen deel 1 T6 Toestandsdiagrammen opdracht 1 15 Tweede Paasdag T6 Toestandsdiagrammen opdracht 2 16 T6 Robotica Uitleg: toestandsdiagrammen deel 2 T6 Toestandsdiagrammen opdracht 3 17 meivakantie 18 meivakantie 19 Vrij O4-Robot : stap 1 intro 20 O4-Robot : stap 1 start O4-Robot : stap 2 toestandsdiagram 21 O4-Robot : stap 2 toestandsdiagram O4-Robot : stap 3 code 22 Tweede Pinksterdag O4-Robot : stap 3 code 23 O4-Robot : stap 4 uitbreidingen O4-Robot : stap 4 uitbreidingen 24 O4-Robot : stap 4 uitbreidingen (/opdrachten/robot/):stap 5 video 5V-IN-S10 robot inleveren 25 voorbereiding TW3 extra les: voorbereiding TW3 26 TW3: Toets 5V-IN-S08 over T6 Robotica 27 TW3 28 Lesvrije week 29 Lesvrije week 28 Zomervakantie Toetsen en inlevermomenten Datum Code Toetsvorm Stof Toetsweek 1 5V-IN-S06 Digitale toets T7 Netwerken Zondag 23 feb 2025 23:59 5V-IN-S09 Praktische Opdracht O3 Webshop Toetsweek 2 5V-IN-S07 Digitale toets T5 Databases Zondag 15 juni 2025 23:59 5V-IN-S10 Praktische Opdracht O4 Robot Toetsweek 3 5V-IN-S08 Digitale Toets T6 Robotica ","description":"","tags":null,"title":"5 vwo","uri":"/planning/5v/"},{"content":"Hulpmiddelen zijn programma’s die we gebruiken om dingen te maken. Hulpmiddelen zijn dus gereedschap (Engels: tools) dat je gebruikt bij informatica.\nDe hulpmiddelen die we bij informatica gebruiken:\nKhan Academy Khan Academy is internationale online lesmethode met cursussen voor diverse onderwerpen. Wij gebruiken enkele cursussen uit de sectie Computer Programming.\nInformatica Actief Informatica Actief is de lesmethode voor informatica die wij gebruiken. Wij gebruiken enkele modules uit de methode.\nGitHub met Codespaces en VS Code GitHub is een website waar je code kunt opslaan en delen. Codespaces is een codeeromgeving binnen GitHub waar je code kunt wijzigen en uitvoeren. Codespaces maakt gebruik van de webversie van de editor Visual Studio Code.\nArduino IDE Arduino IDE is een programma waarin je code kunt schrijven en downloaden in je Arduino.\nFilius Filius is een programma waarmee je netwerken kunt namaken en simuleren.\n","description":"","tags":null,"title":"Hulpmiddelen","uri":"/tools/"},{"content":"Je gaat je robot programmeren!\nOpdrachtbeschrijving De opdracht in het kort is: programmeer een apparaat naar keuze met behulp van een toestandsdiagram.\nInschrijven Je schrijft je in via het onderstaande formulier dat de docent aanlevert (login met je google account van school voor toegang).\nJe teamnaam is de voornamen van iedereen die in je groepje zit.\n5Vin1 HAR 24/25 5Vin2 GEE 24/25 5Vin3 GEE 24/25 5Hin2 GEE 24/25 5Hin CAM 24/25 Apparaat kiezen Je bent vrij om zelf te kiezen voor welk van de aangeboden apparaten je een programma gaat maken. Je docent moet je keuze goedkeuren. De apparaten die je kunt programmeren zijn:\nStoplichtenplein (havo) De opdracht voor dit apparaat\nMaak een programma waarmee de stoplichten zo op groen, oranje en rood springen dat auto’s en voetgangers zo efficient mogelijk over de kruising kunnen.\nHet stoplichtenplein\nJe mag het plein uitbreiden met sensoren die auto’s waarnemen.\nArcade game box (havo en vwo) De opdracht voor dit apparaat\nMaak een game die zo boeiend mogelijk is. De arcade box\nJe mag gebruik maken van alle mogelijkheden die de hardware in de arcadebox biedt. Dit zijn 4 knoppen met dimbare verlichting, een speaker en een display met twee regels van zestien karakters en de mogelijkheid om zelf een beperkt aantal karakters te ontwerpen.\nAlphabot2 rijdende robot (havo en vwo)\nDe opdracht voor dit apparaat\nMaak een programma dat de alphabot zo snel mogelijk de uitgang van een doolhof laat vinden.\nDe alphabot\nJe moet mimimaal de beide motoren en één type afstandssensor van de alphabot2 gebruiken. De afstandssensoren waar je uit kunt kiezen zijn de ultrasone afstandssensor voorop, de twee infrarode aftandssensoren schuin links- en rechtsvoor en de lijnvolgsensoren onderop. Je kunt je oplossing uitbreiden door meerdere sensortypen te gebruiken. Je kunt je programma ook uitbreiden door het display, de speaker of de RGB-leds onderop te gebruiken om te laten merken wat de alphabot aan het doen is.\nHet doolhof\nHet doolhof bestaat uit en pad met doodlopende vertakkingen. In het doolhof zitten geen rondjes. De paden worden gevormd door vierkanten van ongeveer 30x30 cm. Aan de randen van de paden staan muren. De muren bestaan uit stukken van ongeveer 30 centimeter lang. De stukken muur sluiten recht op elkaar aan of maken een hoek van ongeveer 90 graden. In de midden van het pad is er een strook zwart tape op de vloer gemaakt. Dit tape bevat vertakkingen en is steeds ongeveer 15 cm van een muur verwijderd.\nDrone (experimenteel voor vwo in 22/23, vwo vanaf 23/24)\nDe opdracht voor dit apparaat\nLaat de drone zo snel mogelijk van de startplek naar de finish plek vliegen. Onderweg staan opstakels.\nDe drone\nJe gebruikt commando’s om de drone te laten opstijgen en landen en om de drone in een bepaalde richting te laten vliegen. Je gebruikt de afstandssensor voor op de drone om de afstand tot opstakels te meten.\nHet parcours\nHet parkcours wordt telkens opgebouwd en afgebroken in de gang. De drone mag niet buiten het parcours vliegen, geen obstakels of muren raken en tijdens het vliegen mogen er geen personen binnen de grenzen van het parcours aanwezig zijn. Er is een vast punt waar de drone start en een zone waar de drone eindigt. De drone vliegt op vaste afstand van de grond (ongeveer 1 meter). De obstakels bevinden zich op de hoogte waar de drone vliegt. Tijdens de opdracht werk je in overleg met de docent het parcours verder uit.\nIn overleg met je docent mag je ook een eigen apparaat kiezen of een bestaand apparaat uitbreiden.\nWerkwijze Je maakt deze opdracht in een team van twee personen. De docent geeft aan hoe de teams gemaakt worden. Je bepaalt zelf hoe je het werk binnen je team verdeelt, zolang iedereen een gelijkwaardige bijdrage levert. Je krijgt één cijfer per team, maar de docent kan hiervan afwijken als teamleden geen gelijkwaardige bijdrage hebben geleverd. Je krijgt van de docent startcode voor deze opdracht. Deze staat klaar in een repo op GitHub. Er is één repo per team. Je maakt code in de Arduino IDE. Je zorgt dat alle teamleden even veel coderen. Elke les sla je je tussentijdse werk op in de repo op GitHub. Dat doe je door de nieuwe versies van je bestanden met de hand te uploaden in de webpagina, want de Arduino IDE heeft geen automatische koppeling met GitHub. Deze opdracht maak je alsof het een echt project is. Je maakt eerst een planning. Daarna kijk je wekelijks of je nog volgens plan loopt. Als je niet volgens plan loopt, dan stuur je bij. In de les word je hiermee geholpen, maar uiteindelijk moet jij zorgen dat je op tijd klaar bent en een goed resultaat oplevert. Beoordeling Het cijfer dat je voor je PO krijgt wordt vanuit vier invalshoeken bepaald:\nminimale eisen uiterlijk techniek inzet, planning en samenwerking Minimale eisen\nVoordat je een cijfer krijgt voor je PO, wordt gekeken of je werk voldoet aan de minimale eisen. Werk dat niet voldoet aan de minimale eisen krijgt het cijfer 1,0. De minimale eisen zijn:\nDe inhoud van je opdracht is moreel verantwoord: het is niet beledigend, visueel gewelddadig of op andere manieren onfatsoenlijk. Natuurlijk mag je overleggen met klasgenoten en mag je op internet kijken hoe je bepaalde dingen kunt maken. Let wel op dat je geen plagiaat pleegt. Je mag maximaal 5 regels code overnemen van andere leerlingen of internet en je schrijft in het commentaar erbij waar je het voorbeeld vandaan hebt. Dat geldt ook voor code die je zelf vertaalt naar het Nederlands. Overtypen van code uit een Youtube-video of een tutorial van internet volgen en dat resultaat inleveren is niet toegestaan. Je gebruikt de startcode die je krijgt. Je gebruikt het stappenplan dat bij deze opdracht gegeven is. Een download in zip-formaat van je opdracht mag maximaal 50 MB groot zijn. Werking en aantrekkelijkheid\nJe apparaat start op Je apparaat reageert op de omgeving De bediening van je apparaat is eenvoudig en logisch Het nut/doel van je apparaat is duidelijk Het apparaat bevat diverse functionaliteiten / mogelijkheden Je hebt uitbreidingen op het apparaat gemaakt … Techniek\nDe code volgt de lijn van de startcode De code is netjes en duidelijk leesbaar De code bevat geen dubbele stukken code Je hebt de technieken gebruikt die in de lessen zijn aangeboden. Je hebt dingen toegevoegd waarvan je zelf hebt uitgezocht hoe ze werken … Inzet, planning en samenwerking\nJe toont inzet tijdens de lessen De planning is vooraf gemaakt, gevolgd en als nodig bijgesteld. De taakverdeling is duidelijk en alle teamleden dragen in gelijke mate bij. Het werk is verdeeld over de weken waarin aan de opdracht kon worden gewerkt. Inleveren De deadline voor inleveren vind je in de lesplanner. Je kunt vragen stellen tot de laatste les voor de deadline. Je zorgt dat alle bestanden in die nodig zijn om je spel te spelen in GitHub staan, dit zijn ten minste: het .ino bestand met de code, een bestand met het toestandsdiagram (.excalidraw, .drawio, .pptx, .jpeg, .png of .pdf) en een link naar de video op youtube (.txt) of de video zelf (.mp4 of .mov). Als je libraries gebruikt, dan staan die er ook bij. Uit de versie historie in GitHub blijkt wanneer je wat gedaan hebt. De laatste versie van je PO die op het moment van de deadline in GitHub staat, wordt gebruikt voor de beoordeling. Hulpmiddelen We gebruiken in deze opdracht de volgende tools:\nGitHub om je werk op te slaan. Arduino IDE om je code voor de arduino te bewerken en in je apparaat te laden. Er is geen automatische koppeling tussen Arduino IDE en GitHub. Dat betekent dat je je bestanden via de webinterface van GitHub moet downloaden en uploaden.\nStartcode Als je van je docent je een kopie van de startcode hebt ontvangen, dan kun je aan de slag met de stappen uit het README.md bestand.\nStappenplan Werk de planning af van boven naar beneden.\nStap 1: Starten Je hebt je GitHub-inlognaam aan de docent doorgegeven, zodat die een Github-repo kan aanmaken. Je hebt gekozen wat je gaat maken en dat aan de docent doorgegeven, bij een eigen idee moet de docent het goedkeuren. Je hebt thuis een computer of laptop (Arduino werkt niet op een iPad) waarop je de gratis Arduino software hebt geïnstalleerd, of je hebt er rekening mee gehouden dat je een paar uur per week op school op een computer kan werken. Je hebt de startcode voor je project uitgeprobeerd. Je vindt de startcode in het .ino bestand in de map die hoort bij wat je gaat maken. Stap 2: Toestandsdiagram Je hebt een toestandsdiagram gemaakt. Dit sla je op in GitHub. Je hebt je docent gevraagd om feedback over je toestandsdiagram. De feedback heb je verwerkt. Het uiteindelijke resultaat sla je weer op in GitHub. Je hebt aangegeven welke sensoren en actuatoren je gaat gebruiken, dit kan in een kort lijstje op hetzelfde blad als je toestandsdiagram. Je kunt een toestandsdiagram bijvoorbeeld als volgt maken\nop https://excalidraw.com/ (snel en eenvoudig) of op https://draw.io (meer mogelijkheden) in Powerpoint op papier en dan fotograferen (het is dan wel lastig om het netjes te doen) Stap 3: Code Je hebt het toestandsdiagram in code omgezet, zodat alle toestanden doorlopen kunnen worden met jouw circuit. Daarbij heb je het door de docent aangeleverde projectcode als startpunt gebruikt. Nog niet alle sensoren of actuatoren van je apparaat hoeven het te doen, zolang alle toestanden maar doorlopen kunnen worden. De laatste versie van je code sla je steeds op op GitHub. Je hebt de code van je toestandsdiagram uitgebreid, zodat alle sensoren en actuatoren van je project het doen. Je apparaat werkt nu volledig en zoals beschreven in het toestandsdiagram. De laatste versie van je code sla je steeds op op GitHub. Stap 4: Uitbreidingen Je hebt je ontwerp uitgebreid met extra ideeën en deze heb je verwerkt in je toestandsdiagram en in je code. De laatste versie van je toestandsdiagram en code sla je steeds op op GitHub. Stap 5: Video Maak een video die de werking van je project demonstreert. Het is een video met geluid (uitleg tijdens de demonstratie) in .mp4 of .mov formaat van maximaal 20MB of .txt bestand met link naar youtube. De video duurt maximaal 2 minuten.\nUitlegvideo’s Er zijn op dit moment (nog) geen uitlegvideo’s bij deze opdracht.\n","description":"","tags":null,"title":"O4. Robot","uri":"/opdrachten/robot/"},{"content":"Je leert hoe je problemen kunt oplossen met algoritmen, je gebruikt daarbij stroomdiagrammen en de programmeertaal Javascript.\nHulpmiddelen We gebruiken in deze module enkele online hulpmiddelen voor het tekenen van schema’s en het maken van oefeningen.\nOefeningen Eenvoudige algoritmen\nStroomdiagrammen lespresentatie, met codevoorbeelden in replit (wordt misschien herzien) Lespresentatie korste-pad-algoritme Programmeeropdrachten in Github (tevens beschikbaar in Woots ) Uitleg Leerdoelen voor de toets Eenvoudige algoritmen\nje kunt uitleggen wat een algoritme is je kunt uitleggen wat een flowchart is en waarvoor je deze gebruikt je kunt flowcharts lezen, dat betekent dat je de output van een flowchart kunt bepalen als de input en de flowchart gegeven worden je kunt een flowchart maken van een eenvoudig algoritme waarvan je een korte beschrijving en een voorbeeld van de input en de output krijgt. Een eenvoudig algoritme is een algoritme waarbij een rij wordt doorlopen, zoals bijvoorbeeld: zoek het grootste getal in een rij, bereken het gemiddelde van alle getallen in een rij, tel het aantal keer dat een bepaalde letter voorkomt in een tekst. je kunt een flowcharts omzetten naar JavaScript code en JavaScript code kunnen omzetten naar een flowchart. Complexe algoritmen (vervalt in 2024/2025)\nje kunt met een gegeven graaf handmatig Dijkstra’s kortste pad algoritme uitvoeren en zo het korste pad tussen twee knopen / punten vinden. Oefentoets Een oefentoets voor deze module staat in Woots .\n","description":"","tags":null,"title":"T4. Algoritmen in Javascript","uri":"/theorie/algoritmen/"},{"content":"Chapter 4 This could be yours Start your success story. Now!\n","description":"","tags":null,"title":"This could be yours","uri":"/yours/"},{"content":"Hier vind je de lesplanner, geplande toetsen en inlevermomenten voor 6 vwo.\nLesplanner 25/26 Data Les 1 Les 2 1 sep - 7 sep T8 - Objectgeoriënteerd programmeren introweek opfrissen Javascript 8 sep - 14 sep T8 - Diagnostische toets Bespreken toets, verder met opfrissen Javascript 15 sep - 21 sep T8 - Theorie: objecten en classes Doen: verwerkingsopdracht 1 T8 - Theorie: objectdiagrammen Doen: verwerkingsopdracht 1 en UML-opdracht 1a. Indien nodig: verder met opfrissen Javascript 22 sep - 28 sep T8 - Theorie: OverervingDoen: programmeren verwerkingsopdracht 2 T8 - Doen: verder met verwerkingsopdracht 2 en UML-opdracht 2a. 29 sep - 5 okt T8 - Theorie: InkapselingDoen: verwerkingsopdracht 3 T8 - Doen: verder met verwerkingsopdracht 3 en UML-opdracht 3a 6 okt - 12 okt T8 - Uitleg: Associatie Doen: verwerkingsopdracht 4 T8 - Doen: verder met verwerkingsopdracht 4 en UML-opdracht 4a 13 okt - 19 okt Afronding T8, start Marble Mania intro, werkwijze, maken groepen Marble Mania uitleg opdracht 20 okt - 26 okt Herfstvakantie 27 okt - 2 nov Marble Mania Start sprint 1 : ingang, teller en poort Marble Maniasprint 1 3 nov - 9 nov Marble Maniasprint 1 TW1: Toets 6V-IN-S11 over T8 Object Oriented Programming 10 nov - 16 nov TW1 Marble Mania Einde sprint 1 17 nov - 23 nov Marble Maniastart sprint 2 Marble Maniasprint 2 24 nov - 30 nov Marble Maniasprint 2 Marble ManiaEinde sprint 2 1 dec - 7 dec Marble Maniastart sprint 3: Knikkerbaan af Marble Maniasprint 3 8 dec - 14 dec Marble Maniasprint 3 Marble ManiaEinde sprint 3: demo en beoordeling 1 15 dec - 21 dec Marble Maniastart sprint 4: Maak en koppel website Marble Maniasprint 4 22 dec - 28 dec Kerstvakantie 29 dec - 4 jan Kerstvakantie 5 jan - 11 jan Marble Mania sprint 4 Marble Mania Einde sprint 4 12 jan - 18 jan Marble Mania start sprint 5: Finishing touch Marble Mania sprint 5 19 jan - 25 jan Marble Mania sprint 5 Marble Mania Einde sprint 5 demo en beoordeling 2 26 jan - 1 feb Nieuw theorie-onderdeel: T9 Security – Theorieles wachtwoorden en hashing T9 Security – Theorieles symetrische encyptie 2 feb - 8 feb T9 Security – Theorieles asymetrische encryptie T9 Security – Theorieles gevaren en oplossingen 9 feb - 15 feb T9 Security – Theorieles praktijkvoorbeelden T9 Security – Praktijkles Hacking (CTF) 16 feb - 22 feb Voorjaarsvakantie 23 feb - 1 mrt T9 Security – Praktijkles Hacking (CTF) T9 Security – Praktijkles Hacking (CTF) 2 mrt - 8 mrt TW2: Toets 6V-IN-S12 over T9 Security 9 mrt - 15 mrt TW2 16 mrt - 22 mrt nader te bepalen nader te bepalen 23 mrt - 29 mrt Bespreken 6V-IN-S11 nader te bepalen 30 mrt - 5 apr nader te bepalen nader te bepalen 6 apr - 12 apr nader te bepalen nader te bepalen 13 apr - 19 apr nader te bepalen informatica afgerond 20 apr - 26 apr meivakantie 27 apr - 3 mei meivakantie examencijfer informatica bekend 4 mei - 10 mei Start CE geen CE voor informatica 11 mei - 17 mei Start CE geen CE voor informatica 18 mei - 24 mei Start CE geen CE voor informatica Toetsen en inlevermomenten Datum Code Toetsvorm Stof Toetsweek 1 6V-IN-S11 Digitale toets T8 Objectgeoriënteerd Programmeren week 50 - laatste les van de week 6V-IN-S13 deel 1 Praktische Opdracht O5 Marble Mania of CanSat week 4 - laatste les van de week 6V-IN-S13 deel 2 Praktische Opdracht O5 Marble Mania of CanSat Toetsweek 2 6V-IN-S12 Digitale toets T9 Security ","description":"","tags":null,"title":"6 vwo","uri":"/planning/6v/"},{"content":"Hier vind je informatie voor docenten. Geen geheimen natuurlijk, want leerlingen kunnen deze pagina ook bekijken.\nOnze filosofie We zijn in juni 2022 begonnen met deze site, vanuit de behoefte om alle verschillende stukken lesmateriaal die we de afgelopen jaren verzameld hebben overzichtelijk en laagdrempelig voor leerlingen bij elkaar te brengen. Bij het maken van de site hebben we ons laten leiden door de volgende uitgangspunten:\ninformatica als praktisch vak (leuk voor leerlingen, relevantie van theorie door koppeling met praktijk) laagdrempelig voor leerlingen (zo min mogelijk drempels: weinig kliks, ook op mobiel, geen inlog, snel vinden wat je zoekt, eenvoudige structuur) modulair programma (eenvoudig te onderhouden, onderdelen eenvoudig te vernieuwen) we maken geen lesmethode, maar een programma. Dat betekent dat we zoveel mogelijk verwijzen naar bestaand (Nederlandstalig of Engelstalig) lesmateriaal. Gebruiken in je klas Geef de link aan je leerlingen en gebruik de delen die je aanstaan. Zolang je doel is om leerlingen te helpen met informatica, vinden wij het geweldig.\nZelf aanpassen Wil je aanpassingen doen? Dat doe je zo:\nFork onze repo op github Maak de juiste instellingen (vraag CAM@emmaus) Pas de site naar je eigen behoeften aan Probeer schoolspecifieke informatie zoveel mogelijk te scheiden van de rest, dat is handig als je updates van ons wilt overnemen Meer informatie over de gebruike technieken\nHugo Documentation Theme Relearn Documentation Veelgestelde vragen Hoe beoordelen jullie praktische opdrachten?\nZie onze rubrics voor P1 website , P2 game , P3 webshop en P4 robot voor inspiratie. Hoe werkt GitHub?\nZie onze docentenhandleiding voor GitHub, Codespaces en Classroom . Bijdragen… We vinden het tof als je het programma gebruikt en nog toffer als je mee wilt werken om het verder te verbeteren. Als we kennis delen dan wordt het voor iedereen beter en kost het ons met zijn allen minder tijd om een mooi programma te onderhouden. Bijdragen kan als volgt:\nVoor kleine wijzigingen (binnen 1 pagina) kun je klikken op het potlood rechtsboven elke pagina. De aanpassing kun je vervolgens in github maken. Na goedkeuring worden ze automatisch verwerkt. (@we moeten dit nog testen) Voor substantielere wijzigingen, zoals toevoegen van een nieuwe (keuze)module. Contact ons via mail. We staan altijd open voor het uitwisselen van ervaring, contact ons Contact Arie Pieter Cammeraat CAM@emmaus\nSander van Geest GEE@emmaus Aksel Harrewijn HAR@emmaus Allen docent informatica op het Emmauscollege Rotterdam (volledige mailadres niet opgenomen ter bescherming tegen spam, tip: het mailadres eindigt op emmauscollege.nl 😉)\nMeer inspiratie Kijk voor meer inspiratie ook eens op de informatica site van deze scholen:\nMetis Montessori Lyceum Amsterdam License This site is licensed under the MIT License .\nCredits Wil jij je naam hier? Help ons dan om de site beter te maken.\n","description":"","tags":null,"title":"Docentenpagina","uri":"/docenten/"},{"content":"Je maakt een interactieve module voor een grotere knikkerbaan.\nOpdrachtbeschrijving In het vakgebied van informatica wordt heel veel projectmatig gewerkt. Een van de manieren om dit te doen is Agile. Bij deze opdracht ga je in groepen van 3 of 4 leerlingen projectmatig werken aan een knikkerbaan die verbonden is met een computer. Hierbij ga je veel kennis en vaardigheden die bij het vak informatica hebt opgedaan toepassen en integreren. Er vindt op twee momenten een beoordeling plaats.\nWat ga je precies opleveren? Een module voor een knikkerbaan. Het is de bedoeling dat je bovenaan knikkers kunt ontvangen en ze onderaan weer laat vallen, zodat een volgende module ze weer kan opvangen. Ook moet de knikkerbaan om kunnen gaan met verschillen in de snelheid waarmee nieuwe knikkers aangeleverd worden en ervoor zorgen dat er geen knikkers vastlopen. Klik hier voor de basislayout. Deze module is interactief: hij maakt gebruik van Arduino, heeft minimaal een teller, een snelheidsmeter (sensors), een poortje en een wissel (actuators). De module staat via USB in verbinding met een website die op een computer draait. De basis van de opdracht wordt aan je gegeven met uitleg hoe je de basis van de knikkerbaan moet maken, inclusief een teller (onderbrekingssensor) en een poortje (servomotor -\u003e actuator).\nDe knikkerbaanmodule mag natuurlijk meer sensors en actuators krijgen. Je kunt natuurlijk meer tellers toevoegen en meer poortjes, je kunt ook denken aan een kleurensensor, afstandssensor, krachtsensor, gewichtsensor etc. Of als actuators: ledjes, een RGB-ledstrip, display, buzzer, andere bewegende onderdelen (bijv. met behulp van een 360-gradensensor). Als je twijfelt of iets kan / mag, vraag even aan je docent.\nEen kleine webpagina. Deze webpagina is een widget waarmee je de statusgeschiedenis van je knikkerbaanmodule kunt weergeven, maar ook het gedrag van de knikkerbaan kunt aanpassen / configureren. Je krijgt informatie van de knikkerbaan, maar geeft ook informatie terug waarop de knikkerbaan moet reageren. Je kunt dus informatie van de sensors zien en het functioneren van de actuators beïnvloeden. De widget kan later door de docent opgenomen worden in een grote webpagina waar een overzicht te zien is van alle modules van de uiteindelijke knikkerbaan.\nVerslaglegging van planning, voortgang en samenwerking. We verwachten dat je minimaal aan het begin van iedere sprint een screenshot in de daarvoor bestemde map in GitHub plaatst met de bijgewerkte planning. Nog beter: doe dit iedere eerste les van de week. Daarnaast willen we dat ieder teamlid in gelijke mate bijdraag\nInleveren en beoordeling De laatste les van de week van sprint 3 wordt de knikkerbaan zonder widget beoordeeld. Er wordt beoordeeld op uiterlijk, functionaliteit, techniek en planning. Dit deelcijfer telt voor 50% mee in het totaalcijfer van S13. De laatste les van de week van sprint 5 wordt de widget beoordeeld. Ook bij deze beoordeling wordt naar uiterlijk, de functionaliteit, techniek en planning gekeken. Belangrijk is dat de widget en de knikkerbaan echt met elkaar communiceren. Mocht je aan het einde van sprint 5 nog substantiële verbeteringen hebben gedaan aan de knikkerbaan, dan kan je eerste deelcijfer met maximaal 1 punt opgehoogd worden. Hulpmiddelen GitHub - zodat iedereen aan de code kan werken en alles wel netjes op één plek staat. Daarnaast maken we gebruik van extra functies van GitHub om goed projectmatig te kunnen werken. GitPod - voor het ontwerpen/ programmeren van de server-app en de website. Je programmeert deze onderdelen vooral in JavaScript. Arduino - voor het programmeren van de knikkerbaan. Planning Je werkt bij deze opdrachten in sprints. Een sprint is een periode van twee weken waarbij je met elkaar afspreekt wat er aan het einde van de twee weken af is en wie dit doet. Halverwege de sprint kun je daar eventueel een kleine wijziging in aanbrengen. Om INzichtelijke te maken wat er gedaan moet worden, wie wat aan het doen is en wat is afgerond, maken we gebruik van een planningsbord in GitHub.\nVoor in ieder geval de eerste drie sprints hebben wij in algemene termen opgeschreven wat er af moet zijn:\nsprint 1: Begin van knikkerbaan moet werken, inclusief een teller en een poortje sprint 2: De knikkerbaan moet nu ook een werkende snelheidsmeter en een wissel hebben sprint 3: Je hebt de knikkerbaan verder uitgebreid en verbeterd. Beoordeling De opdracht wordt op de volgende aspecten beoordeeld, waarbij de vragen niet uitputtend beschreven zijn:\nKnikkerbaan\nHoeveel uitbreidingen zijn er aan de basis toegevoegd? Hoe functioneert de knikkerbaan? Werkt de knikkerbaan soepel? Hoe is de totale afwerking? Hoe is de kwaliteit van de code? Is de code een rommeltje of is het netjes? Hoe objectgeoriënteerd is het geheel van de code? Widget\nHoe ziet de widget eruit? Hoe slag je de ontvangen en verzonden gegevens op? Doet de widget wat het moet doen? Hoeveel interactiviteit met de knikkerbaan wordt hierdoor mogelijk? Doe je iets met de geschiedenis van de ontvangen en verzonden gegevens? Hoe objectgeoriënteerd is het geheel van de code? Is de code netjes? Samenwerking en planning\nHoe was de inzet van de groepsleden. Heeft ieder groepslid evenveel bijgedragen? Heeft iedereen zicht op het hele project, ook als iemand anders daar vooral aan heeft gewerkt? Is er planmatig in sprints gewerkt? Hoe is de verslaglegging van de planning? Er wordt verwacht dat elk teamlid een gelijkwaardige bijdrage levert. Je mag taken verdelen, maar iedereen heeft in ieder geval aan een deel van de code zelf meegeschreven. Aan het einde van de opdracht wordt van alle teamleden verwacht dat zij dezelfde kennis hebben van alle onderdelen van de opdracht. Bij twijfel kan de docent dit toetsen in een kort gesprek met de teamleden en onderzoeken welke commits door teamleden zijn gedaan. Het staat de docent vrij om aan groepsleden verschillende cijfers toe te kennen op basis van hoe en wat zij controleerbaar aan het project hebben bijgedragen.\n","description":"","tags":null,"title":"O5. Marble Mania Knikkerbaan","uri":"/opdrachten/knikkerbaan/"},{"content":"Hier vind je informatie over het robotica programma op het Emmauscollege. Dit programma is ook te volgen voor leerlingen zonder informatica.\nLego (brugklas) Inschrijven: geef je op voor het emc-uur. Tijd: elk emc-blok 1 emc-uur per week, dus ongeveer 6 lessen. Je kunt elk blok starten, of als je het leuk vond opnieuw inschrijven. Lego League (2e klas) Inschrijven: geef je op voor het emc-uur op dinsdag het 8e en 9e lesuur. Tijd: dinsdag het 8e en 9e uur, het hele jaar door dezelfde groep, 1 wedstrijd in Rotterdam op een zaterdag in janauri/februari Lego League (3e klas) Inschrijven: het 2e klas Lego League van vorig jaar kan in overleg met de docent deelnemen. Tijd: dinsdag het 8e en 9e uur, het hele jaar door dezelfde groep, 1 wedstrijd in Rotterdam op een zaterdag in janauri/februari Robot in a Week + Rookie Challenge (3e klas) Inschrijven: schrijf je in via het inschrijfformulier dat wordt verstuurd door de docent. Tijd: 5 dagen in de derde periode, je andere lesssen vervallen dan, je moet die zelfstandig inhalen We beginnen met een bouwcursus op de Hogeschool in Utrecht. We werken op het Emmaus verder aan de robot We sluiten af met deelname aan een wedstrijd (de Rookie Challenge) in Utrecht Rookie Challenge 24/25 Bouwinstructie Robot en regels Rookie Challenge 23/24 Bouwinstructie Robot in a Day 22/23 Lespresentatie 22/23 FTC (4 havo + 4 vwo) Inschrijven: geef je op voor het emc-uur op dinsdag het 8e en 9e lesuur. Tijd: dinsdag het 8e en 9e uur, het hele jaar door dezelfde groep, 5 zaterdagen met wedstrijden (als je een keer niet kunt dan regelen we dat). Je werkt in het robolab op school, je daar in op elk moment dat de school open is. FTC (5 havo + 5 vwo) Inschrijven: het team uit de 4e wordt automatisch ingeschreven voor de 5e klas, tenzij een leerling bij de docent aangeeft te willen stoppen. Als er plaatsen vrijkomen, dan kunnen die in overleg met de docent en het team worden opgevuld door nieuwe leden. Tijd: dinsdag het 8e en 9e uur, het hele jaar door dezelfde groep, 5 zaterdagen met wedstrijden (als je een keer niet kunt dan regelen we dat). Je werkt in het robolab op school, je daar in op elk moment dat de school open is. Profielwerkstuk (5 havo + 5 vwo) Inschrijving en eindpresentatie gaat hetzelfde als voor 6-vwo (eind van het schooljaar voordat je wilt starten met je PWS). Om in te kunnen schrijven moet je informatica in je vakkenpakket hebben en moet je het jaar voor je PWS hebben deelgenomen aan FTC. Beoordelingsmodel Voorbeeld van een profielwerkstuk van team Thunder Wonder (23/24)\nPresentatie Portfolio Engineering Notebook Log Voorbeeld van een profielwerkstuk van team M-Mais (24/25)\nPresentatie Portfolio Engineering Notebook CanSat (6 vwo) Inschrijven: geef je op bij je informatica-docent Tijd: tijdens de informaticalessen en 1 zaterdag. ","description":"","tags":null,"title":"Robotica","uri":"/robotica/"},{"content":"Je leert hoe je heel veel informatie kunt bekijken en bewaren in databases met de programmeertaal SQL.\nHulpmiddelen We gebruiken in deze module de volgende tools:\nKhan Academy Oefeningen Khanacademy, module Intro to SQL\nSQL basics More advanced SQL queries Relational queries in SQL (lang) Modifying databases with SQL Further learning in SQL (overslaan) Ruimtedatabase (alleen vwo)\nOpgaven met antwoorden in Woots Uitlegvideo’s met antwoorden Uitleg Naslagmateriaal Lespresentatie (vwo) Lespresentatie (havo) Syntaxblad SQL (krijg je ook bij de toets) Leerdoelen voor de toets Databases theorie\nJe kunt uitleggen wat een relationele database is. alleen vwo: Je kunt gegevens analyseren en structureren en relaties vastleggen in een multipliciteitsdiagram. alleen vwo: Je kunt gegevens analyseren en structureren en vastleggen in een strokendiagram. Je kunt een database voorzien van een voorbeeldpopulatie (dit betekent dat je gegevens in velden kunt invullen). Je kunt het verschil tussen en 1:n, n:1 en n:m relatie uitleggen en je kunt in een gegeven voorbeeld aangeven van welke relatie sprake is. Je kunt uitleggen wat redundantie is. Je kunt uitleggen wat normaliseren is. Je kunt een gegeven, niet volledig genormaliseerde database omzetten naar een database in de 3e normaalvorm (dit betekent dat je de redundante informatie kunt verwijderen door de database te splitsen in meerdere aan elkaar gerelateerde tabellen). Je kunt voor een gegeven situatie een voorstel te doen voor een genormaliseerde database structuur. Je kunt aangegeven welke (combinaties van) velden uniek zijn / als sleutel kunnen dienen. Je weet waarvoor de primaire sleutel dient. Je weet wat een verwijzende sleutel is. Je weet hoe verwijzingen tussen verschillende tabellen met behulp van sleutels werken. Je weet hoe in een database wordt aangegeven dat een veld geen waarde bevat. Databases programmeren in khan:\nJe kunt met CREATE TABLE een gegevensmodel omzetten in een database. Je kunt met INSERT rijen aan een tabel toevoegen. alleen vwo: Je kunt met DELETE rijen verwijderen uit een tabel. Je kunt met SELECT gegevens uit een relationele database opvragen. Je kunt de opgevraagde gegevens uit een relationele database oplopend en aflopend sorteren. Je kunt voorwaarden stellen aan de op te vragen gegevens uit de database (WHERE) en gebruikmaken van operatoren (=, \u003c, \u003e, \u003e=, \u003c=, \u003c\u003e). Je kunt gebruikmaken van LIKE bij het stellen van voorwaarden in de query. alleen vwo: Je kunt gebruik maken van een subquery in combinatie met de voorwaarde IN. Je kunt gebruikmaken van samengestelde voorwaarden (AND, OR) bij het stellen van voorwaarden in de query. Je kunt gebruikmaken van omgedraaide voorwaarden (NOT) bij het stellen van voorwaarden in de query. Je kunt gebruikmaken van NULL bij het stellen van voorwaarden in de query. Je kunt gebruikmaken van aggregatiefuncties (COUNT, SUM, MAX, MIN, AVG) bij het opstellen van query. Je kunt gebruikmaken van GROUP BY bij het groeperen van de resultaten van een query. Je kunt voorwaarden stellen aan op te vragen gegroepeerde gegevens met HAVING alleen havo: Je kunt bij een query over 2 of 3 tabellen de JOIN toepassen alleen vwo: Je kunt bij een query over 2 of meer tabellen de JOIN toepassen Je kunt een query maken met JOIN van een 1-op-n relatie Je kunt een query maken met JOIN van een n-op-m relatie alleen vwo: Je kent het verschil tussen cross join (JOIN zonder ON), inner join (JOIN ON), left outer join (LEFT JOIN ON) en kunt beslissen welke van deze drie je nodig hebt in een query. Oefentoets Een oefentoets voor deze module staat in Woots .\n","description":"","tags":null,"title":"T5. Databases met SQL","uri":"/theorie/databases/"},{"content":"Chapter 5 Tests Some pages for internal testing of differnt styles\nCode Some testing for different styles used in syntax highlightning and preformatted blocks\nImages Some testing for different styles of image links\nLinks Some testing for different styles of links\n","description":"","tags":null,"title":"Tests","uri":"/tests/"},{"content":"Hier vind je informatie voor leerlingen uit de derde klas (en hun ouders) die misschien het vak informatica willen kiezen.\nInformatica inspireert Een rondleiding door het lokaal Veelgestelde vragen Waarom zou ik informatica kiezen? Informatica is leuk. Je werkt 40% van je lessen aan praktische opdrachten. Bij de praktische opdrachten bepaal jij zelf hoe het eindresultaat eruit ziet. Daarbij heb je veel vrijheid en kun je veel creativiteit kwijt. Het is een nuttig vak. Computers worden in bijna alle beroepen gebruikt, het is dus handig om daar meer van te leren. Bij steeds meer studies krijg je een vakje waarbij je moet programmeren, als je informatica op de havo of het vwo hebt gehad, dan heb je daarbij alvast een kleine voorsprong. Wat is het verschil tussen informatica en IC? IC is het vak informatie en communicatie dat iedereen in de brugklas krijgt. Bij IC leer je vooral hoe je programma’s op een computer kunt gebruiken. Informatica krijg je in de bovenbouw, maar alleen als je het kiest. Bij informatica leer je vooral hoe je zelf programma’s kunt maken voor een computer. Hoe zien de lessen eruit? We hebben theorielessen en praktijklessen.\nTijdens de theorielessen legt de docent vaak wat uit en daarna ga je zelf oefenen. Oefenen doe je meestal door kleine opdrachtjes te maken in een online omgeving. Je programmeert dan een klein dingetje en je ziet gelijk het resultaat. De computer geeft vaak aan of iets goed of fout is. De docent is er om je te helpen als je er niet uitkomt. Tijdens de praktijklessen werk je aan praktische opdrachten. Een opdracht duurt meestal 5 of 10 weken. Goed plannen hoort erbij, maar je krijgt een stappenplan om je daarbij te helpen. Je werkt vaak in kleine groepjes en je hebt veel vrijheid. De docent loopt rond en is er om jullie te helpen. Welke praktische opdrachten gaan we doen? statische website maken 2D game maken webshop maken robot programmeren knikkerbaan maken (alleen vwo) Welke programmeertalen gaan we leren? html/css JavaScript SQL C++ Hoe ziet de lesstof eruit? Op onze website informatica.emmauscollege.nl staat het hele informaticaprogramma dat we geven.\nIs informatica een examenvak? Ja.\nHoe wordt je examencijfer bij informatica bepaald? Bij de meeste vakken is het examencijfer het gemiddelde van een centraal eindexamen en schoolexamens. Het centrale eindexamen is voor alle leerlingen in Nederland hetzelfde en doe je aan het eind van je examenjaar. Schoolexamens verschillen per school. Je doet schoolexamens gespreid over de 4e, 5e en 6e klas. Bij informatica (en wiskunde D) zijn er wel schoolexamens, maar geen centraal eindexamen. Dat betekent dat je het cijfer dat je voor informatica op je diploma krijgt al weet voordat de centrale eindexamens beginnen. Een 7 of hoger voor informatica mag je gebruiken als compensatie, een onvoldoende telt mee voor je tekorten.\nWaar kan ik terecht als ik meer vragen heb? Kom langs bij de informatica-docenten.\nMeneer Cammeraat (afkorting CAM) Meneer Van Geest (afkorting GEE) Meneer Harrewijn (afkorting HAR) Je vindt ons in lokaal B27 en lokaal B42.\n","description":"","tags":null,"title":"Derde klassers","uri":"/derdeklassers/"},{"content":"Je leert hoe je met behulp van toestandsgrammen kunt programmeren. Je gebruikt daarbij het Arduino platform.\nHulpmiddelen We gebruiken in deze module de volgende tools:\nArduino IDE Oefeningen Arduino-lessen.nl, les 1 t/m 5\nKnipperende LED Knipperend LED op breadboard Fadende LED op breadboard met PWM Knippersnelheid regelen met potmeter LED schakelen met drukknop Afstand meten met ultrasoon sensor (geen toetsstof) Zonder arduino-lessen.nl\nGrove I2C LCD met tekst en symbolen, zie uitlegvideo op deze pagina met libary “Grove-LCD RGB Backlight” (geen toetsstof) Passive speaker voor muziek, zie uitleg op https://docs.arduino.cc/built-in-examples/digital/toneMultiple (geen toetsstof) Meer lessen Arduino-lessen (geen toetsstof)\nPresentaties\nLespresentatie toestandsdiagrammen Lespresentatie Arduino basics Uitleg Naslagwerken\nMicrocontroller reader (alleen de paragrafen 1.1, 2.1 t/m 2.9, 3.2, 4.1 t/m 4.3, 5.1 t/m 5.6 en 6.4) Leerdoelen voor de toets Arduino\nJe kunt uitleggen wat een microcontroller is. Je weet wat de setup() en loop() functies in een Arduino sketch zijn. Je weet hoe je digitale en analoge poorten aanstuurt of uitleest Je weet hoe je delay() gebruikt en wat de voor- en nadelen van deze functie zijn. Je begrijpt wat de functie millis() doet. Je kunt de functie millis() gebruiken als vervanging van delay(). Je weet hoe je een PWM signaal kunt creëren Je kunt uitleggen wat een PWM signaal is en kunt daarbij de term duty cycle correct gebruiken en uitleggen Je weet hoe een breadboard werkt Je weet hoe je een variabele weerstand aansluit op een analoge poort van Arduino Je weet hoe je een LED aansluit op een digitale poort van Arduino Je weet hoe je een knop aansluit op een digitale input poort van Arduino Je weet wat het verschil is tussen een sensor en een actuator. Je kunt een aansluitschema maken van een systeem dat beschreven is in een stuk tekst. Het aansluitschema bevat een Arduino, actuatoren en sensoren. Je kent de volgende datatypen: string, int, float, bool Je kunt Arduino code aanpassen om tot een gevraagde oplossing te komen. Je kunt korte programma’s maken die een knipperende LED, gedimde LED, knop en potmeter gebruiken. Je hebt voorkennis van programmeren op het niveau van de vierde klas. Toestandsdiagrammen\nJe kunt aan de hand van een gegeven toestandsdiagram aangeven hoe een systeem zich gedraagt. Je kunt een toestandsdiagram maken van een systeem dat beschreven is in een stuk tekst. Je kunt een toestandsdiagram omzetten in Pseudocode. Je kunt pseudocode omzetten in Arduino-code. Naslagmateriaal Syntaxblad Oefentoets Een oefentoets voor deze module staat in Woots .\n","description":"","tags":null,"title":"T6. Robotica met Arduino","uri":"/theorie/robotica/"},{"content":"Je leert hoe het internet van binnen werkt.\nHulpmiddelen We gebruiken in deze module de volgende tools:\nInformatica Actief Filius Oefeningen Informatica Actief, keuzemodule netwerken, versie netwerken nieuwe stijl\nInformatica Actief, keuzemodule netwerken (1.1, sla 1.2 over) In plaats van Filius te installeren, gebruik je Filius in Gitpod Informatica Actief, keuzemodule netwerken (2.1 t/m 2.17) Informatica Actief, keuzemodule netwerken (3.1 t/m 3.8) Informatica Actief, keuzemodule netwerken (4.1 t/m 4.3) Informatica Actief, keuzemodule netwerken (5.1 t/m 5.5) Uitleg Naslagmateriaal\nNetwerken lespresentatie (Powerpoint presentatie) How the internet works (video’s) Theorie netwerkprotocollen (alleen hoofdtstuk 5, dit is best pittig, aanvulling op uitleg in de les). Leerdoelen voor de toets Netwerken\nJe kunt de belangrijkste reden voor de overgang van IPv4 naar IPv6 uitleggen, ondersteund met een berekening van het aantal beschikbare IP-adressen volgens beide protocollen. Je kunt het verschil tussen een LAN (Local Area Network) en een WAN (Wide Area Network) uitleggen, inclusief kenmerken als bereik, snelheid en gebruikstoepassingen. Je kunt de belangrijkste verschillen benoemen tussen koperen, glasvezel- en draadloze verbindingen, met name over snelheid, kosten en betrouwbaarheid. Je kunt de termen latency, lag, latentie en bandbreedte uitleggen en beschrijven hoe deze factoren de snelheid van een netwerkverbinding beïnvloeden. Je kunt het doel van het OSI-model uitleggen en de functies van de zeven lagen in het OSI-model en de IP-stack beschrijven. Je kunt twee voordelen benoemen van het werken met een lagenmodel, zoals het OSI-model en de IP-stack. Je kunt uitleggen wat een MAC-adres is, de functie van ARP (Address Resolution Protocol), het MAC- en IP-broadcastadres, en beschrijven hoe deze termen en technologieën samenwerken in netwerken. Je kunt uitleggen wat een IP-adres is, de functie van een subnetmasker, de effecten van grote subnetwerken, en berekenen hoeveel apparaten er in een netwerk kunnen worden aangesloten op basis van een subnetmasker. Je kunt het routeringsproces uitleggen, inclusief het gebruik van routeringstabellen, en beschrijven hoe een pakket van het ene naar het andere subnet wordt gestuurd. Je kunt de belangrijkste verschillen tussen TCP en UDP benoemen en uitleggen, en je begrijpt het concept van TCP-poorten en hun functie in netwerkcommunicatie. Je kunt de functies van netwerkapparaten zoals router, modem, switch, wireless access point, repeater en firewall uitleggen, de OSI-laag waarop ze werken benoemen, en deze apparaten herkennen in een netwerkdiagram, waarbij je de IP-adressen en de subnetmaskers correct toewijst. Je kunt de functies van een firewall, DNS (Domain Name System) en DHCP (Dynamic Host Configuration Protocol) uitleggen en beschrijven hoe deze systemen samenwerken in een netwerk. Oefentoets Je kunt een deel van je kennis en vaardigheden testen met de volgende oefenopgaven:\nOefenopgave IP-adressen en subnetten Antwoorden oefenopgave IP-adressen en subnetten ","description":"","tags":null,"title":"T7. Netwerken met IP","uri":"/theorie/netwerken/"},{"content":"Inleiding Om te leren hoe je objectgeoriënteerd programmeert, gaan we stap voor stap een objecgeoriënteerd programma maken. We maken hiervoor een epidemiesimulator die visueel maakt hoe organismen elkaar kunnen besmetten met een ziekteverwekker. Tussen de opdrachten door vind je theorie over objectgeoriënteerd programmeren.\nOpdracht 0 - Klaar voor de start Begrijp de code: Bekijk in je browser wat de simulator nu al doet. De simulator doet nog niet veel: het laat een vierkantje bewegen en stuiteren tegen de randen van het scherm. Bekijk de code van de simulator. In de code zie je globale variabelen die de positie en de horizontale en verticale snelheid bevatten. Ook zie je de constante BREEDTE, die de waarde van de grootte van het vierkantje bevat. var x; var y; var speedX; var speedY; const BREEDTE = 20; In setup krijgen deze variabelen hun initiële waarde. De positie is in het midden van het canvas. (Het midden van het vierkant is overigens niet exact in het midden. De waarden x en y worden gebruikt voor de linkerbovenhoek…) De horizontale en verticale snelheid krijgen bij de start een random waarde tussen -5 en 5.\nx = width / 2; y = heigth / 2; speedX = random(-5, 5); speedY = random(-5, 5); In draw wordt netjes een wit vierkantje getekend met behulp van de waarden van x, y en BREEDTE. Herinner je je nog dat de functie rect een vierkant tekent met de linkerbovenhoek op de meegeven positie?\nrect(x, y, BREEDTE, BREEDTE); Opdracht 1 – 25 random ‘mensen’ maken. En wat doen die katten daar? 😼 In de theorie van hoofdstuk 1 is een heel groot deel van de klasse Mens gegeven. Je maakt deze klasse verder af en gebruikt deze om 25 mensobjecten te maken die zich in onze simulatie bewegen:\nProgrammeren a) 25 random mensen We gaan nu de array mensen vullen met 25 random mens-objecten. Verwijder de code die je bij opdracht 2 in setup hebt gezet om handmatig 5 mens-objecten te maken. Schrijf in plaats daarvan deze code:\n// maak 25 random mensen for (var teller = 0; teller \u003c 25; teller++) { // we moeten ze niet te dicht bij de rand tekenen // om geen problemen met stuiteren te krijgen var ruimteTotRand = 50; // creëer random positie en snelheid var randomX = random(ruimteTotRand, width - ruimteTotRand); var randomY = random(ruimteTotRand, height - ruimteTotRand); var randomSpeedX = random(-5, 5); var randomSpeedY = random(-5, 5); // maak nieuw mensobject var nieuwMens = new Mens(randomX, randomY, randomSpeedX, randomSpeedY); // voeg mensobject toe aan array mensen.push(nieuwMens); } Deze code maakt 25 keer een nieuw mens-object met random waarden aan en voegt deze toe aan de array mensen. Zorg ervoor dat je deze regels begrijpt. Uitleg over push vind je onder andere op de shite van w3schools Bekijk het resultaat. Als het goed is, heb je nu 25 vierkantjes die door elkaar heen vliegen en tegen de randen stuiteren.\nControleer je code b) besmettingen Het wordt tijd dat deze mensen elkaar kunnen besmetten. Het idee is dat mensen elkaar besmetten als ze elkaar in hun beweging overlappen.\nGeef de klasse Mens een nieuw attribuut isBesmet. Dit attribuut initialiseer je in de constructor op false. Je hoeft hiervoor dus geen argument aan je constructor toe te voegen. Hint Bovenin de class Mens, onder speedY, schrijf je isBesmet; In de constructor typ je onder de regel this.speedY = speedY: this.isBesmet = false;\nDaar heb je dus geen extra informatie voor nodig die meegegeven zou moeten worden aan de constructor. Het is gewoon altijd false als een mens-object wordt aangemaakt.\nVoeg in setup, na de for-loop die de 25 mensen aanmaakt, deze regel code toe:\nmensen[0].isBesmet = true; Hierdoor wordt alvast één mens besmet.\nVerander de code in de methode show zo, dat een mens als rood vierkant wordt getekend als deze besmet is. Als het goed is, wordt één vierkant nu rood getekend. Hint Als isBesmet waar is, moet er iets anders getekend worden dan wanneer isBesmet onwaar is. Gebruik hiervoor een if-statement.\nVervolgens maken we een methode die kan controleren of een ander mens-object overlap heeft met het object dat de methode uitvoert. Ga voor jezelf na of je de volgende zin begrijpt: Omdat een mens getekend wordt als een vierkant, overlappen twee mensen elkaar als één van de hoeken van het ene vierkant zich binnen de randen van het andere vierkant bevindt. Onderstaande code bevat het begin van de methode isOverlappend. Voeg deze code toe aan de klasse Mens.\nisOverlappend(andereMens) { // zet teruggeefwaarde standaard op false var overlappend = false; // zet teruggeefwaarde op true als er een overlap is if ( (this.x + this.breedte \u003e= andereMens.x \u0026\u0026 this.x \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y + this.breedte \u003e= andereMens.y \u0026\u0026 this.y \u003c= andereMens.y + andereMens.breedte) ) { overlappend = true; } // stuur de teruggeefwaarde terug return overlappend; } Uitleg Pak een vel papier en teken twee vierkantjes: één voor ’this’, één voor ‘andereMens’. Schrijf bij de randen van de vierkanten welke waarden daarbij horen. De bovenrand van ‘andereMens’ hoort bijvoorbeeld bij andereMens.y.\nAls je dit voor alle 8 zijden hebt gedaan, teken de vierkantjes dan eens zo, dat het vierkant van ’this’ met de linkerbovenhoek in het vierkant van ‘andereMens’ zit. Probeer nu te kijken of je de code in het if-statement hierboven kunt begrijpen.\nNu moeten we in draw code toevoegen die alle mogelijke paren van mensobjecten controleert of ze overlappen. Indien ze overlappen, controleren we of een van die objecten besmet is. Als dat zo is wordt het andere ook besmet (als het dat nog niet is). Een simpele manier om dit te controleren is in een for-loop ieder object te controleren met ieder ander object, behalve zichzelf. Dit ziet er zo uit: // ga alle mensen langs for (var i = 0; i \u003c mensen.length; i++) { var mensA = mensen[i]; // ga met mensA opnieuw alle mensen langs om te checken op overlap, behalve met zichzelf for (var j = 0; j \u003c mensen.length; j++) { var mensB = mensen[j]; if (mensA != mensB) { // check overlap var mensenOverlappen = mensA.isOverlappend(mensB); if (mensenOverlappen) { // check of er een besmetting optreedt if (mensA.isBesmet || mensB.isBesmet) { // als er één besmet is, wordt ze allebei besmet // als ze allebei besmet zijn, verandert deze code niets. mensA.isBesmet = true; mensB.isBesmet = true; } } } } } Ga de code eens regel voor regel af en leg aan jezelf (of je buur) uit wat hier gebeurt.\nControleer je code c) katten… 🐈 Helaas komen de gezondheidsinstanties erachter dat ook katten een rol spelen in de verspreiding van de ziekte. We zullen ook deze moeten opnemen in onze simulatie.\nDe array mensen gaat ook dieren bevatten. Het is raar als deze naam hetzelfde blijft. Alle ‘dingen’ die iets in onze simulatie doen, heten ‘actoren’. Verander door je hele code de naam van de array mensen in actoren. Dat kan in GitPod heel handig: Zoek de regel waar je de mensen als globale variabele declareert. Waarschijnlijk staat er var mensen;. Klik met de rechtermuisknop op mensen en kies in het menu dat verschijnt ‘Rename Symbol’. Wanneer je op deze manier de naam wijzigt, wordt de naam van deze variabele overal gewijzigd. Wel moet je nog even door de comments gaan om te zien of je ook daar misschien ‘mensen’ moet wijzigen in ‘actoren’\nMaak onder de klasse Mens een nieuwe klasse met de naam Kat. Laat deze precies hetzelfde doen als Mens, maar met deze verschillen:\nde breedte van een kat is 10 pixels een niet-besmette kat is blauw in plaats van wit een besmette kat is oranje in plaats van rood Voeg in setup na de 25 mensen ook 10 katten toe aan de simulatie. Geef de katten een random snelheid tussen -2 en 2. Hint Je kunt hiervoor even snel de for-loop die je voor de 25 mensen gebruikt, kopiëren en direct daaronder plakken en aanpassen naar 10 katten.\nControleer je code Opdracht 4 In de theorie van hoofdstuk 2 heb je de gezien hoe de code van de superklasse Actor eruit ziet. Je gaat nu de code van Mens en Kat aanpassen.\nProgrammeren a)\nVoeg, zoals in de theorie voorgedaan, de klasse Dokter toe aan je code en voeg 1 dokterobject toe aan de actoren. Controleer of de dokter verschijnt en anderen geneest. Controleer je code b)\nMaak Mens en Kat subklassen van Actor. Bedenk goed welke code weg mag en welke code veranderd moet worden. Eén methode blijft onveranderd. Weet je welke? Hint De methode show van Actor moet leeg blijven, omdat we Actor abstract maken. Dus de tekencode van show moet in subklassen staan.\nHint Het is raar om in een abstracte klasse als Actor wel een breedte mee te geven. We definiëren breedte daarom wel in Actor, maar geven er geen waarde aan. Dat moet in de constructor van Mens en Kat gebeuren.\nControleer je code c)\nVervolgens gaan we de ‘statistieken’ van onze simulatie laten zien. De verantwoordelijkheid voor deze code ligt niet bij een van de actoren, maar bij het ‘raamwerk’ van de simulatie. Deze code schrijven we daarom in dit geval onder draw. Zorg dat je op die plek met behulp van de p5js-functie text twee regels in de linkerbovenhoek plaatst: een met het aantal onbesmette actoren en een met het aantal besmette actoren. Hint Tip: hiervoor moet je de array actoren doorlopen met een for-loop. Er is overigens al een for-loop die hier prima geschikt voor is.\nHint Je hebt variabelen nodig om de telling tijdelijk in op te slaan. Zou je kieen voor globale of lokale variabelen?\nControleer je code d)\nIedere actor die eenmaal besmet is, wordt in onze simulatie nooit meer beter, tenzij de dokter langskomt. Dat moet veranderen. Actoren moeten ook uit zichzelf weer beter kunnen worden. We gaan daarvoor een teller maken die bij besmetting voor een Mens begint bij 400 en voor een Kat begint op 200. Bij iedere aanroep van de methode update wordt de afteltimer 1 kleiner. Als de afteltimer 0 is, wordt het attribuut isBesmet weer op false gezet. Vraag jezelf hiervoor het volgende af: in welke klasse definieer je besmettelijkheidsTeller? hoe zorg je dat besmettelijkheidsTeller wordt ingesteld wanneer er een besmetting plaatsvindt? Tip: maak een methode besmet() die isBesmet op true zet EN de besmettelijkheidsTeller instelt. hoe maak je het verschil in gedrag tussen Mens en Kat? Als je het in kleine stapjes wilt doen: Maak het eerst werkend voor één klasse. Maak het daarna werkend voor de andere klasse. Verplaats waar mogelijk dubbele code naar Actor. wat gebeurt er met de besmettelijkheidsTeller als update wordt aangeroepen en de actor is niet besmet? wat gebeurt er met de besmettelijkheidsTeller als deze aan het aflopen is en er opnieuw contact is met een andere, besmette, actor? Controleer je code Speel gerust eens met de waarden van de besmettelijkheidsTeller of het aantal dokters om te zien wat er in je simulatie gebeurt.\nopdracht 5 Programmeren In de theorie van hoofdstuk 3 is een heel aantal veranderingen genoemd. Verander je code zo, dat de genoemde attributen private worden en ze de juiste getters en setters hebben. Alle code staat nog in één bestand: script.js. Dit is niet handig als je code gemakkelijk herbruikbaar wilt maken. Daarom doen we het volgende: we maken voor iedere klasse een apart bestand aan, zoals actor.js, mens.js etc. je javascript wordt uitgevoerd binnen de HTML-pagina index.html. Het JavaScript-bestand wordt hierin netjes geladen. Nu we de code hebben verdeeld over meerdere bestanden, moeten we ook aangeven dat deze worden geladen. Voeg boven de regel: \u003cscript id=\"canvas\" src=\"script.js\"\u003e\u003c/script\u003e voor ieder bestand nieuwe regel toe zoals: \u003cscript src=\"actor.js\"\u003e\u003c/script\u003e Maak zelf een heel nieuwe actor voor de simulatie. Je mag zelf weten of het een directe subklasse van Actor, Mens, Kat of Dokter is, zolang je maar geen code in (één van de) superklassen gaat veranderen om jouw nieuwe klasse te laten werken. Zet deze code in een los bestand. Maak een volledig UML klassendiagram van de vijf klassen die in jouw simulatie voorkomen. Wissel met een klasgenoot jullie zelfbedachte actorklassen uit en neem deze op in je eigen simulatie. Als het goed is, heb je niet veel code nodig om dit voor elkaar te krijgen. Hint Wissel uit door:\nde bijbehorende bestanden elkaar te sturen. in je HTML bestand ook dit nieuwe bestand te laden. in je setup een zelfbedacht aantal van deze nieuwe klasse actoren op te nemen. ","description":"","tags":null,"title":"T8 Epidemiesimulatoropdracht","uri":"/theorie/objectoriented_simulator_opdracht/"},{"content":"Introductie In de vierde klas heb je in JavaScript met behulp van de library p5.js een spelletje gemaakt. Later leerde je de taal C++ om daarmee een microcontroller te programmeren. JavaScript en C++ zijn verschillende programmeertalen, toch lijken ze ook wat op elkaar: het programma dat je in deze talen maakt wordt stap voor stap uitgevoerd, commando na commando. Na ieder commando is de toestand waarin je programma zich bevindt weer een beetje anders.\nDeze manier van programmeren heet imperatief programmeren. Een andere manier van programmeren is bijvoorbeeld declaratief programmeren . Zo’n manier van programmeren heet een programmeerparadigma. Vanuit imperatief programmeren is in de loop der tijd een aparte paradigma onstaan: objectgeoriënteerd programmeren. De Engelse term hiervoor is object oriented programming, ofwel OOP. Heel veel programma’s zijn gemaakt met behulp van dit paradigma. Zonder dat je het misschien hebt doorgehad, heb bij bij het werken met Arduino ook gebruik gemaakt van objectgeoriënteerd programmeren. In deze module gaan we leren dit paradigma bewust toe te passen.\nHoofdstuk 1 – objecten, attributen, methoden, this, klassen Attributen In de vierde klas heb je geleerd hoe je variabelen gebruikt in je programma. Je kunt in JavaScript een variabele creëren met var of let, zoals var xPositie = 10. Ook leerde je dat er arrays bestaan. Hiermee kun je een lijstje van waarden maken. Je hebt hiervoor een variable nodig en een index, zoals xPosities[2]. In de opfrisopdracht moest je een spelletje programmeren waarbij ‘appels’ naar beneden vielen. Zo’n appel heeft een x-positie, y-positie en een verticale snelheid. Je kunt hiervoor prima de volgende variabelen gebruiken (de waarden zijn willekeurig gekozen):\nvar x = 300; var y = -50; var speed = 4; Wanneer je meer dan één appeltje tegelijkertijd in het spel wilt hebben, kun je het beter gebruik maken van arrays (de waarden zijn opnieuw willekeurig gekozen):\nvar xPosities = [300, 500]; var yPosities = [-50, -150]; var speeds = [4, 2]; Je kunt vervolgens een loop gebruiken om alle elementen (of waarden) van de arrays te doorlopen:\n// updatet yPosities met de bijbehorende speed: for (var i=0; i\u003cyPosities.length; i++) { yPosities[i] = yPosities[i] + speeds[i]; } In bovenstaande arrays staan twee appels beschreven: één met een x-waarde van 300, een y-waarde van -50 en een speed van 4 en één met een x-waarde van 500, een y-waarde van -150 en een speed van 2. Het is het een beetje vreemd dat we waarden die eigenlijk bij elkaar horen (omdat ze bij dezelfde appel horen), opsplitsen in arrays die dezelfde soort informatie bevatten (namelijk, allemaal x- of y-waarden).\nGelukkig heeft JavaScript hier iets voor: objecten. Je kunt op deze manier een object maken:\nvar appel = { x: 300, y: -50, speed: 4 }; De eigenschappen x, y en speed, noemen we attributen van het object appel. Wanneer je nu het x-attribuut van appel wilt lezen of veranderen, maak je gebruik van puntnotatie: appel.x. Bijvoorbeeld, om de waarde van het x-attribuut te printen in de JavaScript console: console.log(apple.x). Of om de waarde van attribuut y te veranderen met de hoeveelheid die in speed staat: appel.y = appel.y + appel.speed.\nHet is ook mogelijk om objecten in een array te zetten:\nvar appels = { x: 300, // dit is het eerste appel-object y: -50, speed: 4 }, { x: 500, // dit is het tweede appel-object y: -150, speed: 2 }; Methoden De laatste regel code zul je in array-vorm vast ook in je simulatie-opdracht hebben staan. We hebben nu dus objecten die gegevens die bij elkaar hoort netjes in bij elkaar hebben staan. Maar hoort programmeercode die de positie van het object op basis van de snelheid aanpast eigenlijk ook niet bij datzelfde object? Dat klopt. En daarom is het ook mogelijk om een object acties / handelingen te laten uitvoeren. Je zou je het kunnen voorstellen als een functie die bij een bepaald object hoort. In objectgeoriënteerd programmeren heet zo’n ‘functie van een object’ een methode.\nAls het appel-object ook een methode update moet hebben die de y-positie van de appel updatet, moeten we de code herschrijven:\nvar appel = { x: 300, y: -50, speed: 4, update() { this.y = this.y - this.speed; } } Als we vervolgens appel.update() aanroepen, wordt de methode uitgevoerd.\nthis Maar wat doet het keyword this in de code van update? Je zou je het als volgt kunnen voorstellen: de code binnen update heeft ‘geen idee’ dat dat object uiteindelijk via de naam appel toegankelijk is. Die naam appel is als het ware onzichtbaar voor de code binnen het object. Toch wil je in de code van methode vaak een attribuut of methode van datzelfde object aanroepen. Daarvoor gebruikt je this. De code this.x = 90 betekent zoveel als: geef het attrituut x van mijzelf de waarde 90.\nKlassen Stel dat we meerdere appel-objecten met dezelfde eigenschappen en functionaliteit willen maken. We zouden hiervoor deze code kunnen gebruiken:\nvar appelA = { x: 300, y: -50, speed: 4, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } var appelB = { x: 500, y: -150, speed: 2, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } var appelC = { x: 200, y: -350, speed: 3, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } Als het goed is, krijg je als programmeur jeuk van deze code. De code voor de methode update is drie keer precies hetzelfde! Dit moet toch beter kunnen? En kunnen we er wel vanuit gaan dat appelA, appelB en appelC wel dezelfde attributen en methoden hebben? Het is handig dat ze bijna dezelfde namen hebben, maar zijn ze wel vergelijkbaar?\nOm deze twee problemen op te lossen, maken programmeurs gebruik van klassen. Een klasse is een soort blauwdruk van een groep objecten. We kunnen bijvoorbeeld een klasse Appel maken. Ieder appel-object heeft dan gegarandeert beschikking over alle attributen en methodes die in de klasse beschreven zijn.\nEen klasse Appel zou er in JavaScript zo uit kunnen zien:\nclass Appel { x; y; speed; constructor(x, y, speed) { this.x = x; this.y = y; this.speed = speed; } update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } Uitleg\nDe eerste 4 regels van de klasse Appel geven aan welke attributen deze klasse heeft. De eerste methode is de zogenaamde constructor. Dit is een speciale methode die als doel heeft een object te creëren van deze klasse. De code in een constructor doet alles wat hiervoor nodig is. Omdat een appel in onze simulatie minimaal de eigenschappen x, y en speed moet hebben, is het het beste om deze drie waarden direct aan de constructor mee te geven. Zo krijg je altijd een object dat gelijk functioneel is.\nDe argumenten van de constructor heten hetzelfde als de attributen van de klasse. Dat is niet verplicht. Je zou de parameter x ook newX (of – doe eens gek – a) mogen noemen. Merk wel op dat in de constructor x slaat op de eerste parameter van de constructor en this.x op het attribuut x van de klasse. Deze constructorcode doet precies hetzelfde als de constructorcode hierboven, maar is veel slechter te begrijpen:\nconstructor(a, b, c) { this.x = a; this.y = b; this.speed = c; } De code van update herken je zo langzamerhand wel. Valt je op dat de code in een klasse zo algemeen mogelijk is? Het is zo geschreven dat het werkt voor waarden die je nu nog niet weet, maar er wel zijn als van deze klasse een object gemaakt wordt. Wanneer je een nieuw object van de klasse Appel wilt maken gebruik je het keyword new. Wanneer je new gebruikt, wordt automatisch de constructor aangeroepen. Voorbeeld: var appel = new Appel(300, -50, 4); Termen en afspraken Een klasse is een blauwdruk voor een bepaald object. Objecten van dezelfde klasse hebben dezelfde attributen en methoden. De waarden die in de attributen zijn opgeslagen, zijn mogelijk wel voor ieder object verschillend. Als object appelA een object van de klasse Appel is, zeggen we ook wel dat appelA een instantie (Engels: instance) is van de klasse Appel. Een nieuw object maken heet ook wel ‘instantiëren’ Afspraken over de schrijfwijze: de naam van een klasse begint altijd met een hoofdletter. De naam van een object begint altijd met een kleine letter. Voor beide gebruik je Camelcase . Hoofdstuk 2 – Overerving, super, polymorfie en abstracte klassen Een programmeur die objectgeoriënteerd programmeert, komt vroeg of laat tot de ontdekking dat er twee klassen zijn, die heel erg op elkaar lijken, zoals een appel (+1 punt) en een rotte appel (-1 punt) in ons ‘spelletje’. Beide spel-elementen hebben een positie, punten en een snelheid. Ook hebben ze allebei een constructor, een methode om de y-positie te updaten en één om zichzelf te tekenen. Als programmeur krijg je de rillingen van dubbele code, dus hier moet toch wel een oplossing voor zijn?\nDat klopt! Deze oplossing heet overerving. Wat houdt overerving in? Overerving houdt in dat je kunt aangeven dat de ene klasse alle attributen en methoden van een andere klasse erft, overneemt. Alsof je alle code kopieert en plakt. Op basis van die geërfde attributen en methoden kun je dan je klasse verder specificeren. De klasse die de attributen en methodes doorgeeft heet de superklasse. De klasse die ze erft, heet de subklasse.\nLaten we eens kijken naar de code van Appel en RotteAppel:\nclass Appel { x; y; speed; points; constructor(x, y, speed) { this.x = x; this.y = y; this.speed = speed; this.points = 1 } // werk de y-positie bij update() { this.y = this.y + this.speed; } // teken een appel als rood vierkant show() { noStroke(); fill(\"red\"); rect(this.x, this.y, 20, 20); } } class RotteAppel { x; y; speed; points; constructor(x, y, speed) { this.x = x; this.y = y; this.speed = speed; this.points = -1 } // werk de y-positie bij update() { this.y = this.y + this.speed; } // teken een rotte appel als bruin vierkant show() { noStroke(); fill(\"red\"); rect(this.x, this.y, 20, 20); } } Welke onderdelen hebben Appel en RotteAppel gemeenschappelijk?\nDe constructors hebben beide code die x, y, speed van waarden voorziet. Het aantal punten verschilt. De methode update is voor beide klassen gelijk. De methode show verschilt. Je zou RotteAppel als een ‘speciaal soort Appel’ kunnen zien. Als een class die alles heeft / kan wat Appel ook heeft, maar een beetje extra / anders is. Je kunt daarom RotteAppel alle eigenschappen van Appel geven, en alleen veranderen wat er nodig is:\nclass RotteAppel extends Appel { constructor(x, y, speed) { super(x, y, speed); this.points = -1; } // teken een rotte appel als gewone appel met een bruine plek show() { super.show(); fill(\"brown\"); ellipse(this.x+10, this.y+10, 10, 10); } } Je ziet dat je met behulp van het keyword extends kunt aangeven wat de superclass is. De class erft alle attributen en methoden van de superclass. Die superclass kan overigens zelf ook weer een superclass hebben.\nDe class RotteAppel heeft geen eigen implementatie van de methode update. Als je update van een RotteAppel-object aanroept, wordt de methode update van de superclass gebruikt.\nRotteAppel heeft wel een eigen implementatie van de methode show. Een rotte appel wordt getekend als een rood vierkant met een bruine plek. Het tekenen van een rood vierkant hebben we echter al in de class Appel beschreven. Zonde om opnieuw te doen! De regel super.show() betekent: voer de methode show uit van de superclass, dus zoals die beschreven staat in Appel. Als dat is gebeurd, voer dan nog wat extra tekencode uit.\nHetzelfde zien we bij de constructor. Een constructor van een subclass roept eerst de constructor van de superclass aan: super(x, y, speed). Daarna komt constructorcode die specifiek voor deze subclass is.\nLET OP: het lijkt nu misschien alsof je iedere methode van een subclass moet beginnen met het aanroepen van diezelfde methode van de superclass. Het gebeurt inderdaad vaak, maar bedenk per geval of het echt nodig is.\nAbstracte klassen Zie onderstaande code voor het mandje waarmee je de appels op kunt vangen:\nclass Mand { x; y; constructor(x, y) { this.x = x; this.y = y; } // teken een mand als bruine rechthoek show() { noStroke(); fill(\"brown\"); rect(this.x, this.y, 150, 40); } // voor het gemak is code voor het bewegen van het mandje hier weggelaten } Je ziet dat Mand net zoals Appel de attributen x en y heeft, en ook een methode show(). Je kunt er ook hierbij voor kiezen om een Mand en Appel een gezamenlijke superklasse te geven. Deze superklasse is geen ‘ding’ meer in je spel, maar alleen bedoeld om gedeelde code maar op één plek te beschrijven. Zo’n klasse die niet bedoeld is om direct objecten van te maken, noem je een abstracte klasse. In het geval van Appel en Mand zou je dat zo kunnen doen:\nclass SpelElement { x; y; constructor(x, y) { this.x = x; this.y = y; } show() {} } class Mand extends SpelElement { constructor(x, y) { super(x,y); } // teken een mand als bruine rechthoek show() { noStroke(); fill(\"brown\"); rect(this.x, this.y, 150, 40); } // voor het gemak is code voor het bewegen van het mandje hier weggelaten } class Appel extends SpelElement { speed; points; constructor(x, y, speed) { super(x, y); this.speed = speed; this.points = 1 } // werk de y-positie bij update() { this.y = this.y + this.speed; } // teken een appel als rood vierkant show() { noStroke(); fill(\"red\"); rect(this.x, this.y, 20, 20); } } Je ziet dat in de klasse SpelElement de methode show() wel is aangemaakt, maar geen code bevat. Op deze manier weet je zeker dat je op iedere subklasse van SpelElement de methode show() kunt aanroepen zonder foutmelding te krijgen. We laten het aan de subklasses om show() te overschrijven en daadwerkelijk iets te tekenen.\nNogmaals: in het spel zul je nooit objecten rechtstreeks van SpelElement maken. Dat gaat altijd via Appel of Mand of RotteAppel.\nIn het vervolg maken we voor het gemak even geen gebruik meer van de superklasse SpelElement.\nHoofdstuk 3 - Privé attributen, getters en setters, inkapseling, klasse variabelen Je hebt nu een aantal klassen om een grappige spelletje mee te kunnen maken. Zo’n spelletje kun je prima alleen maken. Maar heel veel software wordt gemaakt door meerdere mensen. Tegelijkertijd werken mensen aan hetzelfde project. Maar ook over de tijd gaan verschillende mensen bezig met hetzelfde stukje software.\nJe zou je kunnen voorstellen dat een andere programmeur (collega?) een half jaar later jouw game verder uitbouwt. Het zou kunnen dat die collega niet goed doorheeft dat de punten van een Appel-object niet veranderd mogen worden. Maar op dit moment houdt niets hem / haar tegen om dit te doen bij een Appel-object met de naam appeltje:\nappeltje.points = 10; Je zou hiervoor het attribuut points een beetje willen afschermen. Niet alles mag hier zomaar mee gedaan worden. Maar het uitlezen moet echter wel mogelijk zijn.\nOp dezelfde manier kun je ook van x, y kunnen zeggen dat deze niet van buitenaf veranderd zouden moeten kunnen worden. De positie wordt helemaal autonoom door de klassen geregeld. En laten we speed dan ook maar helemaal voor rare programmeurs beschermen. We willen gewoonweg niet dat dit zomaar wordt aangepast. Als dit wordt aangepast, dan op onze voorwaarden. Je zou er toch niet aan moeten denken dat een juniorprogrammeur met een negatief getal voor x een appel links buiten het scherm plaatst 😱.\nHet afschermen van attributen kun je doen door een attribuut private te maken. Een attribuut waarvoor dat niet geldt, heet public. Hoe je precies een attribuut publiek of privé maakt, verschilt nogal per objectgeoriënteerde taal. Wel heeft bijna iedere objectgeoriënteerde taal hier mogelijkheden voor. In JavaScript werkt het niet het meest fraai van alle programmeertalen, maar het is wel heel duidelijk: een privéattribuut begin met een #. Dus wil je points private maken, dan verander je door je hele code dit attribuut in #points.\nNu hebben we points mooi afgeschermd van onverantwoorde veranderingen, we hebben dit attribuut nu ook afgeschermd van uitlezen… Dat was niet de bedoeling want nu kunnen we onze statistieken niet meer maken. Om dat op te lossen maken we een nieuwe methode in Appel:\ngetPoints() { return this.#points; } Omdat deze code binnen de klasse Appel staat, heeft deze wel toegang tot points en dan deze zo teruggegeven worden. Wil je van appeltje de waarde van points weten? Dan gebruik je appeltje.getPoints(). Een methode die de waarde van een attribuut teruggeeft, heet een getter. Dezelfde manier kun je nu gebruiken om van x, y en speed een attribuut te maken dat read-only is:\nclass Appel { #x; #y; #speed; #points; constructor(x, y, speed) { this.#x = x; this.#y = y; this.#speed = speed; this.#points = 1 } // werk de y-positie bij update() { this.#y = this.#y + this.#speed; } // teken een appel als rood vierkant show() { noStroke(); fill(\"red\"); rect(this.#x, this.#y, 20, 20); } // getters voor x, y, speed en points getX() { return this.#x; } getY() { return this.#y; } getSpeed() { return this.#speed; } getPoints() { return this.#points; } } Het zou kunnen dat je wilt dat je de speed van een appel toch van buitenaf moet kunnen aanpassen, maar dat je wilt voorkomen dat iemand de speed een negatieve waarde geeft (dan zou dat Appel-object omhoog gaan). Je legt het schrijven van speed dus beperkingen op. Wanneer de gewenste nieuwe snelheid groter of gelijk is aan 0, dan wordt dat de nieuwe snelheid van het Appel-object. Maar als de gewenste snelheid negatief is, dan moet de nieuwe snelheid 0 worden. In code doe je dat met een nieuwe methode:\n// setter voor speed setSpeed(speed) { if (speed \u003e= 0) { this.#speed = speed; } else { this.#speed = 0; } } Je zult nu ook de code in de constructor moeten vervangen om te voorkomen dat je bij het aanmaken van een nieuw Appel-object nog wel een negatieve snelheid kunt meegeven:\nconstructor(x, y, speed) { this.#x = x; this.#y = y; this.setSpeed(speed); this.#points = 1 } Een methode die schrijftoegang tot een attribuut regelt, heet een setter. De werkwijze waarbij je toegang tot de gegevens van een object beperkt en de toegang principieel bij het object zelf legt, heet inkapseling (Engels: encapsulation). Deze techniek is erg belangrijk bij objectgeoriënteerd programmeren voorkomt allerlei ongewenst gebruik van klassen.\nWanneer je in een superclass attributen private maakt, dan betekent dat ook dat een subclass alleen via getters en setters toegang heeft tot die attributen. Het uitlezen van x en y en het instellen van de punten in de klasse RotteAppel op onderstaande manier gaat dus problemen geven:\nclass RotteAppel extends Appel { constructor(x, y, speed) { super(x, y, speed); this.#points = -1; // --\u003e DIT WERKT NU NIET MEER } // teken een rotte appel als gewone appel met een bruine plek show() { super.show(); fill(\"brown\"); ellipse(this.#x+10, this.#y+10, 10, 10); // --\u003e DIT WERKT NU NIET MEER } } Het uitlezen van x en y kunnen we gemakkelijk via de getter doen, dus zo:\nellipse(this.getX()+10, this.getY()+10, 10, 10); Het instellen van de negatieve punten voor een RotteAppel kunnen we op verschillende manieren oplossen:\nje kunt een setter maken voor points, zodat je de punten zo kunen instellen: this.setPoints(-1);. Maar dat betekent ook dat iedereen op ieder willekeurig moment de punten van een Appel- of RotteAppel-object kan veranderen. En dat wilden we juist niet. je kunt ook de constructor aanpassen, zodat je daar ook de punten aan mee moet geven. Wat ook mogelijk is (maar zoek zelf na hoe dat moet als je dat interessant vindt) is dat je de punten als laatste argument van de constructor definieert. Je kunt deze dan evt. weglaten bij het aanmaken van een object (m.b.v. new) en in dat geval een standaard waarde geven (zoals 1 of -1). In de RotteAppelclass geef je dan wel de specifieke waarde mee aan de superconstructor: super(x, y, speed, -1) Ook dit is niet de oplossing die alles perfect dichttimmert. JavaScript biedt hiervoor helaas niet de mogelijkheden die je nodig hebt. Veel andere objectgeoriënteerde programeertalen bieden mogelijkheid wel. Je hebt dan bijvoorbeeld attributen die naast public, private ook protected kunnen zijn. Een protected attribuut is niet benaderbaar door code buitende klasse, (net zoals bij private), maar wel door code van subklasses van de klasse die eigenaar is van het attribuut.\nHoofdstuk 4 - C++, polymorfie, voordelen en nadelen Je hebt nu op een redelijk niveau objectgeoriënteerd leren programmeren in JavaScript. Zoals eerder gezegd heb je, misschien zonder dat je het wist, ook al in C++ object georiënteerd geprogrammeerd. Neem bijvoorbeeld het gebruik van de Seriële Communicatie tussen je Arduino en de computer. Een heel simpel Arduinoprogramma dat elke seconde een berichtje stuurt, ziet er zo uit:\nvoid setup() { Serial.begin(9600); } void loop() { Serial.println(\"Dit is een bericht\"); delay(1000); } Serial is een object dat de Arduinosoftware aanmaakt om ons, eenvoudige programmeurs, toegang te geven tot seriële communicatie. Dit object heeft onder andere de methodes begin en println. (Hoewel Arduino zelf de naam van enkele objecten met een hoofdletter begint, houden wij ons aan de afspraak dat klassennamen met een hoofdletter beginnen en objectnamen met een kleine letter.)\nEn als je al eens een servomotor hebt aangestuurd, herken je hieronder ook objectgeoriënteerde code:\n#include \u003cServo.h\u003e Servo mijnServo; void setup() { mijnServo.attach(9); } void loop() { mijnServo.write(0); delay(500); mijnServo.write(180); delay(500); } Nu je weet hoe je klassen en objecten in JavaScript maakt, is het gemakkelijk om te leren hoe dit in C++ werkt. Hierbij maken we één belangrijke versimpeling, wanneer je klassen in losse bestanden aanlevert, moet dit verdeeld worden in twee bestanden. Eén bestand is de header file, eindigend op .h, die beschrijft welke attributen en methodes de klasse heeft en of het een superklasse heeft. Het andere bestand, eindigend op .cpp, bevat de programmeercode. Wij stoppen de code van een klasse echter voor het gemak in één bestand.\n#include \u003cArduino.h\u003e class Stoplicht { private: int toestand; int pinRood; int pinOranje; int pinGroen; void update() { if (this-\u003etoestand == this-\u003eROOD) { digitalWrite(this-\u003epinRood, HIGH); } else { digitalWrite(this-\u003epinRood, LOW); } // je kunt het ook korter schrijven: digitalWrite(this-\u003epinOranje, this-\u003etoestand == this-\u003eORANJE); digitalWrite(this-\u003epinGroen, this-\u003etoestand == this-\u003eGROEN); } public: // constante klasse attributen static const int GROEN = 0; static const int ORANJE = 1; static const int ROOD = 2; Stoplicht(int newPinRood, int newPinOranje, int newPinGroen) { // neem de opgegeven pinNummers over this-\u003epinRood = newPinRood; this-\u003epinOranje = newPinOranje; this-\u003epinGroen = newPinGroen; // maak van de pinnen OUTPUTs pinMode(this-\u003epinRood, OUTPUT); pinMode(this-\u003epinOranje, OUTPUT); pinMode(this-\u003epinGroen, OUTPUT); this-\u003etoestand = GROEN; } void rood() { this-\u003etoestand = ROOD; } void oranje() { this-\u003etoestand = ORANJE; } void groen() { this-\u003etoestand = GROEN; } int getToestand() { return this-\u003etoestand; } }; Je hebt gezien dat C++ ook gebruik maakt van de . om attributen en methodes van objecten aan te spreken. Bij this wordt echter -\u003e gebruik. Het voert te ver om precies uit te leggen waarom dit is. Het gebruik van this is in C++ echter niet verplicht. Je zult daarom ook vaker code tegenkomen zoals hieronder, waarbij de gewoonte is dat men private attributen laat beginnen met een _:\n#include \u003cArduino.h\u003e class Stoplicht { private: int _toestand; int _pinRood; int _pinOranje; int _pinGroen; void update() { if (_toestand == ROOD) { digitalWrite(_pinRood, HIGH); } else { digitalWrite(_pinRood, LOW); } // je kunt het ook korter schrijven: digitalWrite(_pinOranje, _toestand == ORANJE); digitalWrite(_pinGroen, _toestand == GROEN); } public: // constante klasse attributen static const int GROEN = 0; static const int ORANJE = 1; static const int ROOD = 2; Stoplicht(int newPinRood, int newPinOranje, int newPinGroen) { // neem de opgegeven pinNummers over _pinRood = newPinRood; _pinOranje = newPinOranje; _pinGroen = newPinGroen; // maak van de pinnen OUTPUTs pinMode(_pinRood, OUTPUT); pinMode(_pinOranje, OUTPUT); pinMode(_pinGroen, OUTPUT); _toestand = GROEN; } void rood() { _toestand = ROOD; update(); } void oranje() { _toestand = ORANJE; update(); } void groen() { _toestand = GROEN; update(); } int getToestand() { return _toestand; } }; Je mag zelf kiezen welke stijl je het meest aanspreekt, als je maar consistent bent.\nHet aanmaken van een stoplichtobject gebeurt als volgt:\nStoplicht lichtA(9, 10, 11);\nDeze regel code roept de constructor van de klasse Stoplicht aan met 9, 10 en 11 als waarden voor de pinnen van resp. het rode, oranje en groene licht.\nEen aantal zaken valt op:\nDe toegang wordt geregeld met de gedeelten public en private. Niet alleen attributen, maar ook methoden kunnen private zijn. De enige publieke methoden zijn rood, oranje en groen en de getter van _toestand. De methode update is private. Het aanpassen van de status van de pinnen wordt gedaan naar aanleiding van het aanroepen van rood, oranje of groen, maar hoeft niet door ’een ander’ te gebeuren. De constructor draagt de naam van de klasse. C++ is een sterk getypeerde (Engels: strongly typed) taal, dus attributen hebben een type en de methoden hebben een teruggeefwaarde (behalve de constructor) De ; na de klasse declaratie is noodzakelijk. Subclassing in C++ gaat (in eenvoudige vorm) vrijwel hetzelfde als in JavaScript:\nclass Lamp { private: bool _pin bool _isAan; public: Lamp(int newPin) { _isAan = false; pinMode(_pin, OUTPUT); } void zetAan() { _isAan = true; } void zetUit() { _isAan = false; } // voer in elke loop deze methode uit void update() { digitalWrite(_pin, _isAan); } }; class KnipperLamp : public Lamp { private: int _wachtTijd; unsigned long _veranderTimer; public: KnipperLamp(int newPin, int newWachtTijd) : Lamp(newPin) { _wachtTijd = newWachtTijd; _veranderTimer = millis() + _wachtTijd; } void update() { if (millis() \u003e _veranderTimer) { _isAan = !_isAan; _veranderTimer = millis() + _wachtTijd; } Lamp :: update(); } int getWachtTijd() { return _wachtTijd; } } Polymorfisme Stel, we hebben een aantal lampobjecten en knipperlampobjecten waarop we met behulp van een for-loop update willen aanroepen. De inhoud van een array moet in C++ van hetzelfde soort zijn, dus alleen ints, floats, of objecten van dezelfde klasse. Moeten we voor lampen en knipperlampen dan misschien twee afzonderlijke arrays maken? Nee, dat is niet noodzakelijk. Omdat Knipperlamp een subklasse is van Lamp, voldoet deze daarmee ook aan alle eigenschappen van Lamp. De volgende code is dus geldig:\n// een array met zowel lamp- als knipperlampobjecten Lamp lampen[] = { Lamp(3), KnipperLamp(9, 500), Lamp(5) } void setup() { lampen[0].zetAan(); lampen[1].zetAan(); // de laatste lamp laten we uit } void loop() { for (int i = 0; i \u003c lampen.length(); i++\u003e) { Lamp l = lampen[i]; l.update(); } } Laten we stap voor stap de for-loop hierboven doorlopen: We weten zeker dat er objecten in de array lampen objecten zitten die Lamp als klasse of superklasse hebben. We kunnen kunnen er dus vanuit gaan dat deze objecten de objecten en methoden hebben zoals die in Lamp staan.\ni = 0 l wordt behandeld als lampobject en is dat ook (het eerste element van de array lampen). De aanroep l.update() laat de methode update van de klasse Lamp uitvoeren.\ni = 1 l wordt behandeld als lampobject, maar is eigenlijk een knipperlampobject (het tweede element van de array lampen). De aanroep van l.update() laat de methode update van de klasse KnipperLamp uitvoeren.\ni = 2 Gaat net zoals bij i=0, maar dan voor het laatste object van lampen.\nDe aanroep van update kan, omdat we zeker weten dat de objecten in de array lampen die methode hebben. Omdat één van die objecten echter een subklasse van Lamp is, (namelijk KnipperLamp) die een eigen implementatie van update heeft, wordt in dat geval die code uitgevoerd. In principe hoeven we hier echter helemaal geen rekening mee te houden. In de for-loop mag je uitgaan van lamp-objecten.\nWanneer een object / functie / methode in verschillende scenario’s zich anders gedraagt, spreken we in de informatica van polymorfisme. Je komt dit ook op andere manieren tegen. De operator + kan in C++ zowel gebruikt worden om integers bij elkaar op te tellen, maar ook om strings aan elkaar vast te plakken.\nVoor- en nadelen van objectgeoriënteerd programmeren Objectgeoriënteerd programmeren is al tientallen jaren een populaire programmeerparadigma. Dit komt omdat deze manier van programmeren een aantal voordelen heeft die het erg aantrekkelijk maken.\nVoordelen Modulariteit Objectgeoriënteerd programmeren vereist dat een programma in modules wordt opgebouwd. Dit al handig bij kleine programma’s, maar werkt geweldig bij grote systemen die door hun omvang door uit verschillende deelsystemen bestaat die elk door andere personen of teams worden ontwikkeld. Bij objectgeoriënteerd programmeren kun je, als eenmaal is vastgelegd welke methode een klasse heeft, deze onafhankelijk van andere klassen implementeren.\nInkapseling In eerdere vormen van programmeren was het deels mogelijk om een programma in modules te ontwikkelen, maar data was dan gemakkelijk toegankelijk voor allerlei delen van de programmacode, ook delen die de data niet zouden mogen veranderen.\nDoor inkapseling van gegevens binnen klasse is het gemakkelijker om deze gegevens te ‘beschermen’. Ze zijn ontoegankelijk voor andere stukken programmeercode en daardoor is het gemakkelijker om regels over de data (zoals dat een waarde nooit kleiner mag zijn van 0) af te dwingen.\nFlexibel hergebruik Het is met behulp van objectgeoriënteerd programmeren erg gemakkelijk om code opnieuw te gebruiken in een andere context. Het principe van overerving speelt hierbij een belangrijke rol. Algemene eigenschappen van een klasse definieer je in een superklasse, specifieke eigenschappen in een subklasse. De subklassen gebruik je dan op verschillende plekken in je programma, of zelfs over meerdere programma’s. Hierdoor hoef je de algemene code maar één keer te schrijven en hergebruik je deze code dus telkens als je een subklasse gebruikt.\nNadelen Objectgeoriënteerd programmeren heeft echter ook een aantal nadelen. Of, beter gezegd: Er is ook wel wat af te dingen van dit mooie programmeerparadigma:\nObjectgeoriënteerd programmeren is moeilijk en kost veel tijd om een goed objectgeoriënteerd ontwerp te maken Het uitvoeren van een objectgeoriënteerd programma kost meer computerkracht en -geheugen dan de oudere manieren van programmeren. Er is sprake van meer overhead. Andere vormen van programmeren (zoals procedureel, functioneel of logisch programmeren) bieden voor bepaalde problemen een veel betere oplossing dan objectgeorienteerd programmeren. ","description":"","tags":null,"title":"T8 Theorie objectgeoriënteerd programmeren","uri":"/theorie/objectoriented_theorie/"},{"content":"Introductie In de vierde klas heb je in JavaScript met behulp van de library p5.js een spelletje gemaakt. Later leerde je de taal C++ om daarmee een microcontroller te programmeren. JavaScript en C++ zijn verschillende programmeertalen, toch lijken ze ook wat op elkaar: het programma dat je in deze talen maakt wordt stap voor stap uitgevoerd, commando na commando. Na ieder commando is de toestand waarin je programma zich bevindt weer een beetje anders.\nDeze manier van programmeren heet imperatief programmeren. Een andere manier van programmeren is bijvoorbeeld declaratief programmeren . Zo’n manier van programmeren heet een programmeerparadigma. Vanuit imperatief programmeren is in de loop der tijd een aparte paradigma onstaan: objectgeoriënteerd programmeren. De Engelse term hiervoor is object oriented programming, ofwel OOP. Heel veel programma’s zijn gemaakt met behulp van dit paradigma. Zonder dat je het misschien hebt doorgehad, heb bij bij het werken met Arduino ook gebruik gemaakt van objectgeoriënteerd programmeren. In deze module gaan we leren dit paradigma bewust toe te passen.\nOnderstaande uitleg gaat samen op met de verwerkingsopdrachten die horen bij deze module.\nHoofdstuk 1 – objecten, attributen, methoden, this, klassen Attributen Je hebt in opdracht 2 van de verwerkingsopdrachten kennisgemaakt met objecten. Voor iedere mens maakte je een object aan met de eigenschappen x, y, speedX en speedY. Stel je maakt handmatig zo’n object en in plaats van deze in een array te plaatsen, ken je deze toe aan een variabele. Dat zou er dan zo uit kunnen zien:\nvar mensA = { x: 300, y: 600, speedX: 2, speedY: -3 } Bij objectgeoriënteerd programmeren heet een eigenschap van objecten een attribuut. Je krijgt toegang tot een attribuut met behulp van puntnotatie. Om de waarde van attribuut x van mensA uit te lezen, gebruik je mensA.x, bijv:\nconsole.log(mensA.x); Wil je de waarde van een attribuut aanpassen, dan gebruik je dezelfde schrijfwijze:\nmensA.x = mensA.x + mensA.speedX; Methoden De laatste regel code zul je in array-vorm vast ook in je simulatie-opdracht hebben staan. We hebben nu dus objecten die gegevens die bij elkaar hoort netjes in bij elkaar hebben staan. Maar hoort programmeercode die de positie van het object op basis van de snelheid aanpast eigenlijk ook niet bij datzelfde object? Dat klopt. En daarom is het ook mogelijk om een object acties / handelingen te laten uitvoeren. Je zou je het kunnen voorstellen als een functie die bij een bepaald object hoort. In objectgeoriënteerd programmeren heet zo’n ‘functie van een object’ een methode.\nAls mensA ook een methode update moet hebben die de positie van mensA updatet, moeten we de code herschrijven:\nvar mensA = { x: 300, y: 600, speedX: 2, speedY: -3, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } Als we vervolgens mensA.update aanroepen, wordt de methode uitgevoerd.\nthis Maar wat doet het keyword this in de code van update? Je zou je het als volgt kunnen voorstellen: de code binnen update heeft ‘geen idee’ dat dat object uiteindelijk via de naam mensA toegankelijk is. Die toekenning aan de naam mensA is als het ware onzichtbaar voor de code binnen het object. Toch wil je in de code van methode vaak een attribuut of methode van datzelfde object aanroepen. Daarvoor gebruikt je this. De code this.x = 90 betekent zoveel als: geef het attrituut x van mijzelf de waarde 90.\nKlassen Stel dat we meerdere mensobjecten met dezelfde eigenschappen en functionaliteit willen maken. We zouden hiervoor deze code kunnen gebruiken:\nvar mensA = { x: 300, y: 600, speedX: 2, speedY: -3, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } var mensB = { x: 50, y: 100, speedX: -2, speedY: -1, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } var mensC = { x: 200, y: 350, speedX: 3, speedY: 1, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } Als het goed is, krijg je als programmeur jeuk van deze code. De code voor de methode update is drie keer precies hetzelfde! Dit moet toch beter kunnen? En kunnen we er wel vanuit gaan dat mensA, mensB en mensC wel dezelfde attributen en methoden hebben? Het is handig dat ze bijna dezelfde namen hebben, maar zijn ze wel vergelijkbaar?\nOm deze twee problemen op te lossen, maken programmeurs gebruik van klassen. Een klasse is een soort blauwdruk van een groep objecten. We kunnen bijvoorbeeld een klasse Mens maken. Ieder object van de klasse mens heeft dan gegarandeert beschikking over alle attributen en methodes die in de klasse beschreven zijn.\nEen klasse Mens zou er in JavaScript zo uit kunnen zien:\nclass Mens { x; y; speedX; speedY; constructor(newX, newY, newSpeedX, newSpeedY) { this.x = newX; this.y = newY; this.speedX = newSpeedX; this.speedY = newSpeedY; } update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } Uitleg\nDe eerste 4 regels van de klasse Mens geven aan welke attributen deze klasse heeft. De eerste methode is de zogenaamde constructor. Dit is een speciale methode die als doel heeft een object te creëren van deze klasse. De code in een constructor doet alles wat hiervoor nodig is. Omdat een mens in onze simulatie minimaal de eigenschappen x, y, speedX en speedY moet hebben, is het het beste om deze vier waarden direct aan de constructor mee te geven. Zo krijg je altijd een object dat gelijk functioneel is.\nDe argumenten van de constructor heten hetzelfde als de attributen van de klasse. Dat is niet verplicht. Je zou de parameter x ook newX (of – doe eens gek – a) mogen noemen. Merk wel op dat in de constructor x slaat op het eerste argument van de constructor en this.x op het attribuut x van de klasse. Deze constructorcode doet precies hetzelfde als de constructorcode hierboven, maar is veel slechter te begrijpen:\nconstructor(a, b, c, d) { this.x = a; this.y = b; this.speedX = c; this.speedY = d; } De code van update herken je zo langzamerhand wel. Valt je op dat de code in een klasse zo algemeen mogelijk is? Het is zo geschreven dat het werkt voor waarden die je nu nog niet weet, maar er wel zijn als van deze klasse een object gemaakt wordt. Wanneer je een nieuw object van de klasse Mens wilt maken gebruik je het keyword new. Wanneer je new gebruikt, wordt automatisch de constructor aangeroepen. Voorbeeld: var mensA = new Mens(300, 600, 2 -3); Termen en afspraken Een klasse is een blauwdruk voor een bepaald object. Objecten van dezelfde klasse hebben dezelfde attributen en methoden. De waarden die in de attributen zijn opgeslagen, zijn mogelijk wel voor ieder object verschillend. Als object mensA een object van de klasse Mens is, zeggen we ook wel dat mensA een instantie (Engels: instance) is van de klasse Mens. Een nieuw object maken heet ook wel ‘instantiëren’ Afspraken over de schrijfwijze: de naam van een klasse begint altijd met een hoofdletter. De naam van een object begint altijd met een kleine letter. Voor beide gebruik je Camelcase . Hoofdstuk 2 – Overerving, super, polymorfie en abstracte klassen Een programmeur die objectgeoriënteerd programmeert, komt vroeg of laat tot de ontdekking dat er twee klassen zijn, die heel erg op elkaar lijken, zoals een mens en een kat in onze simulatie. Beide organismen hebben een positie en een snelheid en kunnen besmet raken. Als programmeur krijg je de rillingen van dubbele code, dus hier moet toch wel een oplossing voor zijn? Dat klopt! Deze oplossing heet overerving. Wat houdt overerving in? Overerving houdt in dat je kunt aangeven dat de ene klasse alle attributen en methoden van een andere klasse erft, overneemt. Alsof je alle code kopieert en plakt. Op basis van die geërfde attributen en methoden kun je dan je klasse verder specificeren. De klasse die de attributen en methodes doorgeeft heet de superklasse. De klasse die ze erft, heet de subklasse. Voordat we kijken naar de oplossing voor klassen als Mens en Kat, richten we ons eerst een andere actor. We gaan dit niet doorvoeren in onze simulatie maar houden een gedachte-experiment: Stel dat er in onze simulatie dokters bestaan die zieken in één keer kunnen genezen. Ze hebben zelf toegang tot een vaccin en zijn daarom immuun. Een dokter heeft alle eigenschappen van een mens, maar ziet er anders uit: hij heeft een rood kruis. Ook zouden we iets aan de code moeten veranderen die de besmetting ‘regelt’. Hieronder zie je de code die nodig is om een dokter in het spel op te nemen:\nclass Mens { x; y; speedX; speedY; breedte; isBesmet; constructor(newX, newY, newSpeedX, newSpeedY) { this.x = newX; this.y = newY; this.speedX = newSpeedX; this.speedY = newSpeedY; this.breedte = 20; this.isBesmet = false; } update() { // stuiteren tegen linker- of rechterkant if (this.x \u003c= 0 || this.x + this.breedte \u003e= width) { this.speedX = this.speedX * -1; } if (this.y \u003c= 0 || this.y + this.breedte \u003e= height) { speedY = this.speedY * -1; } // geef nieuwe positie this.x = this.x - this.speedX; this.y = this.y - this.speedY; } show() { noStroke(); // kleur op basis van besmetting if (this.isBesmet) { fill(255, 0, 0); } else { fill(255, 255, 255); } // teken vierkant rect(x, y, breedte, breedte); } isOverlappend(andereMens) { // zet teruggeefwaarde standaard op false var overlappend = false; // zet teruggeefwaarde op true als een hoekpunt overlapt met andereMens if ( (this.x \u003e= andereMens.x \u0026\u0026 this.x \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y \u003e= andereMens.y \u0026\u0026 this.y \u003c= andereMens.y + andereMens.breedte) || (this.x + this.breedte \u003e= andereMens.x \u0026\u0026 this.x + this.breedte \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y \u003e= andereMens.y \u0026\u0026 this.y \u003c= andereMens.y + andereMens.breedte) || (this.x \u003e= andereMens.x \u0026\u0026 this.x \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y + this.breedte \u003e= andereMens.y \u0026\u0026 this.y + this.breedte \u003c= andereMens.y + andereMens.breedte) || (this.x + this.breedte \u003e= andereMens.x \u0026\u0026 this.x + this.breedte \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y + this.breedte \u003e= andereMens.y \u0026\u0026 this.y + this.breedte \u003c= andereMens.y + andereMens.breedte) ) { overlappend = true; } // stuur de teruggeefwaarde terug return overlappend; } } class Dokter extends Mens { show() { // teken zoals de klasse Mens dat doet super.show(); // en daarna nog een rood kruis strokeWeight(5); stroke(255, 0, 0); // rood line(this.x + this.breedte / 2, this.y, this.x + this.breedte / 2, this.y + this.breedte); line(this.x, this.y + this.breedte / 2, this.x + this.breedte, this.y + this.breedte / 2); } } De code onder draw moeten we nu zo aanpassen, dat dokters niet besmet kunnen raken en juist zieke mensen genezen. Verander daarom deze code\n// check of er een besmetting optreedt if (mensA.isBesmet || mensB.isBesmet) { // als er één besmet is, wordt ze allebei besmet // als ze allebei besmet zijn, verandert deze code niets. mensA.isBesmet = true; mensB.isBesmet = true; } in:\n// check of er een besmetting optreedt if (mensA.isBesmet || mensB.isBesmet) { if (mensA instanceof Dokter || mensB instanceof Dokter) { // minimaal één van de mensen is dokter, // dus ze worden / blijven beide gezond mensA.isBesmet = false; mensB.isBesmet = false; } else { // geen van de mensen is dokter, dus // als er één besmet is, wordt ze allebei besmet // als ze allebei besmet zijn, verandert deze code niets. mensA.isBesmet = true; mensB.isBesmet = true; } } Bestudeer de code hierboven. Er vallen een paar dingen op.\nDe klasse Dokter geeft met het keyword extends aan dat het en subklasse van Mens is. De klasse Dokter bevat verder alleen de methode show. Wanneer op een dokterobject show wordt aangeroepen, wordt niet de methode show van de klasse Mens uitgevoerd, maar die van Dokter. Een methodes uit subklassen overschaduwen als het ware methodes met dezelfde naam uit de superklasse. Omdat we in dit geval wel gebruik willen maken van de fucntionaliteit van de methode show van Mens, zouden we die graag alsnog willen aanroepen. Dat doen we met super.show. Daardoor wordt bij het uitvoeren van show eerst getekend zoals de klasse Mens dat doet, en tekent de klasse Dokter daar nog wat bovenop. met de operator instanceof kun je controleren of een object een instantie is van een bepaalde klasse. Deze operator geeft true terug als het object een instantie van die specifieke klasse is, maar ook als het een subklasse daarvan is. Dus, stel dat mensA een dokterobject is, dan geeft mensA instanceof Mens ook true terug. Dubbele code van Kat We hebben zojuist gezien dat we met Dokter een actor hebben gemaakt die vrijwel identiek was aan Mens. Door Dokter een subklasse van Mens te laten zijn, hoeven we maar een klein beetje Dokter-specifieke code te schrijven. De rest neemt de klasse over van Mens. Maar hoe lossen we dit op voor de code die Mens en Kat hetzelfde hebben? Immers, Mens is niet een speciaal soort Kat of vice versa. Maar Mens en Kat zijn wel beide actors. Deze klasse bestaat nog niet, maar die kunnen we wel maken. Actor wordt dan de superklasse van zowel Mens als Kat en bevat alle attibuten en methodes die deze twee klassen gemeenschappelijk hebben. Je zou de klasse Actor dan kunnen zien als de basisklasse voor alle actoren in onze simulatie.\n@TODO: plaatje van klassen Welke onderdelen hebben Mens en Kat gemeenschappelijk?\nDe constructors hebben beide code die x, y, speedX en speedY van waarden voorziet. De ingestelde breedte is echter voor beide anders. De methode update is voor beide klassen gelijk. Deze werkt de positie bij op basis van de snelheid en de randen. De methode isOverlappend is voor beide identiek. De methode show verschilt enorm. Hierin kunnen we geen gemeenschappelijke code destileren. Dit geeft ons in ieder geval de volgende code voor klasse Actor:\nclass Actor { x; y; speedX; speedY; breedte; isBesmet; constructor(newX, newY, newSpeedX, newSpeedY) { this.x = newX; this.y = newY; this.speedX = newSpeedX; this.speedY = newSpeedY; this.isBesmet = false; } update() { // stuiteren tegen linker- of rechterkant if (this.x \u003c= 0 || this.x + this.breedte \u003e= width) { this.speedX = this.speedX * -1; } if (this.y \u003c= 0 || this.y + this.breedte \u003e= height) { speedY = this.speedY * -1; } // geef nieuwe positie this.x = this.x - this.speedX; this.y = this.y - this.speedY; } show() {} isOverlappend(andereActor) { // zet teruggeefwaarde standaard op false var overlappend = false; // zet teruggeefwaarde op true als een hoekpunt overlapt met andereActor if ( (this.x \u003e= andereActor.x \u0026\u0026 this.x \u003c= andereActor.x + andereActor.breedte \u0026\u0026 this.y \u003e= andereActor.y \u0026\u0026 this.y \u003c= andereActor.y + andereActor.breedte) || (this.x + this.breedte \u003e= andereActor.x \u0026\u0026 this.x + this.breedte \u003c= andereActor.x + andereActor.breedte \u0026\u0026 this.y \u003e= andereActor.y \u0026\u0026 this.y \u003c= andereActor.y + andereActor.breedte) || (this.x \u003e= andereActor.x \u0026\u0026 this.x \u003c= andereActor.x + andereActor.breedte \u0026\u0026 this.y + this.breedte \u003e= andereActor.y \u0026\u0026 this.y + this.breedte \u003c= andereActor.y + andereActor.breedte) || (this.x + this.breedte \u003e= andereActor.x \u0026\u0026 this.x + this.breedte \u003c= andereActor.x + andereActor.breedte \u0026\u0026 this.y + this.breedte \u003e= andereActor.y \u0026\u0026 this.y + this.breedte \u003c= andereActor.y + andereActor.breedte) ) { overlappend = true; } // stuur de teruggeefwaarde terug return overlappend; } } Merk het volgende op:\nDe code van update is exact de code zoals die in Mens en Kat staat. De code van isOverlappend is hetzelfde, maar voor de juistheid is andereMens veranderd in andereActor. We moeten echter ook een principiële keuze maken. Kijk daarom eens naar het volgende in de code:\nDe code in de constructor is hetzelfde, maar this.breedte krijgt geen waarde mee. De methode show is leeg. Deze code van Actor heeft tot gevolg dat we over een Actor weten dat deze in principe een breedte heeft en in pricipe met show zichzelf zou moeten kunnen tekenen. De klas Actor zelf bevat echter niet de code om getekend te worden. Hiermee bepalen we als programmeur dus dat je allerlei actors kunt maken en dat we de basisfunctionaliteit in Actor hebben gedefinieerd. We bepalen echter ook dat wij of andere programmeurs geen directe instanties van de klasse Actor in de simulatie mogen gebruiken. Zo’n superklasse die zelf niet bedoeld is om te instantiëren maar alleen gedeelde eigenschappen en functionaliteit definieert noemen we een abstracte klasse.\nLet op Je kunt goede redenen hebben om van Actor juist GEEN abstracte klasse te maken. Dit is niet verplicht als een klasse meerdere subklassen als Mens en Kat heeft. Om van Actor een concrete klasse te kunnen maken, moeten we ervoor zorgen dat deze invulling geeft aan alle gedeclareerde attributen en methoden:\nwe geven this.breedte een waarde in de constructor we definiëren show met code die een ‘actor in het algemeen’ tekent zoals wij dat willen. (Tip: wel vierkant, want onze code in ‘isOverlappend’ gaat uit van een vierkant). Wat vind jij het meest logisch? Actor als abstracte klasse of juist niet?\nHoofdstuk 3 - Privé attributen, getters en setters, inkapseling, klasse variabelen Je hebt op dit moment al echt een heel leuke simulator gebouwd! Wees blij met het resultaat dat je hebt bereikt. We gaan ontwikkelen ’m nog een kleine stukje verder en dan is het genoeg geweest.\nJe zou je kunnen voorstellen dat een andere programmeur (collega?) een half jaar later jouw simulator verder uitbouwt. Deze collega heeft misschien geen idee van de exacte logica achter de Dokterklasse. Het zou met de huidige code zomaar kunnen dat die andere programmeur het attribuut isBesmet bij een dokter toch (per ongeluk) op true zet. Terwijl wij hadden bedacht dat dit juist niet zou moeten kunnen. We zouden hiervoor het attribuut isBesmet een beetje willen afschermen. Niet alles mag hier zomaar mee gedaan worden. Het uitlezen moet echter wel mogelijk zijn.\nOp dezelfde manier kun je ook van x, y kunnen zeggen dat deze niet van buitenaf veranderd zouden moeten kunnen worden. De positie wordt helemaal autonoom door de klassen geregeld. En laten we speedX, speedY, breedte en besmettelijkheidsTeller dan ook maar helemaal voor rare programmeurs beschermen. We willen gewoonweg niet dat dit zomaar wordt aangepast. Als dit wordt aangepast, dan op onze voorwaarden. Je zou er toch niet aan moeten denken dat een juniorprogrammeur een de breedte van een mensobject verandert in een negatief getal 😱.\nDit kun je doen door een attribuut private te maken. Een attribuut waarvoor dat niet geldt, heet public. Hoe je precies een attribuut publiek of privé maakt, verschilt nogal per objectgeoriënteerde taal. Wel heeft bijna iedere objectgeoriënteerde taal hier mogelijkheden voor. In JavaScript werkt het niet het meest fraai van alle programmeertalen, maar het is wel heel duidelijk: een privéattribuut begin met een #. Dus wil je isBesmet een private maken, dan verander je door je hele code dit attribuut in #isBesmet.\nNu hebben we isBesmet mooi afgeschermd van onverantwoorde veranderingen, we hebben dit attribuut nu ook afgeschermd van uitlezen… Dat was niet de bedoeling want nu kunnen we onze statistieken niet meer maken. Om dat op te lossen maken we een nieuwe methode in Actor:\ngetIsBesmet() { return this.#isBesmet } Omdat deze code binnen de klasse Actor staat, heeft deze wel toegang tot isBesmet en dan deze zo teruggegeven worden. Wil je van mensA de waarde van isBesmet weten? Dan gebruik je mensA.getIsBesmet(). (Toegegeven: ‘getIsBesmet’ is geen mooie code, maar om het niet moeilijker te maken houdt ik het even zo voorspelbaar mogelijk). Een methode die de waarde van een attribuut teruggeeft, heet een getter. Dezelfde manier kun je nu gebruiken om van x, y, speedX, speedY en breedte een attribuut te maken dat read-only is.\nHet zou kunnen dat je wilt dat je de positie van een actor toch van buitenaf moet kunnen aanpassen, maar dat dit wil een positie moet zijn binnen de simulatie. Je legt het schrijven van x en y dus beperkingen op. Dat kan zo:\nsetX(x) { var validX = x; if (validX \u003c 0) { validX = 0; } if (validX \u003e width) { validX = width; } this.#x = validX; } setY(y) { // constrain zorgt er net zoals de code onder setX voor // dat een variabele binnen een bepaald bereik valt. this.#y = constrain(y, 0, height); } De code onder setX en setY werkt hetzelfde, maar bij setY wordt gebruik gemaakt van de p5js-functie constrain , wat heel veel regels code scheelt! Wil je een actorobject een andere x-waarde geven? Dan kan dat zo: mensA.setX(145)\nEen methode die schrijftoegang tot een attribuut regelt, heet een setter. De werkwijze waarbij je toegang tot de gegevens van een object beperkt en de toegang principieel bij het object zelf legt, heet inkapseling (Engels: encapsulation). Deze techniek is erg belangrijk bij objectgeoriënteerd programmeren voorkomt allerlei ongewenst gebruik van klassen.\nWanneer je de simulator runt, zul je erachter komen dat de besmettingen niet meer werken. Dit komt doordat de code in update die de besmettingen ‘regelt’, geen waarde in #isBesmet kan schrijven. We kunnen dit regelen door in Actor een setter setIsBesmet(besmet) te maken:\nsetIsBesmet(besmet) { this.#isBesmet = besmet; } Maar dan hebben we opnieuw het probleem dat ook een dokterobject op deze manier besmet kan raken! Dit is echter gemakkelijk op te lossen. We definiëren ook in de klasse Dokter de methode setIsBesmet(besmet), waardoor bij de aanroep hiervan op een dokterobject deze code wordt uitgevoerd:\nsetIsBesmet(besmet) { this.#isBesmet = false } Hoofdstuk 4 - C++, polymorfie, voordelen en nadelen Je hebt nu op een redelijk niveau objectgeoriënteerd leren programmeren in JavaScript. Zoals eerder gezegd heb je, misschien zonder dat je het wist, ook al in C++ object georiënteerd geprogrammeerd. Neem bijvoorbeeld het gebruik van de Seriële Communicatie tussen je Arduino en de computer. Een heel simpel Arduinoprogramma dat elke seconde een berichtje stuurt, ziet er zo uit:\nvoid setup() { Serial.begin(9600); } void loop() { Serial.println(\"Dit is een bericht\"); delay(1000); } Serial is een object dat de Arduinosoftware aanmaakt om ons, eenvoudige programmeurs, toegang te geven tot seriële communicatie. Dit object heeft onder andere de methodes begin en println. (Hoewel Arduino zelf de naam van enkele objecten met een hoofdletter begint, houden wij ons aan de afspraak dat klassennamen met een hoofdletter beginnen en objectnamen met een kleine letter.)\nEn als je al eens een servomotor hebt aangestuurd, herken je hieronder ook objectgeoriënteerde code:\n#include \u003cServo.h\u003e Servo mijnServo; void setup() { mijnServo.attach(9); } void loop() { mijnServo.write(0); delay(500); mijnServo.write(180); delay(500); } Nu je weet hoe je klassen en objecten in JavaScript maakt, is het gemakkelijk om te leren hoe dit in C++ werkt. Hierbij maken we één belangrijke versimpeling, wanneer je klassen in losse bestanden aanlevert, moet dit verdeeld worden in twee bestanden. Eén bestand is de header file, eindigend op .h, die beschrijft welke attributen en methodes de klasse heeft en of het een superklasse heeft. Het andere bestand, eindigend op .cpp, bevat de programmeercode. Wij stoppen de code van een klasse echter voor het gemak in één bestand.\n#include \u003cArduino.h\u003e class Stoplicht { private: int toestand; int pinRood; int pinOranje; int pinGroen; void update() { if (this-\u003etoestand == this-\u003eROOD) { digitalWrite(this-\u003epinRood, HIGH); } else { digitalWrite(this-\u003epinRood, LOW); } // je kunt het ook korter schrijven: digitalWrite(this-\u003epinOranje, this-\u003etoestand == this-\u003eORANJE); digitalWrite(this-\u003epinGroen, this-\u003etoestand == this-\u003eGROEN); } public: // constante klasse attributen static const int GROEN = 0; static const int ORANJE = 1; static const int ROOD = 2; Stoplicht(int newPinRood, int newPinOranje, int newPinGroen) { // neem de opgegeven pinNummers over this-\u003epinRood = newPinRood; this-\u003epinOranje = newPinOranje; this-\u003epinGroen = newPinGroen; // maak van de pinnen OUTPUTs pinMode(this-\u003epinRood, OUTPUT); pinMode(this-\u003epinOranje, OUTPUT); pinMode(this-\u003epinGroen, OUTPUT); this-\u003etoestand = GROEN; } void rood() { this-\u003etoestand = ROOD; } void oranje() { this-\u003etoestand = ORANJE; } void groen() { this-\u003etoestand = GROEN; } int getToestand() { return this-\u003etoestand; } }; Je hebt gezien dat C++ ook gebruik maakt van de . om attributen en methodes van objecten aan te spreken. Bij this wordt echter -\u003e gebruik. Het voert te ver om precies uit te leggen waarom dit is. Het gebruik van this is in C++ echter niet verplicht. Je zult daarom ook vaker code tegenkomen zoals hieronder, waarbij de gewoonte is dat men private attributen laat beginnen met een _:\n#include \u003cArduino.h\u003e class Stoplicht { private: int _toestand; int _pinRood; int _pinOranje; int _pinGroen; void update() { if (_toestand == ROOD) { digitalWrite(_pinRood, HIGH); } else { digitalWrite(_pinRood, LOW); } // je kunt het ook korter schrijven: digitalWrite(_pinOranje, _toestand == ORANJE); digitalWrite(_pinGroen, _toestand == GROEN); } public: // constante klasse attributen static const int GROEN = 0; static const int ORANJE = 1; static const int ROOD = 2; Stoplicht(int newPinRood, int newPinOranje, int newPinGroen) { // neem de opgegeven pinNummers over _pinRood = newPinRood; _pinOranje = newPinOranje; _pinGroen = newPinGroen; // maak van de pinnen OUTPUTs pinMode(_pinRood, OUTPUT); pinMode(_pinOranje, OUTPUT); pinMode(_pinGroen, OUTPUT); _toestand = GROEN; } void rood() { _toestand = ROOD; update(); } void oranje() { _toestand = ORANJE; update(); } void groen() { _toestand = GROEN; update(); } int getToestand() { return _toestand; } }; Je mag zelf kiezen welke stijl je het meest aanspreekt, als je maar consistent bent.\nHet aanmaken van een stoplichtobject gebeurt als volgt:\nStoplicht lichtA(9, 10, 11);\nDeze regel code roept de constructor van de klasse Stoplicht aan met 9, 10 en 11 als waarden voor de pinnen van resp. het rode, oranje en groene licht.\nEen aantal zaken valt op:\nDe toegang wordt geregeld met de gedeelten public en private. Niet alleen attributen, maar ook methoden kunnen private zijn. De enige publieke methoden zijn rood, oranje en groen en de getter van _toestand. De methode update is private. Het aanpassen van de status van de pinnen wordt gedaan naar aanleiding van het aanroepen van rood, oranje of groen, maar hoeft niet door ’een ander’ te gebeuren. De constructor draagt de naam van de klasse. C++ is een sterk getypeerde (Engels: strongly typed) taal, dus attributen hebben een type en de methoden hebben een teruggeefwaarde (behalve de constructor) De ; na de klasse declaratie is noodzakelijk. Subclassing in C++ gaat (in eenvoudige vorm) vrijwel hetzelfde als in JavaScript:\nclass Lamp { private: bool _pin bool _isAan; public: Lamp(int newPin) { _isAan = false; pinMode(_pin, OUTPUT); } void zetAan() { _isAan = true; } void zetUit() { _isAan = false; } // voer in elke loop deze methode uit void update() { digitalWrite(_pin, _isAan); } }; class KnipperLamp : public Lamp { private: int _wachtTijd; unsigned long _veranderTimer; public: KnipperLamp(int newPin, int newWachtTijd) : Lamp(newPin) { _wachtTijd = newWachtTijd; _veranderTimer = millis() + _wachtTijd; } void update() { if (millis() \u003e _veranderTimer) { _isAan = !_isAan; _veranderTimer = millis() + _wachtTijd; } Lamp :: update(); } int getWachtTijd() { return _wachtTijd; } } Polymorfisme Stel, we hebben een aantal lampobjecten en knipperlampobjecten waarop we met behulp van een for-loop update willen aanroepen. De inhoud van een array moet in C++ van hetzelfde soort zijn, dus alleen ints, floats, of objecten van dezelfde klasse. Moeten we voor lampen en knipperlampen dan misschien twee afzonderlijke arrays maken? Nee, dat is niet noodzakelijk. Omdat Knipperlamp een subklasse is van Lamp, voldoet deze daarmee ook aan alle eigenschappen van Lamp. De volgende code is dus geldig:\n// een array met zowel lamp- als knipperlampobjecten Lamp lampen[] = { Lamp(3), KnipperLamp(9, 500), Lamp(5) } void setup() { lampen[0].zetAan(); lampen[1].zetAan(); // de laatste lamp laten we uit } void loop() { for (int i = 0; i \u003c lampen.length(); i++\u003e) { Lamp l = lampen[i]; l.update(); } } Laten we stap voor stap de for-loop hierboven doorlopen: We weten zeker dat er objecten in de array lampen objecten zitten die Lamp als klasse of superklasse hebben. We kunnen kunnen er dus vanuit gaan dat deze objecten de objecten en methoden hebben zoals die in Lamp staan.\ni = 0 l wordt behandeld als lampobject en is dat ook (het eerste element van de array lampen). De aanroep l.update() laat de methode update van de klasse Lamp uitvoeren.\ni = 1 l wordt behandeld als lampobject, maar is eigenlijk een knipperlampobject (het tweede element van de array lampen). De aanroep van l.update() laat de methode update van de klasse KnipperLamp uitvoeren.\ni = 2 Gaat net zoals bij i=0, maar dan voor het laatste object van lampen.\nDe aanroep van update kan, omdat we zeker weten dat de objecten in de array lampen die methode hebben. Omdat één van die objecten echter een subklasse van Lamp is, (namelijk KnipperLamp) die een eigen implementatie van update heeft, wordt in dat geval die code uitgevoerd. In principe hoeven we hier echter helemaal geen rekening mee te houden. In de for-loop mag je uitgaan van lamp-objecten.\nWanneer een object / functie / methode in verschillende scenario’s zich anders gedraagt, spreken we in de informatica van polymorfisme. Je komt dit ook op andere manieren tegen. De operator + kan in C++ zowel gebruikt worden om integers bij elkaar op te tellen, maar ook om strings aan elkaar vast te plakken.\nVoor- en nadelen van objectgeoriënteerd programmeren Objectgeoriënteerd programmeren is al tientallen jaren een populaire programmeerparadigma. Dit komt omdat deze manier van programmeren een aantal voordelen heeft die het erg aantrekkelijk maken.\nVoordelen Modulariteit Objectgeoriënteerd programmeren vereist dat een programma in modules wordt opgebouwd. Dit al handig bij kleine programma’s, maar werkt geweldig bij grote systemen die door hun omvang door uit verschillende deelsystemen bestaat die elk door andere personen of teams worden ontwikkeld. Bij objectgeoriënteerd programmeren kun je, als eenmaal is vastgelegd welke methode een klasse heeft, deze onafhankelijk van andere klassen implementeren.\nInkapseling In eerdere vormen van programmeren was het deels mogelijk om een programma in modules te ontwikkelen, maar data was dan gemakkelijk toegankelijk voor allerlei delen van de programmacode, ook delen die de data niet zouden mogen veranderen.\nDoor inkapseling van gegevens binnen klasse is het gemakkelijker om deze gegevens te ‘beschermen’. Ze zijn ontoegankelijk voor andere stukken programmeercode en daardoor is het gemakkelijker om regels over de data (zoals dat een waarde nooit kleiner mag zijn van 0) af te dwingen.\nFlexibel hergebruik Het is met behulp van objectgeoriënteerd programmeren erg gemakkelijk om code opnieuw te gebruiken in een andere context. Het principe van overerving speelt hierbij een belangrijke rol. Algemene eigenschappen van een klasse definieer je in een superklasse, specifieke eigenschappen in een subklasse. De subklassen gebruik je dan op verschillende plekken in je programma, of zelfs over meerdere programma’s. Hierdoor hoef je de algemene code maar één keer te schrijven en hergebruik je deze code dus telkens als je een subklasse gebruikt.\nNadelen Objectgeoriënteerd programmeren heeft echter ook een aantal nadelen. Of, beter gezegd: Er is ook wel wat af te dingen van dit mooie programmeerparadigma:\nObjectgeoriënteerd programmeren is moeilijk en kost veel tijd om een goed objectgeoriënteerd ontwerp te maken Het uitvoeren van een objectgeoriënteerd programma kost meer computerkracht en -geheugen dan de oudere manieren van programmeren. Er is sprake van meer overhead. Andere vormen van programmeren (zoals procedureel, functioneel of logisch programmeren) bieden voor bepaalde problemen een veel betere oplossing dan objectgeorienteerd programmeren. ","description":"","tags":null,"title":"T8 Theorie objectgeoriënteerd programmeren","uri":"/theorie/objectoriented_theorie_backup/"},{"content":"Introductie In de vierde klas heb je in JavaScript met behulp van de library p5.js een spelletje gemaakt. Later leerde je de taal C++ om daarmee een microcontroller te programmeren. JavaScript en C++ zijn verschillende programmeertalen, toch lijken ze ook wat op elkaar: het programma dat je in deze talen maakt wordt stap voor stap uitgevoerd, commando na commando. Na ieder commando is de toestand waarin je programma zich bevindt weer een beetje anders.\nDeze manier van programmeren heet imperatief programmeren. Een andere manier van programmeren is bijvoorbeeld declaratief programmeren . Zo’n manier van programmeren heet een programmeerparadigma. Vanuit imperatief programmeren is in de loop der tijd een aparte paradigma onstaan: objectgeoriënteerd programmeren. De Engelse term hiervoor is object oriented programming, ofwel OOP. Heel veel programma’s zijn gemaakt met behulp van dit paradigma. Zonder dat je het misschien hebt doorgehad, heb bij bij het werken met Arduino ook gebruik gemaakt van objectgeoriënteerd programmeren. In deze module gaan we leren dit paradigma bewust toe te passen.\nOnderstaande uitleg gaat samen op met de verwerkingsopdrachten die horen bij deze module.\nHoofdstuk 1 – objecten, attributen, methoden, this, klassen Attributen Je hebt in opdracht 2 van de verwerkingsopdrachten kennisgemaakt met objecten. Voor iedere mens maakte je een object aan met de eigenschappen x, y, speedX en speedY. Stel je maakt handmatig zo’n object en in plaats van deze in een array te plaatsen, ken je deze toe aan een variabele. Dat zou er dan zo uit kunnen zien:\nvar mensA = { x: 300, y: 600, speedX: 2, speedY: -3 } Bij objectgeoriënteerd programmeren heet een eigenschap van objecten een attribuut. Je krijgt toegang tot een attribuut met behulp van puntnotatie. Om de waarde van attribuut x van mensA uit te lezen, gebruik je mensA.x, bijv:\nconsole.log(mensA.x); Wil je de waarde van een attribuut aanpassen, dan gebruik je dezelfde schrijfwijze:\nmensA.x = mensA.x + mensA.speedX; Methoden De laatste regel code zul je in array-vorm vast ook in je simulatie-opdracht hebben staan. We hebben nu dus objecten die gegevens die bij elkaar hoort netjes in bij elkaar hebben staan. Maar hoort programmeercode die de positie van het object op basis van de snelheid aanpast eigenlijk ook niet bij datzelfde object? Dat klopt. En daarom is het ook mogelijk om een object acties / handelingen te laten uitvoeren. Je zou je het kunnen voorstellen als een functie die bij een bepaald object hoort. In objectgeoriënteerd programmeren heet zo’n ‘functie van een object’ een methode.\nAls mensA ook een methode update moet hebben die de positie van mensA updatet, moeten we de code herschrijven:\nvar mensA = { x: 300, y: 600, speedX: 2, speedY: -3, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } Als we vervolgens mensA.update aanroepen, wordt de methode uitgevoerd.\nthis Maar wat doet het keyword this in de code van update? Je zou je het als volgt kunnen voorstellen: de code binnen update heeft ‘geen idee’ dat dat object uiteindelijk via de naam mensA toegankelijk is. Die toekenning aan de naam mensA is als het ware onzichtbaar voor de code binnen het object. Toch wil je in de code van methode vaak een attribuut of methode van datzelfde object aanroepen. Daarvoor gebruikt je this. De code this.x = 90 betekent zoveel als: geef het attrituut x van mijzelf de waarde 90.\nKlassen Stel dat we meerdere mensobjecten met dezelfde eigenschappen en functionaliteit willen maken. We zouden hiervoor deze code kunnen gebruiken:\nvar mensA = { x: 300, y: 600, speedX: 2, speedY: -3, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } var mensB = { x: 50, y: 100, speedX: -2, speedY: -1, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } var mensC = { x: 200, y: 350, speedX: 3, speedY: 1, update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } Als het goed is, krijg je als programmeur jeuk van deze code. De code voor de methode update is drie keer precies hetzelfde! Dit moet toch beter kunnen? En kunnen we er wel vanuit gaan dat mensA, mensB en mensC wel dezelfde attributen en methoden hebben? Het is handig dat ze bijna dezelfde namen hebben, maar zijn ze wel vergelijkbaar?\nOm deze twee problemen op te lossen, maken programmeurs gebruik van klassen. Een klasse is een soort blauwdruk van een groep objecten. We kunnen bijvoorbeeld een klasse Mens maken. Ieder object van de klasse mens heeft dan gegarandeert beschikking over alle attributen en methodes die in de klasse beschreven zijn.\nEen klasse Mens zou er in JavaScript zo uit kunnen zien:\nclass Mens { x; y; speedX; speedY; constructor(newX, newY, newSpeedX, newSpeedY) { this.x = newX; this.y = newY; this.speedX = newSpeedX; this.speedY = newSpeedY; } update() { this.x = this.x - this.speedX; this.y = this.y - this.speedY; } } Uitleg\nDe eerste 4 regels van de klasse Mens geven aan welke attributen deze klasse heeft. De eerste methode is de zogenaamde constructor. Dit is een speciale methode die als doel heeft een object te creëren van deze klasse. De code in een constructor doet alles wat hiervoor nodig is. Omdat een mens in onze simulatie minimaal de eigenschappen x, y, speedX en speedY moet hebben, is het het beste om deze vier waarden direct aan de constructor mee te geven. Zo krijg je altijd een object dat gelijk functioneel is.\nDe argumenten van de constructor heten hetzelfde als de attributen van de klasse. Dat is niet verplicht. Je zou de parameter x ook newX (of – doe eens gek – a) mogen noemen. Merk wel op dat in de constructor x slaat op het eerste argument van de constructor en this.x op het attribuut x van de klasse. Deze constructorcode doet precies hetzelfde als de constructorcode hierboven, maar is veel slechter te begrijpen:\nconstructor(a, b, c, d) { this.x = a; this.y = b; this.speedX = c; this.speedY = d; } De code van update herken je zo langzamerhand wel. Valt je op dat de code in een klasse zo algemeen mogelijk is? Het is zo geschreven dat het werkt voor waarden die je nu nog niet weet, maar er wel zijn als van deze klasse een object gemaakt wordt. Wanneer je een nieuw object van de klasse Mens wilt maken gebruik je het keyword new. Wanneer je new gebruikt, wordt automatisch de constructor aangeroepen. Voorbeeld: var mensA = new Mens(300, 600, 2 -3); Termen en afspraken Een klasse is een blauwdruk voor een bepaald object. Objecten van dezelfde klasse hebben dezelfde attributen en methoden. De waarden die in de attributen zijn opgeslagen, zijn mogelijk wel voor ieder object verschillend. Als object mensA een object van de klasse Mens is, zeggen we ook wel dat mensA een instantie (Engels: instance) is van de klasse Mens. Een nieuw object maken heet ook wel ‘instantiëren’ Afspraken over de schrijfwijze: de naam van een klasse begint altijd met een hoofdletter. De naam van een object begint altijd met een kleine letter. Voor beide gebruik je Camelcase . Hoofdstuk 2 – Overerving, super, polymorfie en abstracte klassen Een programmeur die objectgeoriënteerd programmeert, komt vroeg of laat tot de ontdekking dat er twee klassen zijn, die heel erg op elkaar lijken, zoals een mens en een kat in onze simulatie. Beide organismen hebben een positie en een snelheid en kunnen besmet raken. Als programmeur krijg je de rillingen van dubbele code, dus hier moet toch wel een oplossing voor zijn? Dat klopt! Deze oplossing heet overerving. Wat houdt overerving in? Overerving houdt in dat je kunt aangeven dat de ene klasse alle attributen en methoden van een andere klasse erft, overneemt. Alsof je alle code kopieert en plakt. Op basis van die geërfde attributen en methoden kun je dan je klasse verder specificeren. De klasse die de attributen en methodes doorgeeft heet de superklasse. De klasse die ze erft, heet de subklasse. Voordat we kijken naar de oplossing voor klassen als Mens en Kat, richten we ons eerst een andere actor. We gaan dit niet doorvoeren in onze simulatie maar houden een gedachte-experiment: Stel dat er in onze simulatie dokters bestaan die zieken in één keer kunnen genezen. Ze hebben zelf toegang tot een vaccin en zijn daarom immuun. Een dokter heeft alle eigenschappen van een mens, maar ziet er anders uit: hij heeft een rood kruis. Ook zouden we iets aan de code moeten veranderen die de besmetting ‘regelt’. Hieronder zie je de code die nodig is om een dokter in het spel op te nemen:\nclass Mens { x; y; speedX; speedY; breedte; isBesmet; constructor(newX, newY, newSpeedX, newSpeedY) { this.x = newX; this.y = newY; this.speedX = newSpeedX; this.speedY = newSpeedY; this.breedte = 20; this.isBesmet = false; } update() { // stuiteren tegen linker- of rechterkant if (this.x \u003c= 0 || this.x + this.breedte \u003e= width) { this.speedX = this.speedX * -1; } if (this.y \u003c= 0 || this.y + this.breedte \u003e= height) { speedY = this.speedY * -1; } // geef nieuwe positie this.x = this.x - this.speedX; this.y = this.y - this.speedY; } show() { noStroke(); // kleur op basis van besmetting if (this.isBesmet) { fill(255, 0, 0); } else { fill(255, 255, 255); } // teken vierkant rect(x, y, breedte, breedte); } isOverlappend(andereMens) { // zet teruggeefwaarde standaard op false var overlappend = false; // zet teruggeefwaarde op true als een hoekpunt overlapt met andereMens if ( (this.x \u003e= andereMens.x \u0026\u0026 this.x \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y \u003e= andereMens.y \u0026\u0026 this.y \u003c= andereMens.y + andereMens.breedte) || (this.x + this.breedte \u003e= andereMens.x \u0026\u0026 this.x + this.breedte \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y \u003e= andereMens.y \u0026\u0026 this.y \u003c= andereMens.y + andereMens.breedte) || (this.x \u003e= andereMens.x \u0026\u0026 this.x \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y + this.breedte \u003e= andereMens.y \u0026\u0026 this.y + this.breedte \u003c= andereMens.y + andereMens.breedte) || (this.x + this.breedte \u003e= andereMens.x \u0026\u0026 this.x + this.breedte \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y + this.breedte \u003e= andereMens.y \u0026\u0026 this.y + this.breedte \u003c= andereMens.y + andereMens.breedte) ) { overlappend = true; } // stuur de teruggeefwaarde terug return overlappend; } } class Dokter extends Mens { show() { // teken zoals de klasse Mens dat doet super.show(); // en daarna nog een rood kruis strokeWeight(5); stroke(255, 0, 0); // rood line(this.x + this.breedte / 2, this.y, this.x + this.breedte / 2, this.y + this.breedte); line(this.x, this.y + this.breedte / 2, this.x + this.breedte, this.y + this.breedte / 2); } } De code onder draw moeten we nu zo aanpassen, dat dokters niet besmet kunnen raken en juist zieke mensen genezen. Verander daarom deze code\n// check of er een besmetting optreedt if (mensA.isBesmet || mensB.isBesmet) { // als er één besmet is, wordt ze allebei besmet // als ze allebei besmet zijn, verandert deze code niets. mensA.isBesmet = true; mensB.isBesmet = true; } in:\n// check of er een besmetting optreedt if (mensA.isBesmet || mensB.isBesmet) { if (mensA instanceof Dokter || mensB instanceof Dokter) { // minimaal één van de mensen is dokter, // dus ze worden / blijven beide gezond mensA.isBesmet = false; mensB.isBesmet = false; } else { // geen van de mensen is dokter, dus // als er één besmet is, wordt ze allebei besmet // als ze allebei besmet zijn, verandert deze code niets. mensA.isBesmet = true; mensB.isBesmet = true; } } Bestudeer de code hierboven. Er vallen een paar dingen op.\nDe klasse Dokter geeft met het keyword extends aan dat het en subklasse van Mens is. De klasse Dokter bevat verder alleen de methode show. Wanneer op een dokterobject show wordt aangeroepen, wordt niet de methode show van de klasse Mens uitgevoerd, maar die van Dokter. Een methodes uit subklassen overschaduwen als het ware methodes met dezelfde naam uit de superklasse. Omdat we in dit geval wel gebruik willen maken van de fucntionaliteit van de methode show van Mens, zouden we die graag alsnog willen aanroepen. Dat doen we met super.show. Daardoor wordt bij het uitvoeren van show eerst getekend zoals de klasse Mens dat doet, en tekent de klasse Dokter daar nog wat bovenop. met de operator instanceof kun je controleren of een object een instantie is van een bepaalde klasse. Deze operator geeft true terug als het object een instantie van die specifieke klasse is, maar ook als het een subklasse daarvan is. Dus, stel dat mensA een dokterobject is, dan geeft mensA instanceof Mens ook true terug. Dubbele code van Kat We hebben zojuist gezien dat we met Dokter een actor hebben gemaakt die vrijwel identiek was aan Mens. Door Dokter een subklasse van Mens te laten zijn, hoeven we maar een klein beetje Dokter-specifieke code te schrijven. De rest neemt de klasse over van Mens. Maar hoe lossen we dit op voor de code die Mens en Kat hetzelfde hebben? Immers, Mens is niet een speciaal soort Kat of vice versa. Maar Mens en Kat zijn wel beide actors. Deze klasse bestaat nog niet, maar die kunnen we wel maken. Actor wordt dan de superklasse van zowel Mens als Kat en bevat alle attibuten en methodes die deze twee klassen gemeenschappelijk hebben. Je zou de klasse Actor dan kunnen zien als de basisklasse voor alle actoren in onze simulatie.\n@TODO: plaatje van klassen Welke onderdelen hebben Mens en Kat gemeenschappelijk?\nDe constructors hebben beide code die x, y, speedX en speedY van waarden voorziet. De ingestelde breedte is echter voor beide anders. De methode update is voor beide klassen gelijk. Deze werkt de positie bij op basis van de snelheid en de randen. De methode isOverlappend is voor beide identiek. De methode show verschilt enorm. Hierin kunnen we geen gemeenschappelijke code destileren. Dit geeft ons in ieder geval de volgende code voor klasse Actor:\nclass Actor { x; y; speedX; speedY; breedte; isBesmet; constructor(newX, newY, newSpeedX, newSpeedY) { this.x = newX; this.y = newY; this.speedX = newSpeedX; this.speedY = newSpeedY; this.isBesmet = false; } update() { // stuiteren tegen linker- of rechterkant if (this.x \u003c= 0 || this.x + this.breedte \u003e= width) { this.speedX = this.speedX * -1; } if (this.y \u003c= 0 || this.y + this.breedte \u003e= height) { speedY = this.speedY * -1; } // geef nieuwe positie this.x = this.x - this.speedX; this.y = this.y - this.speedY; } show() {} isOverlappend(andereActor) { // zet teruggeefwaarde standaard op false var overlappend = false; // zet teruggeefwaarde op true als een hoekpunt overlapt met andereActor if ( (this.x \u003e= andereActor.x \u0026\u0026 this.x \u003c= andereActor.x + andereActor.breedte \u0026\u0026 this.y \u003e= andereActor.y \u0026\u0026 this.y \u003c= andereActor.y + andereActor.breedte) || (this.x + this.breedte \u003e= andereActor.x \u0026\u0026 this.x + this.breedte \u003c= andereActor.x + andereActor.breedte \u0026\u0026 this.y \u003e= andereActor.y \u0026\u0026 this.y \u003c= andereActor.y + andereActor.breedte) || (this.x \u003e= andereActor.x \u0026\u0026 this.x \u003c= andereActor.x + andereActor.breedte \u0026\u0026 this.y + this.breedte \u003e= andereActor.y \u0026\u0026 this.y + this.breedte \u003c= andereActor.y + andereActor.breedte) || (this.x + this.breedte \u003e= andereActor.x \u0026\u0026 this.x + this.breedte \u003c= andereActor.x + andereActor.breedte \u0026\u0026 this.y + this.breedte \u003e= andereActor.y \u0026\u0026 this.y + this.breedte \u003c= andereActor.y + andereActor.breedte) ) { overlappend = true; } // stuur de teruggeefwaarde terug return overlappend; } } Merk het volgende op:\nDe code van update is exact de code zoals die in Mens en Kat staat. De code van isOverlappend is hetzelfde, maar voor de juistheid is andereMens veranderd in andereActor. We moeten echter ook een principiële keuze maken. Kijk daarom eens naar het volgende in de code:\nDe code in de constructor is hetzelfde, maar this.breedte krijgt geen waarde mee. De methode show is leeg. Deze code van Actor heeft tot gevolg dat we over een Actor weten dat deze in principe een breedte heeft en in pricipe met show zichzelf zou moeten kunnen tekenen. De klas Actor zelf bevat echter niet de code om getekend te worden. Hiermee bepalen we als programmeur dus dat je allerlei actors kunt maken en dat we de basisfunctionaliteit in Actor hebben gedefinieerd. We bepalen echter ook dat wij of andere programmeurs geen directe instanties van de klasse Actor in de simulatie mogen gebruiken. Zo’n superklasse die zelf niet bedoeld is om te instantiëren maar alleen gedeelde eigenschappen en functionaliteit definieert noemen we een abstracte klasse.\nLet op Je kunt goede redenen hebben om van Actor juist GEEN abstracte klasse te maken. Dit is niet verplicht als een klasse meerdere subklassen als Mens en Kat heeft. Om van Actor een concrete klasse te kunnen maken, moeten we ervoor zorgen dat deze invulling geeft aan alle gedeclareerde attributen en methoden:\nwe geven this.breedte een waarde in de constructor we definiëren show met code die een ‘actor in het algemeen’ tekent zoals wij dat willen. (Tip: wel vierkant, want onze code in ‘isOverlappend’ gaat uit van een vierkant). Wat vind jij het meest logisch? Actor als abstracte klasse of juist niet?\nHoofdstuk 3 - Privé attributen, getters en setters, inkapseling, klasse variabelen Je hebt op dit moment al echt een heel leuke simulator gebouwd! Wees blij met het resultaat dat je hebt bereikt. We gaan ontwikkelen ’m nog een kleine stukje verder en dan is het genoeg geweest.\nJe zou je kunnen voorstellen dat een andere programmeur (collega?) een half jaar later jouw simulator verder uitbouwt. Deze collega heeft misschien geen idee van de exacte logica achter de Dokterklasse. Het zou met de huidige code zomaar kunnen dat die andere programmeur het attribuut isBesmet bij een dokter toch (per ongeluk) op true zet. Terwijl wij hadden bedacht dat dit juist niet zou moeten kunnen. We zouden hiervoor het attribuut isBesmet een beetje willen afschermen. Niet alles mag hier zomaar mee gedaan worden. Het uitlezen moet echter wel mogelijk zijn.\nOp dezelfde manier kun je ook van x, y kunnen zeggen dat deze niet van buitenaf veranderd zouden moeten kunnen worden. De positie wordt helemaal autonoom door de klassen geregeld. En laten we speedX, speedY, breedte en besmettelijkheidsTeller dan ook maar helemaal voor rare programmeurs beschermen. We willen gewoonweg niet dat dit zomaar wordt aangepast. Als dit wordt aangepast, dan op onze voorwaarden. Je zou er toch niet aan moeten denken dat een juniorprogrammeur een de breedte van een mensobject verandert in een negatief getal 😱.\nDit kun je doen door een attribuut private te maken. Een attribuut waarvoor dat niet geldt, heet public. Hoe je precies een attribuut publiek of privé maakt, verschilt nogal per objectgeoriënteerde taal. Wel heeft bijna iedere objectgeoriënteerde taal hier mogelijkheden voor. In JavaScript werkt het niet het meest fraai van alle programmeertalen, maar het is wel heel duidelijk: een privéattribuut begin met een #. Dus wil je isBesmet een private maken, dan verander je door je hele code dit attribuut in #isBesmet.\nNu hebben we isBesmet mooi afgeschermd van onverantwoorde veranderingen, we hebben dit attribuut nu ook afgeschermd van uitlezen… Dat was niet de bedoeling want nu kunnen we onze statistieken niet meer maken. Om dat op te lossen maken we een nieuwe methode in Actor:\ngetIsBesmet() { return this.#isBesmet } Omdat deze code binnen de klasse Actor staat, heeft deze wel toegang tot isBesmet en dan deze zo teruggegeven worden. Wil je van mensA de waarde van isBesmet weten? Dan gebruik je mensA.getIsBesmet(). (Toegegeven: ‘getIsBesmet’ is geen mooie code, maar om het niet moeilijker te maken houdt ik het even zo voorspelbaar mogelijk). Een methode die de waarde van een attribuut teruggeeft, heet een getter. Dezelfde manier kun je nu gebruiken om van x, y, speedX, speedY en breedte een attribuut te maken dat read-only is.\nHet zou kunnen dat je wilt dat je de positie van een actor toch van buitenaf moet kunnen aanpassen, maar dat dit wil een positie moet zijn binnen de simulatie. Je legt het schrijven van x en y dus beperkingen op. Dat kan zo:\nsetX(x) { var validX = x; if (validX \u003c 0) { validX = 0; } if (validX \u003e width) { validX = width; } this.#x = validX; } setY(y) { // constrain zorgt er net zoals de code onder setX voor // dat een variabele binnen een bepaald bereik valt. this.#y = constrain(y, 0, height); } De code onder setX en setY werkt hetzelfde, maar bij setY wordt gebruik gemaakt van de p5js-functie constrain , wat heel veel regels code scheelt! Wil je een actorobject een andere x-waarde geven? Dan kan dat zo: mensA.setX(145)\nEen methode die schrijftoegang tot een attribuut regelt, heet een setter. De werkwijze waarbij je toegang tot de gegevens van een object beperkt en de toegang principieel bij het object zelf legt, heet inkapseling (Engels: encapsulation). Deze techniek is erg belangrijk bij objectgeoriënteerd programmeren voorkomt allerlei ongewenst gebruik van klassen.\nWanneer je de simulator runt, zul je erachter komen dat de besmettingen niet meer werken. Dit komt doordat de code in update die de besmettingen ‘regelt’, geen waarde in #isBesmet kan schrijven. We kunnen dit regelen door in Actor een setter setIsBesmet(besmet) te maken:\nsetIsBesmet(besmet) { this.#isBesmet = besmet; } Maar dan hebben we opnieuw het probleem dat ook een dokterobject op deze manier besmet kan raken! Dit is echter gemakkelijk op te lossen. We definiëren ook in de klasse Dokter de methode setIsBesmet(besmet), waardoor bij de aanroep hiervan op een dokterobject deze code wordt uitgevoerd:\nsetIsBesmet(besmet) { this.#isBesmet = false } Hoofdstuk 4 - C++, polymorfie, voordelen en nadelen Je hebt nu op een redelijk niveau objectgeoriënteerd leren programmeren in JavaScript. Zoals eerder gezegd heb je, misschien zonder dat je het wist, ook al in C++ object georiënteerd geprogrammeerd. Neem bijvoorbeeld het gebruik van de Seriële Communicatie tussen je Arduino en de computer. Een heel simpel Arduinoprogramma dat elke seconde een berichtje stuurt, ziet er zo uit:\nvoid setup() { Serial.begin(9600); } void loop() { Serial.println(\"Dit is een bericht\"); delay(1000); } Serial is een object dat de Arduinosoftware aanmaakt om ons, eenvoudige programmeurs, toegang te geven tot seriële communicatie. Dit object heeft onder andere de methodes begin en println. (Hoewel Arduino zelf de naam van enkele objecten met een hoofdletter begint, houden wij ons aan de afspraak dat klassennamen met een hoofdletter beginnen en objectnamen met een kleine letter.)\nEn als je al eens een servomotor hebt aangestuurd, herken je hieronder ook objectgeoriënteerde code:\n#include \u003cServo.h\u003e Servo mijnServo; void setup() { mijnServo.attach(9); } void loop() { mijnServo.write(0); delay(500); mijnServo.write(180); delay(500); } Nu je weet hoe je klassen en objecten in JavaScript maakt, is het gemakkelijk om te leren hoe dit in C++ werkt. Hierbij maken we één belangrijke versimpeling, wanneer je klassen in losse bestanden aanlevert, moet dit verdeeld worden in twee bestanden. Eén bestand is de header file, eindigend op .h, die beschrijft welke attributen en methodes de klasse heeft en of het een superklasse heeft. Het andere bestand, eindigend op .cpp, bevat de programmeercode. Wij stoppen de code van een klasse echter voor het gemak in één bestand.\n#include \u003cArduino.h\u003e class Stoplicht { private: int toestand; int pinRood; int pinOranje; int pinGroen; void update() { if (this-\u003etoestand == this-\u003eROOD) { digitalWrite(this-\u003epinRood, HIGH); } else { digitalWrite(this-\u003epinRood, LOW); } // je kunt het ook korter schrijven: digitalWrite(this-\u003epinOranje, this-\u003etoestand == this-\u003eORANJE); digitalWrite(this-\u003epinGroen, this-\u003etoestand == this-\u003eGROEN); } public: // constante klasse attributen static const int GROEN = 0; static const int ORANJE = 1; static const int ROOD = 2; Stoplicht(int newPinRood, int newPinOranje, int newPinGroen) { // neem de opgegeven pinNummers over this-\u003epinRood = newPinRood; this-\u003epinOranje = newPinOranje; this-\u003epinGroen = newPinGroen; // maak van de pinnen OUTPUTs pinMode(this-\u003epinRood, OUTPUT); pinMode(this-\u003epinOranje, OUTPUT); pinMode(this-\u003epinGroen, OUTPUT); this-\u003etoestand = GROEN; } void rood() { this-\u003etoestand = ROOD; } void oranje() { this-\u003etoestand = ORANJE; } void groen() { this-\u003etoestand = GROEN; } int getToestand() { return this-\u003etoestand; } }; Je hebt gezien dat C++ ook gebruik maakt van de . om attributen en methodes van objecten aan te spreken. Bij this wordt echter -\u003e gebruik. Het voert te ver om precies uit te leggen waarom dit is. Het gebruik van this is in C++ echter niet verplicht. Je zult daarom ook vaker code tegenkomen zoals hieronder, waarbij de gewoonte is dat men private attributen laat beginnen met een _:\n#include \u003cArduino.h\u003e class Stoplicht { private: int _toestand; int _pinRood; int _pinOranje; int _pinGroen; void update() { if (_toestand == ROOD) { digitalWrite(_pinRood, HIGH); } else { digitalWrite(_pinRood, LOW); } // je kunt het ook korter schrijven: digitalWrite(_pinOranje, _toestand == ORANJE); digitalWrite(_pinGroen, _toestand == GROEN); } public: // constante klasse attributen static const int GROEN = 0; static const int ORANJE = 1; static const int ROOD = 2; Stoplicht(int newPinRood, int newPinOranje, int newPinGroen) { // neem de opgegeven pinNummers over _pinRood = newPinRood; _pinOranje = newPinOranje; _pinGroen = newPinGroen; // maak van de pinnen OUTPUTs pinMode(_pinRood, OUTPUT); pinMode(_pinOranje, OUTPUT); pinMode(_pinGroen, OUTPUT); _toestand = GROEN; } void rood() { _toestand = ROOD; update(); } void oranje() { _toestand = ORANJE; update(); } void groen() { _toestand = GROEN; update(); } int getToestand() { return _toestand; } }; Je mag zelf kiezen welke stijl je het meest aanspreekt, als je maar consistent bent.\nHet aanmaken van een stoplichtobject gebeurt als volgt:\nStoplicht lichtA(9, 10, 11);\nDeze regel code roept de constructor van de klasse Stoplicht aan met 9, 10 en 11 als waarden voor de pinnen van resp. het rode, oranje en groene licht.\nEen aantal zaken valt op:\nDe toegang wordt geregeld met de gedeelten public en private. Niet alleen attributen, maar ook methoden kunnen private zijn. De enige publieke methoden zijn rood, oranje en groen en de getter van _toestand. De methode update is private. Het aanpassen van de status van de pinnen wordt gedaan naar aanleiding van het aanroepen van rood, oranje of groen, maar hoeft niet door ’een ander’ te gebeuren. De constructor draagt de naam van de klasse. C++ is een sterk getypeerde (Engels: strongly typed) taal, dus attributen hebben een type en de methoden hebben een teruggeefwaarde (behalve de constructor) De ; na de klasse declaratie is noodzakelijk. Subclassing in C++ gaat (in eenvoudige vorm) vrijwel hetzelfde als in JavaScript:\nclass Lamp { private: bool _pin bool _isAan; public: Lamp(int newPin) { _isAan = false; pinMode(_pin, OUTPUT); } void zetAan() { _isAan = true; } void zetUit() { _isAan = false; } // voer in elke loop deze methode uit void update() { digitalWrite(_pin, _isAan); } }; class KnipperLamp : public Lamp { private: int _wachtTijd; unsigned long _veranderTimer; public: KnipperLamp(int newPin, int newWachtTijd) : Lamp(newPin) { _wachtTijd = newWachtTijd; _veranderTimer = millis() + _wachtTijd; } void update() { if (millis() \u003e _veranderTimer) { _isAan = !_isAan; _veranderTimer = millis() + _wachtTijd; } Lamp :: update(); } int getWachtTijd() { return _wachtTijd; } } Polymorfisme Stel, we hebben een aantal lampobjecten en knipperlampobjecten waarop we met behulp van een for-loop update willen aanroepen. De inhoud van een array moet in C++ van hetzelfde soort zijn, dus alleen ints, floats, of objecten van dezelfde klasse. Moeten we voor lampen en knipperlampen dan misschien twee afzonderlijke arrays maken? Nee, dat is niet noodzakelijk. Omdat Knipperlamp een subklasse is van Lamp, voldoet deze daarmee ook aan alle eigenschappen van Lamp. De volgende code is dus geldig:\n// een array met zowel lamp- als knipperlampobjecten Lamp lampen[] = { Lamp(3), KnipperLamp(9, 500), Lamp(5) } void setup() { lampen[0].zetAan(); lampen[1].zetAan(); // de laatste lamp laten we uit } void loop() { for (int i = 0; i \u003c lampen.length(); i++\u003e) { Lamp l = lampen[i]; l.update(); } } Laten we stap voor stap de for-loop hierboven doorlopen: We weten zeker dat er objecten in de array lampen objecten zitten die Lamp als klasse of superklasse hebben. We kunnen kunnen er dus vanuit gaan dat deze objecten de objecten en methoden hebben zoals die in Lamp staan.\ni = 0 l wordt behandeld als lampobject en is dat ook (het eerste element van de array lampen). De aanroep l.update() laat de methode update van de klasse Lamp uitvoeren.\ni = 1 l wordt behandeld als lampobject, maar is eigenlijk een knipperlampobject (het tweede element van de array lampen). De aanroep van l.update() laat de methode update van de klasse KnipperLamp uitvoeren.\ni = 2 Gaat net zoals bij i=0, maar dan voor het laatste object van lampen.\nDe aanroep van update kan, omdat we zeker weten dat de objecten in de array lampen die methode hebben. Omdat één van die objecten echter een subklasse van Lamp is, (namelijk KnipperLamp) die een eigen implementatie van update heeft, wordt in dat geval die code uitgevoerd. In principe hoeven we hier echter helemaal geen rekening mee te houden. In de for-loop mag je uitgaan van lamp-objecten.\nWanneer een object / functie / methode in verschillende scenario’s zich anders gedraagt, spreken we in de informatica van polymorfisme. Je komt dit ook op andere manieren tegen. De operator + kan in C++ zowel gebruikt worden om integers bij elkaar op te tellen, maar ook om strings aan elkaar vast te plakken.\nVoor- en nadelen van objectgeoriënteerd programmeren Objectgeoriënteerd programmeren is al tientallen jaren een populaire programmeerparadigma. Dit komt omdat deze manier van programmeren een aantal voordelen heeft die het erg aantrekkelijk maken.\nVoordelen Modulariteit Objectgeoriënteerd programmeren vereist dat een programma in modules wordt opgebouwd. Dit al handig bij kleine programma’s, maar werkt geweldig bij grote systemen die door hun omvang door uit verschillende deelsystemen bestaat die elk door andere personen of teams worden ontwikkeld. Bij objectgeoriënteerd programmeren kun je, als eenmaal is vastgelegd welke methode een klasse heeft, deze onafhankelijk van andere klassen implementeren.\nInkapseling In eerdere vormen van programmeren was het deels mogelijk om een programma in modules te ontwikkelen, maar data was dan gemakkelijk toegankelijk voor allerlei delen van de programmacode, ook delen die de data niet zouden mogen veranderen.\nDoor inkapseling van gegevens binnen klasse is het gemakkelijker om deze gegevens te ‘beschermen’. Ze zijn ontoegankelijk voor andere stukken programmeercode en daardoor is het gemakkelijker om regels over de data (zoals dat een waarde nooit kleiner mag zijn van 0) af te dwingen.\nFlexibel hergebruik Het is met behulp van objectgeoriënteerd programmeren erg gemakkelijk om code opnieuw te gebruiken in een andere context. Het principe van overerving speelt hierbij een belangrijke rol. Algemene eigenschappen van een klasse definieer je in een superklasse, specifieke eigenschappen in een subklasse. De subklassen gebruik je dan op verschillende plekken in je programma, of zelfs over meerdere programma’s. Hierdoor hoef je de algemene code maar één keer te schrijven en hergebruik je deze code dus telkens als je een subklasse gebruikt.\nNadelen Objectgeoriënteerd programmeren heeft echter ook een aantal nadelen. Of, beter gezegd: Er is ook wel wat af te dingen van dit mooie programmeerparadigma:\nObjectgeoriënteerd programmeren is moeilijk en kost veel tijd om een goed objectgeoriënteerd ontwerp te maken Het uitvoeren van een objectgeoriënteerd programma kost meer computerkracht en -geheugen dan de oudere manieren van programmeren. Er is sprake van meer overhead. Andere vormen van programmeren (zoals procedureel, functioneel of logisch programmeren) bieden voor bepaalde problemen een veel betere oplossing dan objectgeorienteerd programmeren. ","description":"","tags":null,"title":"T8 Theorie objectgeoriënteerd programmeren 2324","uri":"/theorie/objectoriented_theorie2324/"},{"content":"Inleiding Om te leren hoe je objectgeoriënteerd programmeert, gaan we stap voor stap een objecgeoriënteerd programma maken. We maken hiervoor een epidemiesimulator die visueel maakt hoe organismen elkaar kunnen besmetten met een ziekteverwekker. Tussen de opdrachten door vind je theorie over objectgeoriënteerd programmeren.\nOpdracht 0 - Klaar voor de start Start een eigen repo en begrijp de code: Ga naar GitHub classroom en schrijf je in voor de opdracht ‘Epidemiesimulator’ Bekijk in je browser wat de simulator nu al doet. De simulator doet nog niet veel: het laat een vierkantje bewegen en stuiteren tegen de randen van het scherm. Bekijk de code van de simulator. In de code zie je globale variabelen die de positie en de horizontale en verticale snelheid bevatten. Ook zie je de constante BREEDTE, die de waarde van de grootte van het vierkantje bevat. var x; var y; var speedX; var speedY; const BREEDTE = 20; In setup krijgen deze variabelen hun initiële waarde. De positie is in het midden van het canvas. (Het midden van het vierkant is overigens niet exact in het midden. De waarden x en y worden gebruikt voor de linkerbovenhoek…) De horizontale en verticale snelheid krijgen bij de start een random waarde tussen -5 en 5.\nx = width / 2; y = heigth / 2; speedX = random(-5, 5); speedY = random(-5, 5); In draw wordt netjes een wit vierkantje getekend met behulp van de waarden van x, y en BREEDTE. Herinner je je nog dat de functie rect een vierkant tekent met de linkerbovenhoek op de meegeven positie?\nrect(x, y, BREEDTE, BREEDTE); Lees nu hoofdstuk 1 van de theorie Opdracht 1 – 25 random ‘mensen’ maken. En wat doen die katten daar? 😼 In de theorie van hoofdstuk 1 is een heel groot deel van de klasse Mens gegeven. Je maakt deze klasse verder af en gebruikt deze om 25 mensobjecten te maken die zich in onze simulatie bewegen:\nProgrammeren a) 25 random mensen We gaan nu de array mensen vullen met 25 random mens-objecten. Verwijder de code die je bij opdracht 2 in setup hebt gezet om handmatig 5 mens-objecten te maken. Schrijf in plaats daarvan deze code:\n// maak 25 random mensen for (var teller = 0; teller \u003c 25; teller++) { // we moeten ze niet te dicht bij de rand tekenen // om geen problemen met stuiteren te krijgen var ruimteTotRand = 50; // creëer random positie en snelheid var randomX = random(ruimteTotRand, width - ruimteTotRand); var randomY = random(ruimteTotRand, height - ruimteTotRand); var randomSpeedX = random(-5, 5); var randomSpeedY = random(-5, 5); // maak nieuw mensobject var nieuwMens = new Mens(randomX, randomY, randomSpeedX, randomSpeedY); // voeg mensobject toe aan array mensen.push(nieuwMens); } Deze code maakt 25 keer een nieuw mens-object met random waarden aan en voegt deze toe aan de array mensen. Zorg ervoor dat je deze regels begrijpt. Uitleg over push vind je onder andere op de shite van w3schools Bekijk het resultaat. Als het goed is, heb je nu 25 vierkantjes die door elkaar heen vliegen en tegen de randen stuiteren.\nControleer je code b) besmettingen Het wordt tijd dat deze mensen elkaar kunnen besmetten. Het idee is dat mensen elkaar besmetten als ze elkaar in hun beweging overlappen.\nGeef de klasse Mens een nieuw attribuut isBesmet. Dit attribuut initialiseer je in de constructor op false. Je hoeft hiervoor dus geen argument aan je constructor toe te voegen. Hint Bovenin de class Mens, onder speedY, schrijf je isBesmet; In de constructor typ je onder de regel this.speedY = speedY: this.isBesmet = false;\nDaar heb je dus geen extra informatie voor nodig die meegegeven zou moeten worden aan de constructor. Het is gewoon altijd false als een mens-object wordt aangemaakt.\nVoeg in setup, na de for-loop die de 25 mensen aanmaakt, deze regel code toe:\nmensen[0].isBesmet = true; Hierdoor wordt alvast één mens besmet.\nVerander de code in de methode show zo, dat een mens als rood vierkant wordt getekend als deze besmet is. Als het goed is, wordt één vierkant nu rood getekend. Hint Als isBesmet waar is, moet er iets anders getekend worden dan wanneer isBesmet onwaar is. Gebruik hiervoor een if-statement.\nVervolgens maken we een methode die kan controleren of een ander mens-object overlap heeft met het object dat de methode uitvoert. Ga voor jezelf na of je de volgende zin begrijpt: Omdat een mens getekend wordt als een vierkant, overlappen twee mensen elkaar als één van de hoeken van het ene vierkant zich binnen de randen van het andere vierkant bevindt. Onderstaande code bevat het begin van de methode isOverlappend. Voeg deze code toe aan de klasse Mens.\nisOverlappend(andereMens) { // zet teruggeefwaarde standaard op false var overlappend = false; // zet teruggeefwaarde op true als er een overlap is if ( (this.x + this.breedte \u003e= andereMens.x \u0026\u0026 this.x \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y + this.breedte \u003e= andereMens.y \u0026\u0026 this.y \u003c= andereMens.y + andereMens.breedte) ) { overlappend = true; } // stuur de teruggeefwaarde terug return overlappend; } Uitleg Pak een vel papier en teken twee vierkantjes: één voor ’this’, één voor ‘andereMens’. Schrijf bij de randen van de vierkanten welke waarden daarbij horen. De bovenrand van ‘andereMens’ hoort bijvoorbeeld bij andereMens.y.\nAls je dit voor alle 8 zijden hebt gedaan, teken de vierkantjes dan eens zo, dat het vierkant van ’this’ met de linkerbovenhoek in het vierkant van ‘andereMens’ zit. Probeer nu te kijken of je de code in het if-statement hierboven kunt begrijpen.\nNu moeten we in draw code toevoegen die alle mogelijke paren van mensobjecten controleert of ze overlappen. Indien ze overlappen, controleren we of een van die objecten besmet is. Als dat zo is wordt het andere ook besmet (als het dat nog niet is). Een simpele manier om dit te controleren is in een for-loop ieder object te controleren met ieder ander object, behalve zichzelf. Dit ziet er zo uit: // ga alle mensen langs for (var i = 0; i \u003c mensen.length; i++) { var mensA = mensen[i]; // ga met mensA opnieuw alle mensen langs om te checken op overlap, behalve met zichzelf for (var j = 0; j \u003c mensen.length; j++) { var mensB = mensen[j]; if (mensA != mensB) { // check overlap var mensenOverlappen = mensA.isOverlappend(mensB); if (mensenOverlappen) { // check of er een besmetting optreedt if (mensA.isBesmet || mensB.isBesmet) { // als er één besmet is, wordt ze allebei besmet // als ze allebei besmet zijn, verandert deze code niets. mensA.isBesmet = true; mensB.isBesmet = true; } } } } } Ga de code eens regel voor regel af en leg aan jezelf (of je buur) uit wat hier gebeurt.\nControleer je code c) katten… 🐈 Helaas komen de gezondheidsinstanties erachter dat ook katten een rol spelen in de verspreiding van de ziekte. We zullen ook deze moeten opnemen in onze simulatie.\nDe array mensen gaat ook dieren bevatten. Het is raar als deze naam hetzelfde blijft. Alle ‘dingen’ die iets in onze simulatie doen, heten ‘actoren’. Verander door je hele code de naam van de array mensen in actoren. Dat kan in GitPod heel handig: Zoek de regel waar je de mensen als globale variabele declareert. Waarschijnlijk staat er var mensen;. Klik met de rechtermuisknop op mensen en kies in het menu dat verschijnt ‘Rename Symbol’. Wanneer je op deze manier de naam wijzigt, wordt de naam van deze variabele overal gewijzigd. Wel moet je nog even door de comments gaan om te zien of je ook daar misschien ‘mensen’ moet wijzigen in ‘actoren’\nMaak onder de klasse Mens een nieuwe klasse met de naam Kat. Laat deze precies hetzelfde doen als Mens, maar met deze verschillen:\nde breedte van een kat is 10 pixels een niet-besmette kat is blauw in plaats van wit een besmette kat is oranje in plaats van rood Voeg in setup na de 25 mensen ook 10 katten toe aan de simulatie. Geef de katten een random snelheid tussen -2 en 2. Hint Je kunt hiervoor even snel de for-loop die je voor de 25 mensen gebruikt, kopiëren en direct daaronder plakken en aanpassen naar 10 katten.\nControleer je code Lees nu hoofdstuk 2 van de theorie Opdracht 4 In de theorie van hoofdstuk 2 heb je de gezien hoe de code van de superklasse Actor eruit ziet. Je gaat nu de code van Mens en Kat aanpassen.\nProgrammeren a)\nVoeg, zoals in de theorie voorgedaan, de klasse Dokter toe aan je code en voeg 1 dokterobject toe aan de actoren. Controleer of de dokter verschijnt en anderen geneest. Controleer je code b)\nMaak Mens en Kat subklassen van Actor. Bedenk goed welke code weg mag en welke code veranderd moet worden. Eén methode blijft onveranderd. Weet je welke? Hint De methode show van Actor moet leeg blijven, omdat we Actor abstract maken. Dus de tekencode van show moet in subklassen staan.\nHint Het is raar om in een abstracte klasse als Actor wel een breedte mee te geven. We definiëren breedte daarom wel in Actor, maar geven er geen waarde aan. Dat moet in de constructor van Mens en Kat gebeuren.\nControleer je code c)\nVervolgens gaan we de ‘statistieken’ van onze simulatie laten zien. De verantwoordelijkheid voor deze code ligt niet bij een van de actoren, maar bij het ‘raamwerk’ van de simulatie. Deze code schrijven we daarom in dit geval onder draw. Zorg dat je op die plek met behulp van de p5js-functie text twee regels in de linkerbovenhoek plaatst: een met het aantal onbesmette actoren en een met het aantal besmette actoren. Hint Tip: hiervoor moet je de array actoren doorlopen met een for-loop. Er is overigens al een for-loop die hier prima geschikt voor is.\nHint Je hebt variabelen nodig om de telling tijdelijk in op te slaan. Zou je kieen voor globale of lokale variabelen?\nControleer je code d)\nIedere actor die eenmaal besmet is, wordt in onze simulatie nooit meer beter, tenzij de dokter langskomt. Dat moet veranderen. Actoren moeten ook uit zichzelf weer beter kunnen worden. We gaan daarvoor een teller maken die bij besmetting voor een Mens begint bij 400 en voor een Kat begint op 200. Bij iedere aanroep van de methode update wordt de afteltimer 1 kleiner. Als de afteltimer 0 is, wordt het attribuut isBesmet weer op false gezet. Vraag jezelf hiervoor het volgende af: in welke klasse definieer je besmettelijkheidsTeller? hoe zorg je dat besmettelijkheidsTeller wordt ingesteld wanneer er een besmetting plaatsvindt? Tip: maak een methode besmet() die isBesmet op true zet EN de besmettelijkheidsTeller instelt. hoe maak je het verschil in gedrag tussen Mens en Kat? Als je het in kleine stapjes wilt doen: Maak het eerst werkend voor één klasse. Maak het daarna werkend voor de andere klasse. Verplaats waar mogelijk dubbele code naar Actor. wat gebeurt er met de besmettelijkheidsTeller als update wordt aangeroepen en de actor is niet besmet? wat gebeurt er met de besmettelijkheidsTeller als deze aan het aflopen is en er opnieuw contact is met een andere, besmette, actor? Controleer je code Speel gerust eens met de waarden van de besmettelijkheidsTeller of het aantal dokters om te zien wat er in je simulatie gebeurt.\nLees nu hoofdstuk 3 van de theorie opdracht 5 Programmeren In de theorie van hoofdstuk 3 is een heel aantal veranderingen genoemd. Verander je code zo, dat de genoemde attributen private worden en ze de juiste getters en setters hebben. Alle code staat nog in één bestand: script.js. Dit is niet handig als je code gemakkelijk herbruikbaar wilt maken. Daarom doen we het volgende: we maken voor iedere klasse een apart bestand aan, zoals actor.js, mens.js etc. je javascript wordt uitgevoerd binnen de HTML-pagina index.html. Het JavaScript-bestand wordt hierin netjes geladen. Nu we de code hebben verdeeld over meerdere bestanden, moeten we ook aangeven dat deze worden geladen. Voeg boven de regel: \u003cscript id=\"canvas\" src=\"script.js\"\u003e\u003c/script\u003e voor ieder bestand nieuwe regel toe zoals: \u003cscript src=\"actor.js\"\u003e\u003c/script\u003e Maak zelf een heel nieuwe actor voor de simulatie. Je mag zelf weten of het een directe subklasse van Actor, Mens, Kat of Dokter is, zolang je maar geen code in (één van de) superklassen gaat veranderen om jouw nieuwe klasse te laten werken. Zet deze code in een los bestand. Maak een volledig UML klassendiagram van de vijf klassen die in jouw simulatie voorkomen. Wissel met een klasgenoot jullie zelfbedachte actorklassen uit en neem deze op in je eigen simulatie. Als het goed is, heb je niet veel code nodig om dit voor elkaar te krijgen. Hint Wissel uit door:\nde bijbehorende bestanden elkaar te sturen. in je HTML bestand ook dit nieuwe bestand te laden. in je setup een zelfbedacht aantal van deze nieuwe klasse actoren op te nemen. Lees nu hoofdstuk 4 van de theorie Opdracht 6 In deze opdracht maak je een eigen klasse in C++. Kies uit de volgende twee klassen:\nEen klasse die twee LEDs om en om laat knipperen, dus als de waarschuwingslichten bij een spoorwegovergang. Deze lichten kunnen ook in zijn geheel uit staan. Een klasse die een knop uitleest. Bij het indrukken van de knop wisselt de status van het bebehorende object van aan naar uit en andersom. a) uitdenken Maak, met theorie van het hoofdstuk 4 in je achterhoofd, een beschrijving (d.w.z. een UML-schets en informele beschrijving van methoden) van de nieuwe klasse. Probeer uit hoever je kan bedenken wat er allemaal in de klasse moet komen.\nb) programmeren Maak in C++ de klasse zoals je die hebt bedacht. Test de klasse uit en pas aan waar nodig, totdat deze werkt zoals gevraagd. c) uitbreiden Heb je gekozen voor de waarschuwingslichten? Kun je het zo maken dat je de knippersnelheid kunt aanpassen? Op welke manier maak je deze eigenschap toegankelijk voor andere programmeurs? Heb je gekozen voor de knop. Kun je het zo maken dat de lichte storing die optreedt rond het indrukken van de knop weggefilterd wordt? Je noemt dit debouncen. Check deze voorbeeldcode voor een idee. ","description":"","tags":null,"title":"T8 Verwerkingsopdrachten","uri":"/theorie/objectoriented_simulator_opdrachten-backup/"},{"content":"Inleiding Om te leren hoe je objectgeoriënteerd programmeert, gaan we stap voor stap een objecgeoriënteerd programma maken. We maken hiervoor een epidemiesimulator die visueel maakt hoe organismen elkaar kunnen besmetten met een ziekteverwekker. Tussen de opdrachten door vind je theorie over objectgeoriënteerd programmeren.\nOpdracht 0 - Klaar voor de start Begrijp de code: Bekijk in je browser wat de simulator nu al doet. Je ziet 25 ‘mensen’, waarvan er één besmet is. Mensen kunnen elkaar nog niet besmetten.\nDe class Mens beschrijft de eigenschappen van een mens in onze simulator. Het wordt getekend als een vierkantje met een bepaalde kleur. Een mens heeft een bepaalde positie en snelheid, kan stuiteren tegen de randen en kan besmet zijn.\nIn setup worden 25 mens-objecten aangemaakt met random waarden. Deze objecten worden toegevoegd aan de array mensen. Bij het eerste element van de array wordt het attribuut isBesmet op true gezet.\nIn draw wordt netjes een wit vierkantje getekend met behulp van de waarden van this.x, this.y en this.breedte. Herinner je je nog dat de functie rect een vierkant tekent met de linkerbovenhoek op de meegeven positie?\nOpdracht 1 - Maak een dokter Voeg een dokter toe aan de simulatie. Een dokter is een speciaal soort mens. In deze opdracht zullen we alleen nog maar bezig zijn met het uiterlijk van de Dokter: wit met een rood kruis (+). Deze kun je tekenen als twee dikke lijnen, met behulp van line(x, y, w, h) .\nMaak hiervoor onder de class Mens een nieuwe class Dokter. Pas de theorie van overerving zo goed mogelijk toe. Voeg deze code toe aan het einde van de setup, om zo een dokter-object aan te maken en toe te voegen aan de array met mens-objecten.\nvar dokter = new Dokter(400, 200, 5, 5); mensen.push(dokter); ","description":"","tags":null,"title":"T8 Verwerkingsopdrachten","uri":"/theorie/objectoriented_simulator_opdrachten2425/"},{"content":"Inleiding Om de overstap naar objectgeoriënteerd programmeren te maken, beginnen we met een puur imperatief programma en werken we dit stap voor stap uit naar een objectgeoriënteerd programma. We maken hiervoor een epidemiesimulator die visueel maakt hoe organismen elkaar kunnen besmetten met een ziekteverwekker. Tussen de opdrachten door vind je theorie over objectgeoriënteerd programmeren.\nIs het programmeren een beetje weggezakt? Kijk dan eerst nog eens op Khan Academy en gebruik gerust het syntaxblad .\nOpdracht 0 - Klaar voor de start Start een eigen repo en begrijp de code: Ga naar het GitHub-repository ‘ OOP-template ’. Log in bij GitHub en gebruik de knop Use Template om een kopie hiervan te maken in je eigen GitHub account. Maak van jouw repo een workspace in GitPod. Pin deze workspace in je GitPod Dashboard als je dat handig vindt, zo wordt deze niet automatisch door GitPod verwijderd. De code doet nog niet veel: het laat een vierkantje bewegen en stuiteren tegen de randen van het scherm. In de code zie je globale variabelen die de positie en de horizontale en verticale snelheid bevatten. Ook zie je de constante BREEDTE, die de waarde van de grootte van het vierkantje bevat.\nvar x; var y; var speedX; var speedY; const BREEDTE = 20; In setup krijgen deze variabelen hun initiële waarde. De positie is in het midden van het canvas. (Het midden van het vierkant is overigens niet exact in het midden. De waarden x en y worden gebruikt voor de linkerbovenhoek…) De horizontale en verticale snelheid krijgen bij de start een random waarde tussen -5 en 5.\nx = width / 2; y = heigth / 2; speedX = random(-5, 5); speedY = random(-5, 5); In draw wordt netjes een wit vierkantje getekend met behulp van de waarden van x, y en BREEDTE. Herinner je je nog dat de functie rect een vierkant tekent met de linkerbovenhoek op de meegeven positie?\nrect(x, y, BREEDTE, BREEDTE); Opdracht 1 – Meerdere mensen Je simulatie-omgeving bestaat nu uit één mens. Er zijn er natuurlijk meer nodig. Hiervoor hebben we niet één x, y, speedX en speedY nodig, maar meerdere. Je kunt dit in je programma voor elkaar krijgen door te werken met arrays. Voor ieder mens staat er in de verschillende arrays een waarde. Dezelfde mens heeft z’n waarde steeds op dezelfde plek / index van de arrays. Dus voor de x- en y posities van 3 mensen zou je deze code kunnen gebruiken:\nxPosities = [130, 60, 470]; yPosities = [700, 1010, 40]; Ondersteuning Zie je niet helemaal voor je hoe bovenstaande techniek werkt? Maak eerst weer eens de opdracht Make it rain van KhanAcademy. Daar gebruiken ze deze techniek voor de x- en y-waarde van de regendruppels.\nProgrammeren Verander de namen van de globale variabelen zo, dat je ze herkent als een array. Dus bijv. xPosities in plaats van x, etc. Verander in setup de initiële waarden in arrays met ieder 5 waarden, zodat er vijf mensen getekend kunnen worden. Je mag voor nu zelf beslissen of je de waarden zelf bedenkt of ze random laat zijn. Hoe meer waarden je random laat zijn, hoe verrassender je simulator wordt. Verander in draw de code zo, dat je voor iedere mens: de positie verandert met de bijbehorende snelheden checkt of deze moet stuiteren Hint 1 Check nogmaals Make it rain als je hier niet uitkomt. Als je niet 100% begrijpt wat er in die opdracht wordt gedaan, kun je beter daar eerst aandacht aan besteden, anders blijft wat hieronder komt abracadabra.\nHint 2 Verander var x; in var xPosities;, en verzin voor de andere drie globale variabelen ook namen die je laten vermoeden dat het om een array met meerdere waarden gaat.\nVervolgens moet je in de setup die variabele niet één waarde meegeven, maar een array met vijf waarden, bijvoorbeeld xPosities = [192, 450, 800, 120, 75]. Doe dit ook voor de andere drie globale variabelen.\nJe hebt nu 4 arrays, met waarden die bij elkaar horen. Dus de waarden van element 0 uit alle vier de arrays vormen samen de waarden voor één mens. De informatie staat dus als het ware ‘verticaal’ in je code.\nHint 3 Je moet op de plek waar je de mensen tekent, update en laat stuiteren een for-loop gebruiken die dit nu op alle waarden van de arrays toepast:\nfor (var i = 0; i \u003c xPosities.length; i++) { // hier moet de code komen voor het tekenen, updaten en stuiteren // bedenk dat deze waarden in arrays staan. De variabele `i` kun je // gebruiken om steeds het volgende element te 'kiezen' } Hint 4 Deze tekencode in de for-loop werkt niet:\nfor (var i = 0; i \u003c xPosities.length; i++) { rect(xPosities, yPosities, BREEDTE, BREEDTE); // hieronder zou de update- en stuitercode moeten staan } Dat komt omdat rect een enkele waarde nodig heeft, en geen array met waarden. Dus bijvoorbeeld rect(xPosities[0], yPosities[0], BREEDTE, BREEDTE);\nMet deze code worden echter 5 keer dezelfde waarden gebruikt, namelijk die van element nul. Je zou willen dat iedere keer het volgende element uit de arrays gebruikt wordt. Toevallig hebben we in de for-loop een variabele die precies van 0 tot en met 4 gaat: i.\nDeze code werkt wel:\nfor (var i = 0; i \u003c xPosities.length; i++) { rect(xPosities[i], yPosities[i], BREEDTE, BREEDTE); // hieronder zou de update- en stuitercode moeten staan } Deze hint kun je ook toepassen op de update- en stuitercode.\nControleer je code Opdracht 2 – objecten De manier waarop je bij opdracht 1 de gegevens in arrays hebt gestopt werkt prima, maar is niet in overeenstemming met welke gegevens er volgens je gevoel bij elkaar horen: niet alle x-posities, y-posities, etc. horen bij elkaar, maar alle gegevens van 1 bepaald mens. Je zou eigenlijk willen dat je die gegevens bij elkaar zou kunnen zetten. Dat kan met behulp van objecten.\nProgrammeren Maak het gehele onderdeel Objects van Khan Academy. Dus van ‘Intro’ tot en met ‘Bookshelf’). Gebruik je opgedane kennis om in je Simulator in plaats van 4 arrays met losse waarden, 1 array genaamd mensen met objecten te maken: 5 objecten – voor iedere mens één. Zorg ervoor dat alles blijft werken. Hint 1 Verwijder boven de setup de declaratie van de vier globale variabelen en schrijf daar var mensen; Vervang in de setup de code waar je arrays met waarden aan die globale variabelen gaf en schrijf in plaats daarvan: mensen = [ {x: 320, y: 100, speedX : 2 speedY : -4}, {x: 500, y: 490, speedX : -3 speedY : 1}, // voeg hier ZELF nog 3 extra mensobjecten toe. // na het laatste object GEEN komma ]; Mensen wordt met deze code een array van objecten. Verander je teken-, update- en stuitercode ook zo dat deze past bij deze nieuwe vorm.\nHint 2 Voor de tekencode ziet de aanpassing er zo uit:\nfor (var i = 0; i \u003c mensen.length; i++) { rect(mensen[i].x, mensen[i].y, BREEDTE, BREEDTE); // hieronder zou de update- en stuitercode moeten staan } mensen[i].x betekent: van de array mensen het i-de element, en van het object dat je daarmee krijgt, attribuut x.\nProbeer zelf de code voor het updaten en stuiteren te maken.\nControleer je code Lees nu hoofdstuk 1 van de theorie Opdracht 3 – 25 random mensen maken. En wat doen die katten daar? 😼 In de theorie van hoofdstuk 1 is een heel groot deel van de klasse Mens gegeven. Je maakt deze klasse verder af en gebruikt deze om 25 mensobjecten te maken die zich in onze simulatie bewegen:\nProgrammeren a) 25 random mensen Neem de code van de class Mens uit de theorie over en plaats deze code nog boven je globale variabele(n).\nDe klasse Mens bevat alle code die nodig is om de positie van een mensobject te updaten. Verwijder deze code uit draw en roep in plaats daarvan update aan op het betreffende object. Hint 1 De code die speedX bij x optelt en speedY bij y hebben we verhuisd naar de class Mens. Die hebben we in draw niet meer nodig.\nHint 2 De code staat in de for-loop:\nmensen[i].x = mensen[i].x + mensen[i].speedX; mensen[i].y = mensen[i].y + mensen[i].speedY; Deze updatecode zit nu in de class Mens en mag dus weg.\nDe code die controleert of een mens tegen de rand van de simulatiewereld botst, moet ook verhuizen naar de klasse Mens. Breidt de methode update uit. Gebruik hiervoor de betreffende code die je in draw vindt en pas deze aan. Je kunt nu op de oude plek van de code de methode update() aanroepen. Hint 3 Bij de updatecode hoort niet alleen het geven van een nieuwe positie, maar ook het stuiteren. Haal deze code uit de for-loop en plaats deze in de methode update van de class Mens. Je moet het hiervoor nog wel even omvormen naar this enz.\nDe code die een mens tekent, is ook typisch iets wat bij de klasse Mens hoort. Maak een nieuwe methode show en teken hierin het vierkantje. Haal ook de constante BREEDTE weg. Maak hiervan een attribuut (gebruik dan breedte) en zet de waarde hiervan in de constructor op 50. Je hoeft hiervoor dus niet een argument aan de constructor toe te voegen. Verwijder de code die het vierkant tekent uit draw en roep in plaats daarvan show op de objecten aan.\nWe gaan nu de array mensen vullen met 25 random mens-objecten. Verwijder de code die je bij opdracht 2 in setup hebt gezet om handmatig 5 mens-objecten te maken. Schrijf in plaats daarvan deze code:\n// maak 25 random mensen for (var teller = 0; teller \u003c 25; teller++) { // we moeten ze niet te dicht bij de rand tekenen // om geen problemen met stuiteren te krijgen var ruimteTotRand = 50; // creëer random positie en snelheid var randomX = random(ruimteTotRand, width - ruimteTotRand); var randomY = random(ruimteTotRand, height - ruimteTotRand); var randomSpeedX = random(-5, 5); var randomSpeedY = random(-5, 5); // maak nieuw mensobject var nieuwMens = new Mens(randomX, randomY, randomSpeedX, randomSpeedY); // voeg mensobject toe aan array mensen.push(nieuwMens); } Deze code maakt 25 keer een nieuw mens-object met random waarden aan en voegt deze toe aan de array mensen. Zorg ervoor dat je deze regels begrijpt. Uitleg over push vind je onder andere op de shite van w3schools Bekijk het resultaat. Als het goed is, heb je nu 25 vierkantjes die door elkaar heen vliegen en tegen de randen stuiteren.\nControleer je code b) besmettingen Het wordt tijd dat deze mensen elkaar kunnen besmetten. Het idee is dat mensen elkaar besmetten als ze elkaar in hun beweging overlappen.\nGeef de klasse Mens een nieuw attribuut isBesmet. Dit attribuut initialiseer je in de constructor op false. Je hoeft hiervoor dus geen argument aan je constructor toe te voegen. Hint Bovenin de class Mens, onder speedY, schrijf je isBesmet; In de constructor typ je onder de regel this.speedY = speedY: this.isBesmet = false;\nDaar heb je dus geen extra informatie voor nodig die meegegeven zou moeten worden aan de constructor. Het is gewoon altijd false als een mens-object wordt aangemaakt.\nVoeg in setup, na de for-loop die de 25 mensen aanmaakt, deze regel code toe:\nmensen[0].isBesmet = true; Hierdoor wordt alvast één mens besmet.\nVerander de code in de methode show zo, dat een mens als rood vierkant wordt getekend als deze besmet is. Als het goed is, wordt één vierkant nu rood getekend. Hint Als isBesmet waar is, moet er iets anders getekend worden dan wanneer isBesmet onwaar is. Gebruik hiervoor een if-statement.\nVervolgens maken we een methode die kan controleren of een ander mens-object overlap heeft met het object dat de methode uitvoert. Ga voor jezelf na of je de volgende zin begrijpt: Omdat een mens getekend wordt als een vierkant, overlappen twee mensen elkaar als één van de hoeken van het ene vierkant zich binnen de randen van het andere vierkant bevindt. Onderstaande code bevat het begin van de methode isOverlappend. De methode controleert nog alleen voor de linkerbovenhoek. Voeg deze code toe aan de klasse Mens en voeg zelf de code toe die de andere drie hoeken van this controleert. Als je merkt dat het controleren van overlap moeilijk is, maak dan eerst de oefening Smarter Button van Khan Academy weer eens.\nisOverlappend(andereMens) { // zet teruggeefwaarde standaard op false var overlappend = false; // zet teruggeefwaarde op true als er een overlap is if ( (this.x \u003e= andereMens.x \u0026\u0026 this.x \u003c= andereMens.x + andereMens.breedte \u0026\u0026 this.y \u003e= andereMens.y \u0026\u0026 this.y \u003c= andereMens.y + andereMens.breedte) /* VUL HIER ZELF LATER AAN VOOR DE ANDERE HOEKEN*/ ) { overlappend = true; } // stuur de teruggeefwaarde terug return overlappend; } Hint Pak een vel papier en teken twee vierkantjes: één voor ’this’, één voor ‘andereMens’. Schrijf bij de randen van de vierkanten welke waarden daarbij horen. De bovenrand van ‘andereMens’ hoort bijvoorbeeld bij andereMens.y.\nAls je dit voor alle 8 zijden hebt gedaan, teken de vierkantjes dan eens zo, dat het vierkant van ’this’ met de linkerbovenhoek in het vierkant van ‘andereMens’ zit. Probeer nu te kijken of je de code in het if-statement hierboven kunt begrijpen.\nNu moeten we in draw code toevoegen die alle mogelijke paren van mensobjecten controleert of ze overlappen. Indien ze overlappen, controleren we of een van die objecten besmet is. Als dat zo is wordt het andere ook besmet (als het dat nog niet is). Een simpele manier om dit te controleren is in een for-loop ieder object te controleren met ieder ander object, behalve zichzelf. Dit ziet er zo uit: // ga alle mensen langs for (var i = 0; i \u003c mensen.length; i++) { var mensA = mensen[i]; // ga met mensA opnieuw alle mensen langs om te checken op overlap, behalve met zichzelf for (var j = 0; j \u003c mensen.length; j++) { var mensB = mensen[j]; if (mensA != mensB) { // check overlap var mensenOverlappen = mensA.isOverlappend(mensB); if (mensenOverlappen) { // check of er een besmetting optreedt if (mensA.isBesmet || mensB.isBesmet) { // als er één besmet is, wordt ze allebei besmet // als ze allebei besmet zijn, verandert deze code niets. mensA.isBesmet = true; mensB.isBesmet = true; } } } } } Ga de code eens regel voor regel af en leg aan jezelf (of je buur) uit wat hier gebeurt.\nControleer je code c) katten… 🐈 Helaas komen de gezondheidsinstanties erachter dat ook katten een rol spelen in de verspreiding van de ziekte. We zullen ook deze moeten opnemen in onze simulatie.\nDe array mensen gaat ook dieren bevatten. Het is raar als deze naam hetzelfde blijft. Alle ‘dingen’ die iets in onze simulatie doen, heten ‘actoren. Verander door je hele code de naam van de array mensen in actoren. Hint Zoek de regel waar je de mensen als globale variabele declareert. Waarschijnlijk staat er var mensen;. Klik met de rechtermuisknop op mensen en kies in het menu dat verschijnt ‘Rename Symbol’. Wanneer je op deze manier de naam wijzigt, wordt de naam van deze variabele overal gewijzigd. Wel moet je nog even door de comments gaan om te zien of je ook daar misschien ‘mensen’ moet wijzigen in ‘actoren’\nMaak onder de klasse Mens een nieuwe klasse met de naam Kat. Laat deze precies hetzelfde doen als Mens, maar met deze verschillen:\nde breedte van een kat is 10 pixels een niet-besmette kat is blauw in plaats van wit een besmette kat is oranje in plaats van rood Voeg in setup na de 25 mensen ook 10 katten toe aan de simulatie. Geef de katten een random snelheid tussen -2 en 2. Hint Je kunt hiervoor even snel de for-loop die je voor de 25 mensen gebruikt, kopiëren en direct daaronder plakken en aanpassen naar 10 katten.\nControleer je code Lees nu hoofdstuk 2 van de theorie Opdracht 4 In de theorie van hoofdstuk 2 heb je de gezien hoe de code van de superklasse Actor eruit ziet. Je gaat nu de code van Mens en Kat aanpassen.\nProgrammeren a)\nVoeg, zoals in de theorie voorgedaan, de klasse Dokter toe aan je code en voeg 1 dokterobject toe aan de actoren. Controleer of de dokter verschijnt en anderen geneest. Controleer je code b)\nMaak Mens en Kat subklassen van Actor. Bedenk goed welke code weg mag en welke code veranderd moet worden. Eén methode blijft onveranderd. Weet je welke? Hint De methode show van Actor moet leeg blijven, omdat we Actor abstract maken. Dus de tekencode van show moet in subklassen staan.\nHint Het is raar om in een abstracte klasse als Actor wel een breedte mee te geven. We definiëren breedte daarom wel in Actor, maar geven er geen waarde aan. Dat moet in de constructor van Mens en Kat gebeuren.\nControleer je code c)\nVervolgens gaan we de ‘statistieken’ van onze simulatie laten zien. De verantwoordelijkheid voor deze code ligt niet bij een van de actoren, maar bij het ‘raamwerk’ van de simulatie. Deze code schrijven we daarom in dit geval onder draw. Zorg dat je op die plek met behulp van de p5js-functie text twee regels in de linkerbovenhoek plaatst: een met het aantal onbesmette actoren en een met het aantal besmette actoren. Hint Tip: hiervoor moet je de array actoren doorlopen met een for-loop. Er is overigens al een for-loop die hier prima geschikt voor is.\nHint Je hebt variabelen nodig om de telling tijdelijk in op te slaan. Zou je kieen voor globale of lokale variabelen?\nControleer je code d)\nIedere actor die eenmaal besmet is, wordt in onze simulatie nooit meer beter, tenzij de dokter langskomt. Dat moet veranderen. Actoren moeten ook uit zichzelf weer beter kunnen worden. We gaan daarvoor een teller maken die bij besmetting voor een Mens begint bij 400 en voor een Kat begint op 200. Bij iedere aanroep van de methode update wordt de afteltimer 1 kleiner. Als de afteltimer 0 is, wordt het attribuut isBesmet weer op false gezet. Vraag jezelf hiervoor het volgende af: in welke klasse definieer je besmettelijkheidsTeller? hoe zorg je dat besmettelijkheidsTeller wordt ingesteld wanneer er een besmetting plaatsvindt? Tip: maak een methode besmet() die isBesmet op true zet EN de besmettelijkheidsTeller instelt. hoe maak je het verschil in gedrag tussen Mens en Kat? Als je het in kleine stapjes wilt doen: Maak het eerst werkend voor één klasse. Maak het daarna werkend voor de andere klasse. Verplaats waar mogelijk dubbele code naar Actor. wat gebeurt er met de besmettelijkheidsTeller als update wordt aangeroepen en de actor is niet besmet? wat gebeurt er met de besmettelijkheidsTeller als deze aan het aflopen is en er opnieuw contact is met een andere, besmette, actor? Controleer je code Speel gerust eens met de waarden van de besmettelijkheidsTeller of het aantal dokters om te zien wat er in je simulatie gebeurt.\nLees nu hoofdstuk 3 van de theorie opdracht 5 Programmeren In de theorie van hoofdstuk 3 is een heel aantal veranderingen genoemd. Verander je code zo, dat de genoemde attributen private worden en ze de juiste getters en setters hebben. Alle code staat nog in één bestand: script.js. Dit is niet handig als je code gemakkelijk herbruikbaar wilt maken. Daarom doen we het volgende: we maken voor iedere klasse een apart bestand aan, zoals actor.js, mens.js etc. je javascript wordt uitgevoerd binnen de HTML-pagina index.html. Het JavaScript-bestand wordt hierin netjes geladen. Nu we de code hebben verdeeld over meerdere bestanden, moeten we ook aangeven dat deze worden geladen. Voeg boven de regel: \u003cscript id=\"canvas\" src=\"script.js\"\u003e\u003c/script\u003e voor ieder bestand nieuwe regel toe zoals: \u003cscript src=\"actor.js\"\u003e\u003c/script\u003e Maak zelf een heel nieuwe actor voor de simulatie. Je mag zelf weten of het een directe subklasse van Actor, Mens, Kat of Dokter is, zolang je maar geen code in (één van de) superklassen gaat veranderen om jouw nieuwe klasse te laten werken. Zet deze code in een los bestand. Maak een volledig UML klassendiagram van de vijf klassen die in jouw simulatie voorkomen. Wissel met een klasgenoot jullie zelfbedachte actorklassen uit en neem deze op in je eigen simulatie. Als het goed is, heb je niet veel code nodig om dit voor elkaar te krijgen. Hint Wissel uit door:\nde bijbehorende bestanden elkaar te sturen. in je HTML bestand ook dit nieuwe bestand te laden. in je setup een zelfbedacht aantal van deze nieuwe klasse actoren op te nemen. Lees nu hoofdstuk 4 van de theorie Opdracht 6 In deze opdracht maak je een eigen klasse in C++. Kies uit de volgende twee klassen:\nEen klasse die twee LEDs om en om laat knipperen, dus als de waarschuwingslichten bij een spoorwegovergang. Deze lichten kunnen ook in zijn geheel uit staan. Een klasse die een knop uitleest. Bij het indrukken van de knop wisselt de status van het bebehorende object van aan naar uit en andersom. a) uitdenken Maak, met theorie van het hoofdstuk 4 in je achterhoofd, een beschrijving (d.w.z. een UML-schets en informele beschrijving van methoden) van de nieuwe klasse. Probeer uit hoever je kan bedenken wat er allemaal in de klasse moet komen.\nb) programmeren Maak in C++ de klasse zoals je die hebt bedacht. Test de klasse uit en pas aan waar nodig, totdat deze werkt zoals gevraagd. c) uitbreiden Heb je gekozen voor de waarschuwingslichten? Kun je het zo maken dat je de knippersnelheid kunt aanpassen? Op welke manier maak je deze eigenschap toegankelijk voor andere programmeurs? Heb je gekozen voor de knop. Kun je het zo maken dat de lichte storing die optreedt rond het indrukken van de knop weggefilterd wordt? Je noemt dit debouncen. Check deze voorbeeldcode voor een idee. ","description":"","tags":null,"title":"T8 Verwerkingsopdrachten","uri":"/theorie/objectoriented_verwerkingsopdrachten-backup/"},{"content":"Opdracht 1 en 2 Ga naar GitHub Classroom en kies daar de betreffende opdracht (over boeken)\nOpdracht 3 en 4 Ga naar GitHub Classroom en kies daar de betreffende opdracht (over dieren)\nOpdracht 5 en 6 Ga naar GitHub Classroom en kies daar de betreffende opdracht (over inkapseling en associatie)\nOpdracht 7 Pak papier of je iPad erbij.\na. Teken een UML diagram van een klasse ‘Auto’, met de volgende eigenschappen:\nIedere auto heeft een merk, type en snelheid. Iedere auto kan claxoneren (door “tuut” in de console te printen) Iedere auto kan de snelheid verhogen. Als dat wordt gedaan, wordt de snelheid 10 hoger. b. Teken een diagram met drie zelf verzonnen Auto-objecten.\nAntwoorden De antwoorden voor opdracht 1 t/m 6 vind je in dit GitHub repository .\n","description":"","tags":null,"title":"T8 Verwerkingsopdrachten","uri":"/theorie/objectoriented_verwerkingsopdrachten/"},{"content":"Je leert objectgeoriënteerd programmeren. Dat is een manier van programmeren waarbij data en logica gebundeld zijn in objecten.\nTheorie Theorie objectgeoriënteerd programmeren Lespresentatie Opdrachten Schrijf je in voor een opdracht en ga er mee aan de slag in GitHub code spaces.\nVerwerkingsopdrachten. Deze opdrachten zijn verplicht en maak je om de uitleg te verwerken Intekenen: 6V.in1 , 6V.in2 Wil je naast de verwerkingsopdrachten met een spelletje ervaren waarom objectgeoriënteerd programmeren handig werkt? Bouw het appelspel theorie en lespresentatie zelf na Intekenen: 6V.in1 , 6V.in2 Wel je echt ergens je tanden in kunnen zetten om objectgeoriënteerd te programmeren? Maak de epidemie simulator Intekenen: 6V.in1 , 6V.in2 Maak kennis met jOOP jOOP is je persoonlijke AI programmeerassistent tijdens de opdrachten Objectgeoriënteerd Programmeren. Hij helpt je stap voor stap bij het werken met klassen, objecten, overerving, inkapseling en associaties in JavaScript. jOOP geeft geen kant-en-klare oplossingen, maar stelt vragen, geeft hints en helpt je foutmeldingen begrijpen. Zo leer je zelf redeneren en groeien in OOP. Let wel op, tijdens de toets kan/mag je jOOP niet gebruiken.\nGebruik jOOP door hier te klikken Naslagmateriaal (ook beschikbaar bij toets) Naslagmateriaal objectgeoriënteerd programmeren Naslagmateriaal JavaScript en p5js Naslagmateriaal C++ en Arduino Leerdoelen Je weet wat het verschil is tussen een klasse en object. Je weet wat attributen en methodes van objecten zijn. Je weet wat inkapseling is. Je kunt uitleggen wat het verschil is tussen private en public attributen en methodes en dit principe toepassen. Je kunt op basis van een beschrijving in combinatie met stukje code beslissen welke attributen je private en welke je public zou maken. Je weet wat getter- en setter-methodes zijn. Je kunt een beargumenteerde keuze maken om voor een attribuut wel / niet gebruik te maken van getter en / of setter. Je kunt zelf code voor getter- en settermethodes maken. Je kunt uitleggen wat ‘overerving’ betekent en dit principe toepassen. Je begrijpt de termen superklasse en subklasse. Je begrijpt wat een abstracte klasse is. Je kunt in JavaScript objectgeoriënteerde code lezen en schrijven (eerdere kennis wordt verondersteld). Je kunt zelfstandig objectdiagrammen en (ontwerp)klassendiagrammen maken. Je kunt een ontwerpklassendiagram maken met behulp van een beschrijving van systeem. Je kunt een (ontwerp)klassendiagram omzetten naar JavaScript en andersom. Je bent hierbij in staat om relaties tussen klassen om te zetten naar code. Je kent drie voordelen en drie nadelen van objectgeoriënteerd programmeren. Oefentoets Oefentoets (vraag 5 moet je overslaan) Antwoordwoorden oefentoets Opfrissen Javascript Voor het geval Javascript een beetje is weggezakt, is dit een manier om alles weer op te frissen: Ga naar KhanAcademy en probeer steeds de projects aan het einde van iedere onderwerp helemaal opnieuw te maken (dus eerst resetten). Als je vastloopt, verdiep je dan eerst in de theorie van dat onderwerpje en / of probeer eerst een eenvoudiger oefenopdrachtje van dat onderwerp te maken.\nAnimal attack Fish tank Magic 8-ball Build-a-House Constellation maker Make it rain Vind je dit allemaal erg gemakkelijk? Open dan via deze link een leeg programma en programmeer een of meer van de volgende functies:\nfaculteit() - deze functie berekent de faculteit van de invoer. Dus 5! = 5 x 4 x 3 x 2 x 1 = 120 stippen vierkant - deze functie tekent een vierkant (eigenlijk: matrix) van 5 x 5 stippen met behulp van een geneste for-loop. Bonus: maak de functie zo, dat een parameter bepaald hoeveel stippen het vierkant breed is. isPalindroom() - deze functie controleert of de meegegeven tekst een palindroom is. Extra herhalings oefeningen + oplossing Of: - Opfrissen: zit Javascript er goed in en heb je meer uitdaging nodig dan de oefeningen op Khan Academy? Doe deze opdracht. Intekenen: 6V.in1 , 6V.in2 ","description":"","tags":null,"title":"T8. Objectgeoriënteerd Programmeren","uri":"/theorie/objectoriented/"},{"content":"Over de beveiliging van computers en data.\nTheorie Informatica Actief - Security en Privacy , theorie 1 t/m 3 Reader security , hoofdstuk 2 t/m 6 Handout lespresentaties Overig materiaal op deze pagina Naslagmateriaal toets Klik om te downloaden Uitlegvideo’s Onderstaande video’s horen niet bij de verplichte stof, maar kunnen wel helpen de stof te begrijpen of extra informatie geven als je meer wilt weten.\nAES-encryptie: de details Diffie Hellman m.b.v. verf Uitleg en mogelijkheden van public key cryptography Extra uitleg asymmetrische encryptie De wiskundige kant van RSA-encryptie Leerdoelen Thematisch geordend: Je kent in de context van security de principes confidentiality, integrity, availability, kunt deze uitleggen en toepassen op een casus.\nJe kunt uitleggen wat phishing is.\nJe kunt uitleggen wat social engineering is.\nJe kunt drie methoden om te hacken beschrijven.\nJe kunt uitleggen wat een dictionary attack is.\nJe kunt uitleggen hoe een botnet wordt opgezet en wat er mee wordt gedaan.\nJe kunt uitleggen wat authenticatie is.\nJe kunt de sterkte van wachtwoorden kunnen bepalen of vergelijken.\nJe kun aan de hand van een wachtwoordformaat uitrekenen hoeveel mogelijkheden maximaal moeten worden gecontroleerd in een brute force attack, zowel met als zonder gebruik van een dictionary. [46 + overig materiaal]\nJe kunt uitleggen wat two factor authentication (2FA) is.\nJe kunt werken met de analogie van Alice, Bob en Eve (of Chris).\nJe kunt uitleggen wat een ‘man-in-the-middle-attack’ is.\nJe kent de algemene kenmerken van een hash(functie).\nJe kunt een paar voorbeelden geven van populaire hash-algoritmen\nJe kent in de context van hashing de begrippen salting en collision\nJe kunt verschillende toepassingen van hashing uitleggen, zoals wachtwoordverificatie, het controleren van de authenticiteit van data of het identificeren van bestanden.\nJe kunt uitleggen welke de functies van een webcertificaat heeft en welke informatie het daarvoor bevat.\nJe weet welke stappen een browser uitvoert om een webcertificaat te controleren.\nJe weet wat een stamcertificaat / rootcertificate is.\nJe kunt de rol van certificaat-autoriteiten beschrijven.\nJe kunt uitleggen wat het verschil is tussen symmetrische en asymmetrische cryptografie en herkennen of een vorm van encryptie symmetrisch of asymmetrisch is.\nJe begrijpt hoe de versleuteling met behulp van (Caesar)substitutie werkt en je kunt er een boodschap mee versleutelen en ontcijferen\nJe begrijpt hoe de versleuteling met behulp van transpositie werkt en je kunt met behulp van een gegeven transpositiemethode een boodschap versleutelen en ontcijferen.\nJe begrijpt hoe de versleuteling met behulp van Vigenèresubstitutie werkt en je kunt er met een uitgeprinte hulptabel een boodschap mee versleutelen en ontcijferen.\nJe kunt uitleggen wat versleuteling met m.b.v. een one time pad (of: eenmalig blokcijfer) inhoudt en waarom deze manier van versleutelen, onder de juiste voorwaarden, niet te kraken is. Je kent deze voorwaarden.\nJe weet wat de (binaire) XOR-operatie is, op welke wijze deze een rol kan vervullen bij versleuteling en kunt deze operatie toepassen.\nJe kunt in grote lijnen uitleggen via welke vier stappen AES-encryptie werkt.\nJe weet hoe sleuteluitwisseling m.b.v. Diffie-Hellman plaatsvindt en kunt dit voordoen met gegeven getallen p en g.\nJe begrijpt hoe de versleuteling met behulp van RSA werkt en je kunt er met gegeven eenvoudige sleutels m.b.v. je grafische rekenmachine een boodschap mee versleutelen en ontcijferen.\nJe kunt met een gegeven getal p en q m.b.v. je grafische rekenmachine zelf een publiek en privé sleutelpaar genereren.\nJe kunt uitleggen welke twee functies encryptie met een public en private sleutelpaar heeft.\nJe kunt uitleggen welke stappen in de communicatie tussen browser en webserver plaatsvindt om een versleutelde verbinding tot stand te brengen.\nJe kunt uitleggen wat een cookie is en welke functie een cookie heeft.\nJe kunt het verschil tussen HTTP en HTTPS uitleggen.\nJe kunt aan de hand van de inhoud van een website beredeneren of het onverantwoord is om deze met behulp van HTTP te benaderen.\nBehorende bij reader Security met toegevoegd [paginanummer]: H2: Je kunt uitleggen wat authenticatie is. [44] Je kunt uitleggen wat two factor authentication (2FA) is. [44] Je kunt uitleggen hoe een botnet wordt opgezet en wat er mee wordt gedaan. [45] Je kunt de sterkte van wachtwoorden kunnen bepalen of vergelijken. [46] Je kun aan de hand van een wachtwoordformaat uitrekenen hoeveel mogelijkheden maximaal moeten worden gecontroleerd in een brute force attack, zowel met als zonder gebruik van een dictionary. [46 + overig materiaal] Je kunt uitleggen wat phishing is. [52] H3: Je kunt uitleggen wat social engineering is [55] Je kunt drie methoden om te hacken beschrijven. [59] Je kent in de context van security de principes confidentiality, integrity, availability, kunt deze uitleggen en toepassen op een casus. [61] Je kunt werken met de analogie van Alice, Bob en Eve (of Chris). [63] H4: Je begrijpt hoe de versleuteling met behulp van (Caesar)substitutie werkt en je kunt er een boodschap mee versleutelen en ontcijferen [65] Je begrijpt hoe de versleuteling met behulp van transpositie werkt en je kunt met behulp van een gegeven transpositiemethode een boodschap versleutelen en ontcijferen [66] Je begrijpt hoe de versleuteling met behulp van Vigenèresubstitutie werkt en je kunt er met een uitgeprinte hulptabel een boodschap mee versleutelen en ontcijferen. [72] H5 Je kunt uitleggen wat versleuteling met m.b.v. een one time pad (of: eenmalig blokcijfer) inhoudt en waarom deze manier van versleutelen, onder de juiste voorwaarden, niet te kraken is. Je kent deze voorwaarden. [76] Je weet wat de (binaire) XOR-operatie is, op welke wijze deze een rol kan vervullen bij versleuteling en kunt deze operatie toepassen [78] Je kunt in grote lijnen uitleggen via welke vier stappen AES-encryptie werkt. [80 + overig materiaal] H6 Je kunt het verschil tussen HTTP en HTTPS uitleggen. [86] Je kunt uitleggen wat het verschil is tussen symmetrische en asymmetrische cryptografie en herkennen of een vorm van encryptie symmetrisch of asymmetrisch is. [89] Je weet hoe sleuteluitwisseling m.b.v. Diffie-Hellman plaatsvindt en kunt dit voordoen met gegeven getallen p en g. [92] Je kunt uitleggen welke stappen in de communicatie tussen browser en webserver plaatsvindt om een versleutelde verbinding tot stand te brengen. [93] Je kunt aan de hand van de inhoud van een website beredeneren of het onverantwoord is om deze met behulp van HTTP te benaderen. [93] Je begrijpt hoe de versleuteling met behulp van RSA werkt en je kunt er met gegeven eenvoudige sleutels m.b.v. je grafische rekenmachine een boodschap mee versleutelen en ontcijferen. [94 + overig materiaal] Je kunt met een gegeven getal p en q m.b.v. je grafische rekenmachine zelf een publiek en privé sleutelpaar genereren. [overig materiaal] Je kunt uitleggen welke twee functies encryptie met een public en private sleutelpaar heeft. [94 + overig materiaal] Je kunt uitleggen wat een ‘man-in-the-middle-attack’ is. [96] Je kan uitleggen welke de functies van een webcertificaat heeft en welke informatie het daarvoor bevat. [97] Je weet welke stappen een browser uitvoert om een webcertificaat te controleren. [97] Je weet wat een stamcertificaat / rootcertificate is. [98] Je kunt de rol van certificaat-autoriteiten beschrijven. [100] Behorend bij overig materiaal: Je kunt uitleggen wat een cookie is en welke functie een cookie heeft. Je kent de kenmerken van verschillende soorten malware (virussen, wormen, Trojaans paard, ransomware). Je weet onder andere hoe ze zich verspreiden, en wat hun typische doel of effect is. Je kunt uitleggen wat een dictionary attack is. Je kent de algemene kenmerken van een hash(functie). Je kunt een paar voorbeelden geven van populaire hash-algoritmen Je kent in de context van hashing de begrippen salting en collision Je kunt verschillende toepassingen van hashing uitleggen, zoals wachtwoordverificatie, het controleren van de authenticiteit van data of het identificeren van bestanden. Oefenopgaven Oefenopgaven Uitwerkingen ","description":"","tags":null,"title":"T9. Security","uri":"/theorie/security/"},{"content":"Hier vind je een planning voor leerlingen die tijdens het vierde jaar willen overstappen naar informatica.\nOverstappen naar informatica We vinden het hartstikke leuk dat je voor informatica kiest. Als je tijdens de eerste helft van de vierde klas spijt hebt van je vakkenpakketkeuze en toch graag informatica wilt, dan kan dat heel vaak geregeld worden. Je moet er wel rekening mee houden dat je alle gemiste stof moet inhalen, dat vraagt behoorlijk wat zelfstandigheid.\nOm je overstap succesvol te laten zijn helpen we je op de volgende manier:\nTijdens het emc kunnen we je vragen beantwoorden en moeilijke stukjes nog eens uitleggen. Al het lesmateriaal vind je online. Voor T2 (informatica actief) heb je een code nodig die je van de docent krijgt. Voor de website heb je voorbeeldcode nodig die je van de docent krijgt. Bijna alle uitleg is op video te bekijken. Om je overstap succesvol te laten zijn stellen we de volgende regels. Deze gelden tot het moment dat je je achterstand hebt ingehaald:\nBij een dubbel rooster krijgen je informaticalessen voorrang. Je komt ten minste één emc-uur per week voor informatica. In de lessen doe je mee met de nieuwe stof, inhalen doe je thuis en tijdens emc. Reken op ongeveer 4 klokuur inhaalwerk per gemiste lesweek, een deel daarvan kun je in een vakantie doen. Planning als je overstapt voor de herfstvakantie Zorg dat je vóór de herfstvakantie in Magister bent ingedeeld bij een informatica lesgroep.\nGeschatte hoeveelheid inhaalwerk: 30 klokuren\nHerfstvakantie: T1 Webdesign inhalen (20 uur) Tussen herfstvakantie en TW1: deel T2 Informatie inhalen (5 uur) Tussen TW1 en kerstvakantie: deel O1 Webdesign inhalen (5 uur) Toetsen en inlevermomenten\nAlle toetsen en inlevermomenten zijn gelijk aan die van de andere 4h en 4v leerlingen. Planning als je overstapt voor de kerstvakantie Zorg dat je vóór de kerstvakantie in Magister bent ingedeeld bij een informatica lesgroep.\nGeschatte hoeveelheid inhaalwerk: 60 klokuren\nKerstvakantie: T1 Webdesign inhalen (20 uur) Lesweken tussen kerstvakantie en voorjaarsvakantie: T2 Informatie inhalen (15 uur) Lesweken tussen kerstvakantie en voorjaarsvakantie plus de voorjaarsvakantie: O1 Webdesign inhalen (10 uur in de weken voor de voorjaarsvakantie, 15 uur tijdens de voorjaarsvakantie) Toetsen en inlevermomenten\nTW1: de lesstof moet geleerd worden, omdat die nodig is voor de rest van de vierde klas. De toets zelf wordt pas afgenomen op het eerstvolgende moment dat die gegeven wordt.De leerling regelt dit in de vijfde klas via de informaticadocent. Indien de toets samen valt met een andere toets, dan krijgt de informaticatoets voorrang en regelt de leerling via de coördinator een inhaalmoment voor de andere toets.\nJe maakt deze toets dus pas in TW1 van de vijfde klas. TW2: reguliere moment PO website: 1 week voor start van toetsweek 2 (na de voorjaarvakantie). ","description":"","tags":null,"title":"4hv inhaalprogramma","uri":"/planning/inhalenprogramma/"},{"content":" Inloggen met Google\n❗️ Voordat je start Ga naar Replit met de volgende link:\nhttps://replit.com/@Krisvan1/ObjectOrientedProgramming Fork de repository. Maak eventueel een account aan als je die nog niet hebt.\nElke opdracht kan je zelf testen door op de “Run” knop te drukken.\nTIP: Je kan ook checken of je opdracht echt klopt door de Unit tests te runnen. Deze vind je of recht naast je console of links onder bij Tools.\nTIP: Onderaan deze pagina staat een cheat-sheet voor de syntax van JavaScript.\n📦️ Classes Opdracht 1: Maak een object Creëer een object genaamd book dat de volgende eigenschappen heeft: title, author, en pages. Print de title en author van het boek naar de console. Opdracht 2: Maak een array van objecten. Creëer een array genaamd books die meerdere boekobjecten bevat. Elk boekobject moet de eigenschappen title, author, en pages hebben. Loop door elk boek in de array en print de title en author naar de console. Opdracht 3: Maak een class. Maak een class genaamd Book met eigenschappen: title, author, en pages. Deze class moet ook een methode hebben genaamd printDetails die de title en author van het boek print. Creëer een boek van deze class, noem het myBook, en roep de printDetails methode aan. TIP:: Je kan een methode aanroepen door de naam van de class te gebruiken, gevolgd door een punt en de naam van de methode. Bijvoorbeeld: myBook.printDetails()\nOpdracht 4: Maak een array van class-instanties. Creëer een array genaamd myBooks die instanties van de Book class bevat. Loop door elk boek in de array en roep de printDetails methode aan voor elk boek. 🗺️ UML Diagrams Je hebt keuze! Kies uit een makkelijke of moeilijke opdracht.\nPak papier of je iPad erbij om een UML diagram te tekenen.\nOpdracht 5 - Makkelijk: Maak een UML diagram Je bent gevraagd om een basis UML klassendiagram te ontwerpen voor een bakkerij systeem. Het systeem moet producten en klanten bijhouden.\nVereisten Product:\nElk product heeft een unieke productcode, een naam (bijv. brood, taart, croissant) en een prijs. Producten kunnen worden verkocht of bijgevuld. Klant:\nKlanten hebben een unieke klantID, naam en een aankoopgeschiedenis (een lijst van gekochte producten). Klanten kunnen producten kopen. Taak Ontwerp een UML klassendiagram dat de klassen, attributen, methoden en relaties vastlegt op basis van de verstrekte vereisten.\nOpdracht 5 - Moeilijk: Bibliotheeksysteem Achtergrond Je hebt de taak om een basis UML klassendiagram te ontwerpen voor een bibliotheeksysteem. Het systeem moet boeken, leners en personeelsleden bijhouden.\nVereisten Boek:\nElk boek heeft een uniek ISBN-nummer, een titel, een auteur, een publicatiejaar en een status (bijv. beschikbaar, uitgeleend, in onderhoud). Boeken kunnen worden geleend of teruggebracht. Lener:\nLeners hebben een unieke ID, naam, adres en een lijst van boeken die ze hebben geleend. Leners kunnen een boek lenen, mits ze geen achterstallige boeken hebben. Leners kunnen een boek terugbrengen. Personeel:\nPersoneelsleden hebben een ID, naam, functie (bijv. bibliothecaris, onderhoud, admin) en een werkschema. Personeel kan boeken aan het systeem toevoegen of verwijderen. Bibliothecarissen kunnen boeken uitlenen aan leners. Onderhoudspersoneel kan een boek markeren als in onderhoud. Relaties:\nEen lener kan meerdere boeken lenen, maar elk boek kan op een bepaald moment slechts door één lener worden geleend. Personeel kan meerdere boeken beheren, en elk boek kan door meerdere personeelsleden worden beheerd. Geef bij elke relatie aan of het een één-op-één, één-op-veel of veel-op-veel relatie is.\nTaak Ontwerp een UML klassendiagram dat de klassen, attributen, methoden en relaties vastlegt op basis van de verstrekte vereisten.\nOplossingen Makkelijk Je tekening moet er ongeveer zo uitzien:\nKlassen, Attributen en Methoden Product Attributen: productCode: String (Uniek) naam: String prijs: Number Methoden: verkoop(): Void vulBij(): Void Klant Attributen: klantID: String (Uniek) naam: String aankoopgeschiedenis: Lijst Methoden: koop(product: Product): Void Relaties De volgende relatie zijn met pijlen getekend:\nKlant - Product: Een één-op-veel relatie aangezien een klant meerdere producten kan kopen, maar elk product op een bepaald moment slechts door één klant wordt gekocht (per transactie). Moeilijk Je tekening moet er ongeveer zo uitzien:\nKlassen, Attributen en Methoden Boek:\nAttributen: ISBN: String (Uniek) titel: String auteur: String publicatieJaar: Integer status: String of Enum (beschikbaar, uitgeleend, in onderhoud) Methoden: leenUit(): Void brengTerug(): Void Lener:\nAttributen: lenerID: String (Uniek) naam: String adres: String geleendeBoeken: Lijst Methoden: leenBoek(boek: Boek): Void brengBoekTerug(boek: Boek): Void Personeel:\nAttributen: personeelID: String (Uniek) naam: String functie: String of Enum (bibliothecaris, onderhoud, admin) werkschema: String Methoden: voegBoekToe(boek: Boek): Void verwijderBoek(boek: Boek): Void leenBoekUit(boek: Boek, lener: Lener): Void markeerOnderhoud(boek: Boek): Void Relaties De volgende relatie zijn met pijlen getekend:\nLener - Boek: Een één-op-veel relatie aangezien een lener meerdere boeken kan lenen, maar elk boek kan op een bepaald moment slechts door één lener worden geleend. Personeel - Boek: Een veel-op-veel relatie aangezien een personeelslid meerdere boeken kan beheren en elk boek kan door meerdere personeelsleden worden beheerd. 🌳 Overerving (Inheritence) Maak de opdrachten van de volgende replit:\nhttps://replit.com/@Krisvan1/Inheritence#index.js Fork de repository. Maak eventueel een account aan als je die nog niet hebt.\nElke opdracht kan je zelf testen door op de “Run” knop te drukken.\nOpdracht 1: Basis class Dier Maak een basis klasse genaamd Dier met de volgende attributen: naam, leeftijd, en gewicht. Deze klasse moet ook de methoden eten() en slapen() bevatten die respectievelijk \"[naam] is aan het eten!\" en \"[naam] slaapt!\" naar de console afdrukken. Opdracht 2: Afgeleide class Vogel Creëer een afgeleide klasse genaamd Vogel die erft van de Dier klasse. Deze klasse moet een extra attribuut vleugelspanwijdte en een methode vliegen() hebben. De vliegen() methode moet \"[naam] is aan het vliegen met een vleugelspanwijdte van [vleugelspanwijdte] meters!\" afdrukken. Opdracht 3: Afgeleide class Zoogdier Maak een andere afgeleide klasse genaamd Zoogdier die ook erft van de Dier klasse. Deze klasse moet een extra attribuut vachtkleur hebben en een methode rennen(). De methode rennen() moet \"[naam] is aan het rennen!\" naar de console afdrukken. Opdracht 4: Test je code Maak een instantie van de Vogel klasse genaamd \"Adelaar\" met een leeftijd van 5, gewicht van 8 kg, en een vleugelspanwijdte van 2,3 meter. Laat de adelaar eten, slapen, en vliegen. Maak vervolgens een instantie van de Zoogdier klasse genaamd “Leeuw” met een leeftijd van 3, gewicht van 190 kg, en een vachtkleur van “goudkleurig”. Laat de leeuw eten, slapen, en rennen.\n🕵️ 🥏 Inkapseling Maak de opdrachten van de volgende replit: https://replit.com/@Krisvan1/PrivateGetSet#index.js TIP: Gebruik de instructies om de code te testen\nTIP: Gebruik het cheat sheet als je niet meer weet hoe je alles moet typen\nOpdracht 1: Virtuele Huisdier Een Virtueel Huisdier is een digitaal karakter dat je kunt voeden, spelen en zorgen. Je huisdier heeft bepaalde eigenschappen zoals honger en geluk. Je kunt acties uitvoeren om aan de behoeften van je huisdier te voldoen. Kijk in de replit voor alle stappen. Klaar? Ga verder met Opdracht 3 van de reguliere opdrachten:\nhttps://informatica.emmauscollege.nl/theorie/objectoriented_verwerkingsopdrachten/#opdracht-3 🚑️ Oefenopdracht Je gaat oefenen met alles wat je tot nu toe geleerd hebt.\nUML Diagram maken In het Ziekenhuis van Sint-Elisabeth draait alles om de zorg voor patiënten. Patiëntenprivacy staat hierbij hoog in het vaandel. Elk patiëntendossier bevat naast medische gegevens zoals leeftijd, medische geschiedenis en allergieën ook een geheime patiëntencode. Deze code is strikt voor intern gebruik en wordt niet met de patiënt gedeeld.\nHet ziekenhuis kent verschillende afdelingen, maar Cardiologie en Neurologie zijn de meest bezochte. Elke doctor in het ziekenhuis is een specialist. Dr. Hartman, een ervaren cardioloog met 300 uitgevoerde operaties op zijn naam, werkt op de afdeling Cardiologie. Hij is bekend om zijn efficiëntie en gebruikt de getDetails methode om snel een patiëntendossier in te zien. Aan de andere kant is er Dr. Brein van de afdeling Neurologie, die gespecialiseerd is in neurologisch onderzoek en al 200 MRI-scans en CT-scans uitgevoerd heeft. Elke doctor heeft een lijst van patienten waarvoor hij zorgt. Elke doctor kan ook een patient onderzoeken\nMevrouw Jansen, 67 jaar oud, komt voor haar jaarlijkse hartcontrole. Ze is allergisch voor penicilline en heeft vorig jaar een hartoperatie ondergaan. Terwijl Dr. Hartman haar dossier inziet met de getDetails methode, merkt hij op dat haar geheime patiëntencode, zoals het hoort, verborgen blijft.\nMaak een UML Diagram van de verschillende classes, attributen en methoden.\nTIP: Denk goed na wat de relatie is tussen de verschillende classes.\nKijk je UML diagram na Oplossing UML Patiënt\nAttributen: naam: String leeftijd: Integer medischeGeschiedenis: String allergieën: String patienten: Lijst\u003cPatiënt\u003e -geheimePatientencode: String (de ‘-’ geeft aan dat het een privé attribuut is) Methoden: getDetails(toegangscode: String): String Dokter (Abstracte klasse aangezien een algemene dokter niet geïnstantieerd zou moeten worden)\nAttributen: naam: String Methoden: onderzoekPatient(patient: Patient) Cardioloog (erft van Dokter)\nAttributen: aantalOperaties: Integer Methoden: voerOperatieUit() Neuroloog (erft van Dokter)\nAttributen: aantalScans: Integer Methoden: voerScanUit() In dit UML-diagram:\nDe klassennamen zijn vetgedrukt. “+” geeft aan dat het een publiek lid is. “-” geeft aan dat het een privé lid is. Er is een erfenispijl van de subklassen (Cardioloog en Neuroloog) naar de bovenliggende klasse Dokter, wat aangeeft dat ze erven van de Dokter klasse. Er is een relatie van Doctor naar patient met de multipliciteit 1..* (één dokter kan meerdere patiënten hebben). Code Schrijven Maak gebaseerd op je *nagekeken* UML diagram de javascript code aan die nodig is om dit systeem te maken. Fork hiervoor de volgende replit: https://replit.com/@Krisvan1/ZiekenhuisSysteem#index.js Natuurlijk, laten we dat aanpakken.\n🗒️ JavaScript Cheat Sheet Creating an Object Een object is een verzameling van sleutel-waarde paren. In dit voorbeeld bevat het object player drie sleutels: name, score en level.\nvar player = { name: 'John', score: 100, level: 2 }; Creating an Array of Objects Arrays zijn geordende lijsten van items. Hier hebben we een array van objecten.\nvar players = [ { name: 'John', score: 100, level: 2 }, { name: 'Jane', score: 150, level: 3 } ]; Accessing Object Properties Je kunt de waarde van een objecteigenschap opvragen door de naam van het object gevolgd door een punt en daarna de eigenschapsnaam.\nconsole.log(player.name); // John Looping Through an Array of Objects Een for loop herhaalt een reeks instructies een bepaald aantal keer. In dit geval loopt de loop door elk object in de players array en drukt de naam en score van elke speler af.\nUitleg loop:\ni = 0: Initialiseert de tellervariabele i op 0. i \u003c players.length: De loop blijft draaien zolang i kleiner is dan het aantal items in de players array. i++: Verhoogt de waarde van i met 1 na elke loop. for(var i = 0; i \u003c players.length; i++) { console.log(players[i].name + ' has a score of ' + players[i].score); } Creating a Class Een klasse definieert de eigenschappen (variabelen) en gedragingen (methoden) die zijn objecten (instanties) zullen hebben.\nclass Player { name; score; level; constructor(name, score, level) { this.name = name; this.score = score; this.level = level; } increaseScore(amount) { this.score += amount; } increaseLevel() { this.level++; } printDetails() { console.log(this.name + ' has a score of ' + this.score + ' and is on level ' + this.level); } } Creating an Instance of a Class var player1 = new Player('John', 100, 2); Accessing Class Properties console.log(player1.name); // John Inheritance in JavaScript Inheritance stelt je in staat om een nieuwe klasse te maken die is gebaseerd op een bestaande klasse. De nieuwe klasse erft eigenschappen en gedrag van de ouderklasse.\nclass Goalkeeper extends Player { savedGoals; constructor(name, score, level, savedGoals) { super(name, score, level); this.savedGoals = savedGoals; } printGoalkeeperStatistics() { console.log('Saved Goals: ' + this.savedGoals); } } Prive variabelen \u0026 Getters en Setters Private variabelen (zoals #saldo) zijn alleen toegankelijk binnen de klasse waarin ze zijn gedefinieerd. Getters en Setters zijn speciale methoden die respectievelijk worden gebruikt om waarden van deze private variabelen op te vragen of in te stellen.\nclass BankRekening { #saldo; // Prive variabele constructor() { this.#saldo = 0; } getSaldo() { console.log(\"Saldo opvragen\"); return this.#saldo; } setSaldo(bedrag) { if (bedrag \u003e= 0) { this.#saldo = bedrag; } else { console.log(\"Ongeldig saldo\"); } } } const rekening = new BankRekening(); console.log(rekening.getSaldo()); // Saldo opvragen + het huidige saldo rekening.setSaldo(-1000); // Ongeldig saldo Door het gebruik van getters en setters kunnen we ervoor zorgen dat de regels voor toegang tot of wijziging van data worden nageleefd.\nPowerpoints Download hier de lespresentaties Antwoorden oefeningen opdracht 1 overerving private, set en get ziekenhuissysteem ","description":"","tags":null,"title":"Extra: OOP voor 6vin2","uri":"/theorie/object_oriented_programming/"},{"content":"Hier vind je informatie voor docenten over de online ontwikkelomgeving. We gebruiken Github met Codespaces en Classroom.\nGitHub GitHub is een online omgeving waar programmeurs code opslaan en delen. GitHub is gebaseerd op Git.\nHet kost tijd om Git te leren begrijpen, maar een team dat Git begrijpt kan veel efficienter werken. Leeringen die beginnen met programmeren werken veelal samen tegelijk achter 1 computer of typen tegelijk online in hetzelfde document. Het typen en runnen van code moet dan synchroon gebeuren. Professionele teams van programmeurs verdelen werk, maken en testen dat in hun eigen kopie van de omgeving en voegen stukjes code die werken toe aan het gezamenlijke product. Zo is er altijd een werkende versie van het product en kan iedereen zijn eigen versie op elk moment runnen.\nGitHub: Functionaliteit Functionaliteit van GitHub:\nOnline opslaan van code Versiebeheer Met meerdere mensen werken aan dezelfde code Hosting van static websites Toegankelijk via website API beschikbaar … GitHub: Gratis aanbod Git is open-source.\nGitHub is eigendom van Microsoft. Met een gratis account kun je bijna alle functionaliteit gebruiken. De betaalde functies zijn gericht op software-bedrijven, in het onderwijs heb je die niet nodig.\nGitHub: Aan de slag Tips voor gebruik:\nMaak een gratis GitHub account aan en start met het maken van repositories. Maak een organisatie aan in GitHub. Nodig de informaticadocenten op je school uit als (mede)owner van de organisatie. Je kunt dan gemakkelijker met collega informatica-docenten op je school samenwerken en je kunt je schoolwerk gescheiden houden van andere dingen die je op je GitHub account doet. Het is handig om een tweede organisatie te maken waarin je werk van leerlingen bewaart (zie ook onder Classroom). Wijzigen van code gaat in de volgende stappen: change (maak wijzigingen in de code met een editor) stage changes (kies de wijzigingen waarmee je verder wilt, meestal allemaal) commit (maak een foto van je wijzigingen) pull (haal de laatste wijzigingen van anderen op uit GitHub) los eventuele merge-conflicten op (als jij en anderen in dezelfde regels code aanpassingen hebben gedaan, dan moet je handmatig aangeven welke aanpassingen voorrang krijgen) push (upload jouw wijzigingen inclusief opgeloste merge-conflicten naar GitHub) Er zijn instellingen in Git die het gemakkelijker maken voor beginners om ermee te werken, bijvoorbeeld dat alle changes automatisch gestaged worden, dat bij commit automatisch geprobeerd wordt te pullen en pushen, een merge-editor aanzetten die helpt met het oplossen van merge-conflicten etc. In de template-repositories van Emmauscollege vind je de instellingen die wij handig vinden. Voor grotere projecten kun je gebruik maken van branches. Een branch bevat een nieuwe functies die meerdere commits bevat. Als de feature klaar is, dan merge je de branch in de main branche. Je kunt incidenten aanmaken om bij te houden welke bugs er zijn of welke uitbreidingen nog gedaan moeten worden. De indicenten kun je koppelen aan wijzigingen in de code. Dit kan handig zijn voor grotere projecten, bijvoorbeeld in 6-vwo. GitHub: Alternatieven GitHub wordt heel veel gebruikt, als je specifieke wensen hebt dan zijn er alternatieven voor GitHub.\nGit lokaal op je PC installeren en via de commandline je code opslaan op een andere git-server dan GitHub. Gitlab, eveneens gebaseerd op Git, zowel te gebruiken in een cloud omgeving als op eigen servers. Codespaces Codespaces is een online ontwikkelomgeving voor alle programmeertalen.\nCodespaces: Functionaliteit Functionaliteit van Codespaces:\nVirtual machine in de cloud waarop je een Docker image kunt draaien. Het Docker image kun je zelf volledig configureren. Online toegang via webbrowser, inclusief mogelijkheden om bestanden te wijzigen, terminal commando’s te geven en server-applicaties te draaien (zoals webserver, database, vnc-server). Visual Studio Code editor ingebouwd. Met enkel kliks in GitHub kun je een Codespace maken vanuit een GitHub repository. Wijzigingen in je Codespace bewaar je in GitHub. … Wat kan niet:\nEen Codespace dag en nacht laten draaien kan niet, want als je de browser afsluit dan stopt de Codespace na enige tijd (half uur). Als een Codespace stopt dan blijven de bestanden in de Codespace bewaard, dus je kunt de Codespace later weer opnieuw starten. Als een Codespace langere tijd (30 dagen) niet gebruikt is, dan wordt hij gewist. De bestanden uit de Codespace verdwijnen dan, wat je vanuit de CodeSpace in GitHub hebt gezet blijft uiteraard wel bestaan. Codespaces: Gratis aanbod Codespaces maakt onderdeel uit van GitHub. CodeSpaces is geïntegreerd in GitHub. Je GitHub account gebruik je voor CodeSpaces.\nMet een gratis GitHub account kun je per maand 60 uur gebruik maken van Codespaces en gemiddeld 15 GB opslag gebruiken. Je kunt je gebruik inzien, bij overschrijding van de limit wordt Codespaces (niet GitHub) geblokkeerd totdat de maand voorbij is.\nEén codespace vraagt ongeveer 1 GB data, tegen de opslag limiet loop je normaliter niet aan.\nDe 60 uur is voldoende voor bijna alle leerlingen. Een enkele leerling die door de limiet gaat kan een 2e GitHub account aanmaken op een ander email adres, zichzelf als collaborator toevoegen aan de repositories waarin die werkt en dan weer 60 uur vooruit.\nEen docent die door de limieten heen gaat kan creditcardgegevens en een bestedingslimiet toevoegen aan zijn account. Dat is normaal gesproken niet nodig. Een tweede account aanmaken kan ook.\nCodespaces: Aan de slag Login op GitHub, ga naar een repository, klik op de groene code knop en maak een Codespace. Er wordt een standaard image van een linux server gestart en je bestanden uit de repository worden gekopieerd naar de server. Je kunt de Codespace configureren door een devcontainer.json bestand in de .devcontainer map te plaatsen. Open het Source-Control tab links in het scherm om wijzigingen te bewaren in GitHub.\nCodespaces: Alternatieven Alle onderstaande alternatieven kunnen samenwerken met GitHub, maar zijn ook zonder GitHub te gebruiken.\nhttps://gitpod.io/ , zelfde look and feel en nagenoeg dezelfde mogelijkheden als Codespaces, inclusief editor VS Code. https://replit.com/ , in 2017-2020 begonnen als online multi-language platform voor kleine stukjes code, inmiddels fors gegroeid kwa mogelijkheden en aantal gebruikers. Wij hebben enkele jaren Gitpod (vwo) en replit (havo) gebruikt. In 2023 hebben we een geslaagde pilot in 5-vwo gedraaid met Codespaces, ondermeer vanwege de naadloze integratie met GitHub. De firewall van de nieuwe internetaanbieder van de school blokkeerde gebruik op schoolcomputers. In schooljaar 24/25 willen we Gitpod gebruiken, zowel voor de havo als voor het vwo.\nGitHub Classroom Met GitHub Classroom kun je opdrachten klaarzetten voor (grote aantallen) leerlingen.\nClassroom: Functionaliteit Wat wel kan:\nOpdrachten aanmaken en uitnodigingen versturen per email naar leerlingen. Leerlingen schrijven zichzelf in. Leerlingen kunnen zelf groepjes maken, als je groepjes maken aanzet voor die opdracht. Bij het inschrijven krijgen leerlingen een kopie van een template-repository uit GitHub die de docent bij de opdracht meegeeft. Wat niet kan:\nTemplate-repository aanpassen nadat opdracht is uitgezet. Sinds januari 2024 is er beta functionaliteit beschikbaar waarmee dit wel kan. Zie https://github.blog/changelog/2024-01-22-migrating-github-classroom-assignment-repository-creation-from-create-from-template-to-forks-public-beta/ Groepjes aanpassen nadat opdracht is uitgezet. Je kunt dit wel handmatig in GitHub doen door de teams die Classroom aanmaakt in GitHub aan te passen. Classroom: Gratis aanbod Je gebruikt je GitHub account voor classroom. Classroom is geheel gratis, zonder beperkingen. Je kunt de educatie-status aanvragen voor je GitHub account, maar dat is niet nodig.\nClassroom: Aan de slag Tips voor gebruik:\nMaak een organisatie in GitHub waarin je alle leerlingwerkstukken neerzet. Gebruik een andere organisatie voor je eigen voorbeelden en templates. Op die manier hou je werk van leerlingen en van docenten gemakkelijk uit elkaar. Bij elke opdracht die je aanmaakt kunt je aangeven waarmee de naam van de repository die Classroom voor leerlingen in GitHub aanmaakt moet beginnen. Gebruik een systematische naam, dat maakt het vinden van klassen en leerlingen veel gemakkelijker. Bijvoorbeeld :2324-5hin1-website (jaar-klas-opdracht). Geef herkenbare identifiers voor leerlingen op in Classroom. Voornamen werkt handiger dan leerlingnummers. Leerlingen koppelen bij inschrijven hun GitHub account aan de identifier. Deze identifiers worden door Classroom toegevoegd aan de namen van de repositories voor leerlingen. Leerlingen kiezen hun eigen GitHub accountnaam en hun eigen teamnaam, deze zie je terug in de teams die Classroom in GitHub aanmaakt. Hou in de gaten dat de namen die leerlingen kiezen okee zijn. Classroom: Alternatieven Alternatieven voor Classroom:\nLaat leerlingen zelf hun repositories aanmaken, eventueel op basis van een template-repository die de docent online zet. Voor een eerste keer en tot enkele tientallen leerlingen is dit een prima oplossing. De docent maakt de repositories met de hand aan. In een situatie met enkele tientallen leerlingen is dit prima te doen. Gebruik eigen scripts om repo’s aan te maken. Dit hebben wij enkele jaren gedaan, omdat Classroom toen nog niet betrouwbaar werkte. Veelgestelde vragen Heb je een voorbeeld-repository om mee aan de slag te gaan?\nMail ons even voor de laatste versie, of ga zelf op zoek tussen onze template-repositories op https://github.com/orgs/emmauscollege/repositories?q=template Ik zie geen open poorten Codespaces, hoe kan dat?\nSommige scholen blokkeren verkeer naar https://euw.rel.tunnels.api.visualstudio.com in hun firewall. Een work around is om de link naar de juiste poort op de server zelf te typen. Als je een webserver draait op poort 8080, dan doe je dat als volgt: Knip de link van je Codespace boven in je browser naar een nieuw tabblad (de link lijkt op https://xxxxxx-xxxxxx-xxxxxx.github.dev ) Verander de link in https://xxxxxx-xxxxxx-xxxxxx-8080.app.github.dev (dus voeg -8080.app toe) Je ziet nu de webpagina die je in je codespace gemaakt hebt. De merge-conflicten zijn lastig op te lossen, is er een simpelere manier van werken?\nGebruik de plugin live-share, waardoor leerlingen tegelijk kunnen typen in dezelfde codespace. De ene leerling nodigt de andere uit. Documentatie GitHub\nTo be added, er is heeeel veel te vinden. The EXTREMELY helpful guide to merge conflicts YouTube Codespaces, officiele documentatie\nhttps://docs.github.com/en/codespaces GitHub Classroom, officiele documentatie\nhttps://docs.github.com/en/education/manage-coursework-with-github-classroom ","description":"","tags":null,"title":"Ontwikkelomgeving","uri":"/docenten/github-docenten/"},{"content":"GitHub is een website waar je code kunt opslaan en delen. Codespaces is een codeeromgeving binnen GitHub waar je code kunt wijzigen en uitvoeren. Codespaces maakt gebruik van de webversie van de editor Visual Studio Code.\n1. Wat zijn GitHub, Codespaces en VS Code? Screenshot van Github Screenshot van Codespace GitHub is een website waar je code kunt opslaan en delen. GitHub bewaart alle oude versies van je code. Code op GitHub kun je gemakkelijk delen met anderen. Met GitHub kun je in groepen aan dezelfde code werken. Bestanden in GitHub worden bewaard in repositories. Een repository (ook wel afgekort tot repo) is een soort hoofdmap. Voor elk project maak je een aparte repository. GitHub werkt op basis van Git. Git is open source software. Er zijn veel programmeeromgevingen die via Git kunnen samenwerken met GitHub. Codespaces is een codeeromgeving binnen GitHub waar je code kunt uitvoeren. Codespaces biedt een devcontainer (computer in de cloud) waar je op kunt werken via een browser. In je browser zie je VS Code. VS Code “praat” met Codespaces. Wijzigingen in bestanden in je Codespace kun je bewaren in GitHub. Je kunt code uitvoeren in je Codespace, bijvoorbeeld door commando’s te typen in de terminal. VS Code is de editor die in Codespaces wordt gebruikt. VS Code gebruik je voor het wijzigen en runnen van code in Codespaces. VS Code is geschikt voor alle populaire programmeertalen VS Code is meer dan een editor, zo verzorgt VS Code ook de verbinding met je Codespace en GitHub Je kunt de instellingen van VS Code naar je eigen smaak aanpassen. Wij gebruiken instellingen om het bewaren van wijzigingen in github gemakkelijker te maken. De functies van VS Code kun je uitbreiden met extensions. Wij gebruiken extentions om previews van .pdf en .html bestanden te bekijken. VS Code (spreek uit als “vie es koot”) is een veelgebruikte afkorting voor Visual Studio Code. 2. Starten met een opdracht 2.1 Maak een account in GitHub Ga naar https://www.github.com/ (gebruik bij voorkeur Chrome). Klik op sign-up. Gebruik je email adres van school. Kies een wachtwoord dat je terug kunt vinden. Kies als username je voornaam met de eerste letter van je achternaam, als die al bezet is voeg je een nummer toe. Bijvoorbeeld jamesb007 Bevestig je account door te klikken op de link in de mail die je ontvangt van GitHub. 2.2 Maak een Codespace met startcode voor je opdracht De docent deelt een link naar GitHub Classroom waarmee jij je kunt inschrijven voor een opdracht. Na inschrijven krijg je automatisch een repository met startcode voor de opdracht. Als je in een groepje werkt dan maakt het eerste groepslid die zich inschrijft een team aan. De naam van dat team bestaat uit alle voornamen van de groepsleden gescheiden door een streepje. Bijvoorbeeld anne-jasmin-noah. De andere groepsleden joinen bij inschrijven het team dat is aangemaakt. Je maakt je eigen Codespace door op de knop “Create Codespace te klikken”. Alle bestanden uit de GitHub repository worden gekopieerd naar jouw Codespace. Dit kan enkele minuten duren. 3. Werken aan een opdracht 3.1 Codespace starten Als je een Codespace start, dan zie je het scherm van VS Code in je browser.\nOp bovenstaande plaatje zie je het scherm van VS Code met de volgende onderdelen:\n(A) Activity Bar, klik op het bovenste icoon (Explorer) om je mappen en bestanden te zien, klik op het derde icoon (Source Control) van boven om te werken met GitHub (C) Editor Groups, hier verschijnen de bestanden die je opent. (D) Panel, hierin zit onder andere de Terminal. De terminal geeft toegang tot de virtuele computer, je kunt er commando’s intypen. 3.2 Code aanpassen Dubbelklik op een bestand, bijvoorbeeld index.html of main.py. Het bestand wordt geopend in de editor. Je kunt nu het bestand aanpassen. 3.3 Resultaat bekijken Het hangt van de programmeertaal af hoe je kunt bekijken wat je code voor resultaat geeft. In het README.md bestand van de startcode staat beschreven hoe dit moet. Voor een aantal veelgebruikte programmeertalen vind je hier een korte samenvattig\nhtml (eventueel met css en/of javascript): Start een webserver in de Codespace, bij de meeste startcode gebeurt dit automatisch als je de Codespace start. De webserver zorgt ervoor dat de html-bestanden uit de Codespace door een browser op je computer kunne worden geladen. Open een browser-venster met het index.html bestand uit je Codespace. Klik hiervoor op Ports, klik daarna op de link met het adres van de webserver. python: Type in de terminal python main.py, het programma start\nAls het programma lang duurt, stop het dan met de toetsen [CRTL]+[C] Start het programma opnieuw met de toets [PIJL OMHOOG]\npython met pygame: Type in de terminal python main.py, het programma start\nOpen een browser-venster dat via novnc is verbonden met het grafische scherm dat pygame gebruikt. Klik hiervoor op Ports, klik daarna op de link met het adres van de novnc-server. 3.4 Wijzigingen bewaren in GitHub Klik in de activity bar op het Source Control icoon. Voer een beschrijving van de wijziging in Druk op de groen knop “Commit \u0026 Sync”. Je wijzigingen worden nu bewaard in GitHub. Je kunt controleren op github.com of het is gelukt. 4. Samenwerken 4.1 Een team van één persoon Bewaar nieuwe versies van je code steeds in Github. Dan heb heb je een backup als er iets misgaat in Codespaces.\nDe laatste versie van je code uit je Codespace bewaren op GitHub doe je zo:\nIn de iconenbalk links op je scherm is een icoon voor “source control”. Dit is het derde icoon van boven, als je er even met je muis op staat dan verschijnt de tekst “source control”. Klik op het icoon. Je ziet onder “changes” een lijst met bestanden waarin je wijzigingen hebt gemaakt. Daarboven zie je een knop “Commit \u0026 Sync”. Boven de knop zie je een invoerveld met de tekst “Message”. Type een korte beschrijving van je wijziging in het “Message” invulveld. Dit heet een commit message. Klik daarna op “Commit \u0026 Sync”. Je code wordt nu bewaard in GitHub. Als alles gelukt is dan zie je de beschrijving van je wijziging terug in GitHub. Controleer dat in GitHub. Het werkt het best als je aanpassingen doet in kleine stapjes.\nType steeds een paar regels code en test dan of het doet wat je verwacht had. Maak per lesuur één of enkele commits en bewaar dit in GitHub. Een commit is een versie met een aantal kleine wijzigingen die samen iets nieuws toevoegen. Het is niet handig om elke minuut een commit te maken, maar minimaal één commit per les zou wel moeten. 4.2 Een team van twee of drie Elk teamlid heeft zijn eigen kopie van de code in zijn eigen Codespace. In GitHub staat de gezamenlijke code.\nAls je in teams werkt, dan is het opslaan van je code ingewikkelder. Je moet immers zorgen dat jouw wijzigingen en die van je maatje worden samengevoegd. GitHub helpt daarbij.\nDe laatste versie van je code uit je Codespace bewaren op GitHub doe je zo:\nWijzig en test : Type steeds een paar regels code en test dan of het doet wat je verwacht had. Stage : Zet de gewijzigde bestanden klaar voor de commit. Een commit is en nieuwe versie. Commit : Type een korte beschrijving waaronder je de nieuwe versie terug kan vinden. Pull : Haal de wijzigingen van teamgenoten uit Github binnen in jouw Codespace. Push : Duw je commit in Codespace naar je repository op GitHub. Stap 2, 3, 4, en 5 worden direct achter elkaar gedaan als je klikt op de knop “Commit \u0026 Sync”. Als je in teams werkt, dan kan het zijn dat je maatje iets in GitHub bewaart, terwijl jij in jouw Codespace aan het werk bent. De wijzigingen van jouw maatje komen niet automatisch in jouw Codespace, zodat jij ongestoord verder kunt coderen. Als jij na je maatje wijzigingen in GitHub bewaart, dan probeert GitHub de wijzigingen van jou en je maatje automatisch samen te voegen. Als jullie dezelfde regels in hetzelfde bestand gewijzigd hebben, dan lukt het samenvoegen niet automatisch. CodeSpace geeft dan aan dat er een merge-conflict is. Jij moet dan zelf aangeven welke wijzigingen GitHub moet kiezen. Daarna klik je op “Continue” om te zorgen dat alle stappen uit “Commit \u0026 Sync” worden afgemaakt.\nDeze video legt uit hoe je merge-conflicten in Codespaces oplost . Als je goede afspraken maakt over wie wat doet, dan heb je weinig merge-conflicten.\nAls je langer dan een dag niet aan je code gewerkt hebt, dan is het handig om de laatste wijzigingen van jullie gezamenlijke code in GitHub binnen te halen. Dat heet “Pull”. Onze Codespace is zo ingesteld, dat je op het pijltje naast “Commit \u0026 Sync” kunt drukken om te pullen. Pullen kan alleen als je na je laatste commit geen wijzigingen meer hebt gedaan.\n4.3 Een team van vier of meer In grotere teams worden er heel veel veranderingen tegelijk doorgevoerd. De gezamenlijke code wijzigt daardoor heel vaak. Dat is onhandig.\nHet werkt in grote teams handiger als je het werk verdeelt in branches. Vraag hierover uitleg aan je docent, als jullie daaraan toe zijn.\n5. Howto’s en veelgestelde vragen 5.1 Bestanden en mappen Ik wil een nieuw bestand maken, de naam van een bestand veranderen, een bestand uploaden, bestanden downloaden of andere dingen met bestanden of mappen doen. Hoe doe ik dat?\nBestanden bekijken Open Codespaces. In de kolom met iconen links op je scherm zie je bovenaan een icoontje met twee velletjes papier. Klik daarop. Je ziet nu een lijst met al je bestanden en mappen. Mappen kun je uitklappen. Als je dubbelklikt op een bestand, dan wordt het geopend. Als je met je rechtermuisknop op een bestand of map klikt, dan verschijnt er een drop-down menu waarin je meer met het bestand of de map kunt doen. Nieuw bestand of map maken Open Codespaces. In de kolom met iconen links op je scherm zie je bovenaan een icoontje met twee velletjes papier. Klik daarop. Je ziet nu een lijst met al je bestanden en mappen. Mappen kun je uitklappen. Als je muis op de lijst met bestanden staat, dan zie je vlak boven de lijst twee icoontjes met een +. Als je op de linker klikt, dan maak je een nieuw bestand. Als je op de rechter klikt, dan maak je een nieuwe map. Naam van bestand of map wijzigen Open Codespaces. In de kolom met iconen links op je scherm zie je bovenaan een icoontje met twee velletjes papier. Klik daarop. Je ziet nu een lijst met al je bestanden en mappen. Mappen kun je uitklappen. Klik met de rechtmuisknop op een bestand of map. Er verschijnt een drop-down menu. Kies “Rename…” in het pull-down menu. Pas de naam aan en druk op Enter. Bestanden verplaatsen Open Codespaces. In de kolom met iconen links op je scherm zie je bovenaan een icoontje met twee velletjes papier. Klik daarop. Je ziet nu een lijst met al je bestanden en mappen. Mappen kun je uitklappen. Sleep het bestand van de ene naar de andere map. Bestand uploaden naar Codespaces Open Codespaces. In de kolom met iconen links op je scherm zie je bovenaan een icoontje met twee velletjes papier. Klik daarop. Je ziet nu een lijst met al je bestanden en mappen. Mappen kun je uitklappen. Sleep een bestand van je bureaublad naar het lijstje bestanden in Codespaces.\nAls stap 3 niet werkt, probeer dan stap 4. Ga op een map staan, klik op de rechtermuisknop, een pull-down menu verschijnt, kies “Upload…” in het pull-down menu. Bestand downloaden uit Codespaces Open Codespaces. In de kolom met iconen links op je scherm zie je bovenaan een icoontje met twee velletjes papier. Klik daarop. Je ziet nu een lijst met al je bestanden en mappen. Mappen kun je uitklappen. Ga op een bestand staan, klik op de rechtermuisknop, een pull-down menu verschijnt, kies “Download…” in het pull-down menu. Alle bestanden downloaden Open GitHub, ga naar de pagina met je repository. Klik op de groene knop “Code” en kies in het menu dat verschijnt voor “Download ZIP”. Dubbelklik op het gedownloade zip-bestand om alle bestanden uit te pakken. 5.2 github.com gebruiken Hoe open ik mijn laatste Codespace? Open GitHub en login. Klik op de drie streepjes links bovenin. Een menu opent. Klik in het menu op Codespaces. Er wordt een lijst al je Codespaces getoond Klik op de Codespace die je wilt openen. Het openen duurt één a twee minuten. Hoe maak ik een nieuwe Codespace? Open GitHub en login. Ga naar je repository. Klik op de groen knop “Code”, een popup menu verschijnt. Kies het tabje “Codespaces” in het menu. Klik op de groen knop “Create Codespace” (die zie je als je nog geen Codespace van deze repository hebt), klik op “+” als je die knop er niet is. De nieuwe Codespace wordt gemaakt en al je code uit GitHub wordt naar de Codespace gekopieerd. Dit duurt één a twee minuten. Waar staat mijn repository? Open GitHub en login Links in het scherm staan de repo’s die je recent en vaak gebruikt hebt. Door op een repo te klikken wordt deze geladen. De link van de repo staat bovenin je browser. Als je in een team aan een repo werkt, klik dan links op het team, daarna bovenin je scherm op repositories Lijst met commits bekijken Open GitHub, ga naar de pagina met je repository. Een lijst met de laatste wijzigingen krijg je door te klikken op het aantal commits, onder de groene knop met “Code”. Van elke commit kun je zien wat er is gewijzigd, klik daarvoor op het nummer van de commit aan het einde van de regel. Oude versie van je repository bekijken Open GitHub, ga naar de pagina met je repository. Een lijst met de laatste wijzigingen krijg je door te klikken op het aantal commits, onder de groene knop met “Code”. Klik op \u003c\u003e achter een commit naar keuze. Je ziet nu de versie van de repository op het moment van de commit. 5.3 Overige vragen en problemen GitHub 404 fout oplossen Ik heb via email een link ontvangen om toegang te krijgen tot een repo, maar als ik op de link druk dan krijg ik een 404 fout. Wat moet ik doen?\nLogin op GitHub en druk daarna nogmaals op de link.\nMerge conflict oplossen Ik heb een merge conflict, hoe los ik dat op?\nKijk deze video, daarin wordt uitgelegd hoe je een merge conflict in Codespaces oplost.\nhttps://www.youtube.com/watch?v=HosPml1qkrg Als je er met de video niet uitkomt en er is niemand in de buurt die je kan helpen, dan kun je het volgende doen.\nMaak een nieuwe Codespace. In de nieuwe Codespace wordt de laatste versie van de code van GitHub ingelezen. Knip en plak de wijzigingen van je oude Codespace naar je nieuwe Codespace. Test of je code het doet, haal de fouten eruit. Bewaar je wijzigingen in GitHub door in je nieuwe Codespace op Commit en Sync te klikken. Scherm delen Ik wil mijn scherm delen met iemand anders, hoe doe ik dat?\nIn de iconenbalk links op je scherm zie een soort gebogen pijl. Dit is de extension “live-share”. Hiermee kun je je scherm delen met andere GitHub gebruikers.\nDeze functie is bedoeld om samen snel een klein probleem op te lossen. Gebruik hem niet meer dan een paar minuten per les. Echte programmeurs verdelen het werk, maken elk hun eigen stuk code in hun eigen Codespace en delen het dan via GitHub. Dat moet jij ook leren.\nAutomatisch inspringen Open een bestand in VS Code Klik in het bestand op de rechtermuisknop. Er verschijnt een pop-up menu. Klik in het menu op Format Document. Het document wordt aangepast zodat de code netjes inspringt. Hoeveel gratis usage heb ik nog? Per maand krijg je gratis usage voor allerlei dingen, de belangrijkste voor jou zijn:\nAantal repositories in GitHub: onbeperkt Hoeveelheid opslag in GitHub: onbeperkt Aantal uren gebruik van Codespaces: 60 per maand (bij de standaard configuratie met 2 vCPU) Hoeveelheid opslag gemiddeld per maand in Codespaces: 15 GB (één Codespace neemt 1 à 2 GB in beslag) Je kunt zien hoeveel usage je nog hebt op: https://github.com/settings/billing/summary Om onnodige usage te voorkomen is GitHub als volgt ingesteld:\nEen Codespace die je een half uur open hebt staan zonder dat je erin werkt wordt automatisch gesloten (niet gewist). Een Codespace die je twee weken niet opent wordt automatische gewist. Mijn gratis usage is op Je kunt 3 dingen doen:\nEen tweede account aanmaken, je docent kan dat account toeveogen als collaborator aan de repo waarin je werkte. Bijbetalen, dit is vooral handig voor docenten. Je moet een creditcard invoeren en kunt een maximum bedrag per maand instellen. Verder werken in een lokaal geïnstalleerde VS Code met Docker, hiervoor heb je een PC of laptop nodig en moet je handig zijn met VS Code en Docker. 5.4 Documentatie Waar vind ik meer documentatie?\nDocumentatie over VS Code https://code.visualstudio.com/docs/getstarted/userinterface ","description":"","tags":null,"title":"GitHub met Codespaces en VS Code","uri":"/tools/codespaces/"},{"content":"Arduino IDE is een programma waarin je code kunt schrijven en downloaden in je Arduino.\nWat is de Arduino IDE? De Arduino IDE is een programma waarmee je je Arduino kunt programmeren. De Arduino IDE is beschikbaar voor computers met Windows, Linux en MacOS. Het programma is niet beschikbaar voor iPads en Chromebooks. Functies van de Arduino IDE:\ncode-editor compileren gecompileerde code uploaden naar een Arduino microcontroller (via een USB-kabel) Installeren van het programma Op de schoolcomputers is de Arduino-IDE al geïnstalleerd. Als je Arduino thuis wilt gebruiken, dan moet je het zelf installeren. Dat gaat als volgt.\nDe Arduino IDE is gratis. Je hoeft geen account aan te maken. Download de Arduino IDE van https://www.arduino.cc/en/software Installeer het programma zoals je gewend bent om andere programma’s te installeren op je computer. Je eerste Arduino schets Start de Arduino IDE Sluit de Arduino met een USB-kabel aan op de laptop Stel de juiste Arduino in. Klik in het menu op “Hulpmiddelen”-\u003e“Board”-\u003ede_Arduino_die_je_hebt. De rode Arduino’s op school zijn “Aduino Nano”. Stel de USB-poort in waarop je de Arduino hebt aangesloten. Klik in het menu op “Hulpmiddelen”-\u003e“Poort”-\u003ekies_de_juiste_poort. Meestal is de juiste poort iets met “arduino” of “mega” en iets zonder “bluetooth”. Maak een schets. Een programma voor je Arduino microcontroller wordt vaak een schets (Engels: sketch) genoemd. Je kunt beginnen met een voorbeeld-schets. Klik in het menu op “Bestand”-\u003e“Voorbeelden”-\u003e“Basics”-\u003e“Blink” Compileer de schets (vertaal je code naar machinetaal die de Arduino gebruikt). Klik in het menu op “Schets”-\u003e“Verifeer/Compileer”. Upload (verstuur naar je Arduino via de USB-kabel). Klik in het menu op “Schets”-\u003e“Upload”. Je ziet nu een klein ledje op je Arduino die knippert. Verander de code, bijvoorbeeld delay(1000) aanpassen in delay(200). Herhaal stap 7. Je zult zien dat de Arduino stap 6 (compileren) vanzelf opnieuw doet, omdat je de code hebt aangepast. Het ledje knippert nu sneller. Nu je stap 9 gedaan hebt, weet je zeker dat het jouw programma is dat in de Arduino zit. De Arduino onthoudt namelijk het laatste programma, ook als de stroom eraf is geweest, dus het kan zijn dat het knipperend-led programma er al door een vorige leerling in is gezet. Extra libraries installeren De ingewikkeldere sensoren en actuatoren die je kunt aansluiten op je Arduino, zoals displays, hebben libraries nodig om ze te kunnen programmeren. Er zijn twee manieren om libraries te installeren\nlibraries die meegeleverd zijn met Arduino IDE\nHet installeren van libraries die meegeleverd zijn met de Arduino IDE kan via het menu “Schets” -\u003e “Bibliotheek gebruiken” -\u003e “Bibliotheken beheren”. Het vinden van de juiste bibliotheek kan wel eens lastig zijn, vraag het de docent als je twijfelt. libraries uit een zip-bestand\nHet installeren van libraries waarvan je een .zip bestand hebt kan via het menu “Schets” -\u003e “Bibliotheken gebruiken” -\u003e “Voeg .ZIP bibliotheek toe”. De .zip bestanden vind je vaak terug bij startcode die je van je docent krijgt of op de site van leveranciers van Arduino-hardware. Goede biblitheken bevatten voorbeeld-code die na installatie van de bibliotheek in de Arduino IDE terug te vinden is in het menu onder “Bestand” -\u003e “Voorbeelden”\nMeer informatie Meer informatie over de Arduino-taal vind je op https://www.arduino.cc/ klik op “documentation” -\u003e “reference” Meer informatie over de pinnen van je Arduino vind je op https://www.arduino.cc/ klik op “hardware” -\u003e kies jouw Arduino -\u003e kies het tabblad “FAQ” Veelgestelde vragen Hij doet het niet Kijk of de USB-kabel goed in de Arduino zit (je voelt een kleine klik) Kijk of je de juiste Arduino hebt aangeven in de IDE (Arduino Nano) Kijk of je de juiste USB-poort het aangegeven in de IDE Kijk of er foutmeldingen zijn bij uploaden en lees die aandachtig Bij het uploaden krijg ik de melding “avrdude: ser_open(): can’t open device”… Je hebt waarschijnlijk vergeten de juiste USB-poort te kiezen. Kies de juiste USB-poort in het menu onder “Hulpmiddelen”-\u003e“Poort”\nIk krijg één of meerdere foutmelding(en) tijdens het compileren Je hebt fout gemaakt in de code. Bekijk de bovenste foutmelding. Kijk of je de melding begrijpt. Er staat bij op welke regel de fout gevonden is. Probeer de fout in je code op te lossen. Compileer de code daarna opnieuw.\nIk krijg een foutmelding met “undefined” tijdens het compileren Je hebt waarschijnlijk een variabele gebruikt zonder deze te declareren of een typefout gemaakt in de naam van de variabele.\nCompileren en uploaden gaat goed, maar mijn programma doet niet wat ik wil Laat je programma berichten op de Seriële monitor zetten, zodat kunt meekijken wat er gebeurt en de fout kunt vinden. De seriële monitor van Arduino is een soort console, die je misschien kent van eerdere opdrachten.\nZet in de setup() functie de opdracht Serial.begin(115200); Zet aan het begin van loop() functie de opdracht Serial.println(\"Start\"); Voeg op meer nuttige plaatsen berichten toe, zodat je weet welke code wel en niet wordt uitgevoerd. Je kunt ook de inhoud van variabelen of de uitkomst van functies afdrukken, bijvoorbeeld met Serial.println(\"Milliseconde na opstarten\" + millis()); Open voordat je programma upload de seriele monitor door in de Arduino-IDE te klikken op het menu “Hulpmiddelen” -\u003e “Seriële monitor”, let op dat de snelheid staat ingesteld op 115200. Ik heb een kleine rode arduino en op de video van arduino-lessen.nl zie ik een grote blauwe arduino Op school gebruiken wij een Arduino Nano van het merk Suideeeno . Deze heeft dezelfde mogelijkheden als de grote blauwe of groene Arduino Uno . Bij de Nano sluit je draadjes aan via het breadboard, terwijl je de draadjes bij de Uno direct in de Arduino prikt. De pinnen op beide Arduino’s werken hetzelfde, je kunt aan de namen die erbij staan zien welke je moet hebben.\nMijn display heeft andere stekkers dan het display op de video van arduino-lessen.nl Op school gebruiken we een display van het merk Seeeduino . Dit display kun je met een grove kabeltje aansluiten op de rode Arduino Nano. Het grove kabeltje is het kabeltje met vier draadjes in de kleuren geel-wit-rood-zwart draadjes en twee witte plastic stekkers aan de uiteinden.\nHoe sla ik een sketch op? Kies in het menu “Bestand” -\u003e “Opslaan als”, kies een map en geef je schets een naam. Een schets wordt altijd opgeslagen in een map met dezelfde naam als de schets. ","description":"","tags":null,"title":"Arduino IDE","uri":"/tools/arduino-ide/"},{"content":"Filius is een programma waarmee je netwerken kunt namaken en simuleren.\nWat is Filius? Filius is een programma waarmee je netwerken kunt bouwen en simuleren.\nInstalleren van het programma Filius is gratis en je hoeft geen account aan te maken. Je kunt Filius op diverse manieren starten.\nOpen Filius in GitHub en volg de stappen uit de Readme.md. Dit werkt op (bijna) elk apparaat met een moderne webbrowser. Je browser opent GitPod en op de servers van GitPod wordt een Linux-omgeving met Filius geopend. Je kunt in GitPod inloggen met je (gratis) GitHub account. Installeer Filius op je eigen apparaat. Filius is beschikbaar voor Windows, MacOS en Linux. Veelgestelde vragen Filius verdwijnt van het scherm en ik krijg de melding “noVNC”. Als je in de workspace in gitpod een half uur niets aanpast dan wordt de workspace afgesloten. Klikken in Filius telt niet als een aanpassing. Er is geen echte oplossing, maar wel een work-around. Om te voorkomen dat de workspace wordt afgesloten terwijl je in Filius werkt kun je elk half uur een kleine wijziging maken in je workspace, bijvoorbeeld door een puntje aan het einde van je README.md toe te voegen.\nMeer informatie Meer informatie over Filius kun je vinden op de website van de maker: https://www.lernsoftware-filius.de De help over het gebruik van Filius zit in het programma: druk op het vraagteken. ","description":"","tags":null,"title":"Filius","uri":"/tools/filius/"},{"content":"","description":"","tags":null,"title":"1","uri":"/yours/1/"},{"content":"","description":"","tags":null,"title":"10","uri":"/yours/10/"},{"content":"","description":"","tags":null,"title":"2","uri":"/yours/2/"},{"content":"","description":"","tags":null,"title":"3","uri":"/yours/3/"},{"content":"","description":"","tags":null,"title":"4","uri":"/yours/4/"},{"content":"","description":"","tags":null,"title":"5","uri":"/yours/5/"},{"content":"","description":"","tags":null,"title":"6","uri":"/yours/6/"},{"content":"","description":"","tags":null,"title":"7","uri":"/yours/7/"},{"content":"","description":"","tags":null,"title":"8","uri":"/yours/8/"},{"content":"","description":"","tags":null,"title":"9","uri":"/yours/9/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/"},{"content":"Some testing for different styles used in syntax highlightning and preformatted blocks.\nInline Code This is some very long inline code. Where does it wrap?\nWhat about wrapping short inline code if multiple sections are written side by side?\nWhat about wrapping short inline code if multiple sections are written side/by/side?\nWhat about wrapping long inline code if multiple sections are written side567 by34567 side567?\nWhat about wrapping long inline code if multiple sections are written side567/by34567/side567?\nCan we just use a simple HTML element ?\nBlock Code Code fences without any selected language { \"well\": \"some JSON in codefences in here\" } { \"well\": \"some JSON in HTML elements here\" } Block Preformatted Some preformatted stuff with markdown indention Some preformatted stuff in HTML elements ","description":"Some testing for different styles used in syntax highlightning and preformatted blocks","tags":null,"title":"Code","uri":"/tests/code/"},{"content":"Contributors Special thanks to everyone who has contributed to this project.\nMany thanks to Mathieu Cornic for his work on porting the Learn theme to Hugo.\nMany thanks to Andy Miller for initially creating the Learn theme for Grav.\nPackages and libraries autoComplete - A lightweight and powerful vanilla JavaScript completion suggester clipboard.js - A modern approach to copy text to clipboard Featherlight - A lightweight jQuery lightbox plugin Font Awesome - The internet’s icon library and toolkit jQuery - The “Write less, do more” JavaScript library jquery-svg-zoom-pan - A jQuery plugin to enable pan and zoom in SVG images Lunr - Enables a great search experience without the need for external, server-side, search services Mermaid - Generation of diagram and flowchart from text in a similar manner as markdown Perfect Scrollbar - A minimalistic but perfect custom scrollbar plugin RapiDoc - Create beautiful, customizable, interactive API documentation from OpenAPI Specifications Tooling GitHub - Continuous deployement, testing and hosting of this project’s sources and its documentation gren - A releasenotes generator for GitHub Hugo - The static site generator of your choice ","description":"","tags":null,"title":"Credits","uri":"/more/credits/"},{"content":"Some testing for different styles of image links.\nMarkdown Relative to page Relative to page up level Static External fully qualified External without scheme External without scheme and scheme separator HTML Relative to page Relative to page up level Static External fully qualified External without scheme External without scheme and scheme separator ","description":"Some testing for different styles of image links","tags":null,"title":"Images","uri":"/tests/images/"},{"content":"Informatica Actuele berichten Emmaus Arcade Zit je in de vierde klas? Dan kan de game die jij dit jaar gaat maken in de Emmaus Arcade! Inhoud Planning Hier vind je de lesplanners (met geplande toetsen en inlevermomenten), het vakoverzicht en de PTA’s.\nTheorie Hier vind je alle theorie per module.\nOpdrachten Hier vind je de praktische opdrachten. Praktische opdrachten zijn meestal tussen de vier en acht weken werk. Je hebt veel vrijheid en kunt er echt iets moois van maken.\nHulpmiddelen Hulpmiddelen zijn programma’s die we gebruiken om dingen te maken. Hulpmiddelen zijn dus gereedschap (Engels: tools) dat je gebruikt bij informatica.\n","description":"","tags":null,"title":"Informatica","uri":"/"},{"content":"Some testing for different styles of links.\nMarkdown Relative to page: Relative to page up level: Static: ","description":"Some testing for different styles of links","tags":null,"title":"Links","uri":"/tests/links/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/"},{"content":"Placeholder…\n","description":"","tags":null,"title":"The one and only hidden child","uri":"/yours/children-1/"}]